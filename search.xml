<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[html]]></title>
    <url>%2F2018%2F06%2F13%2Fhtml%2F</url>
    <content type="text"><![CDATA[html结构12345678910&lt;!--告诉浏览器使用什么样的html或者xhtml来解析html文档--&gt;&lt;!DOCTYPE html&gt; &lt;!--文档的开始结束标签，说明这是一个html文档--&gt;&lt;html&gt;xxx&lt;/html&gt; &lt;!--出现在文档的开头部门。标签内的东西不会在浏览器的文档窗口显示--&gt;&lt;head&gt;xxx&lt;/head&gt; &lt;!--定义网页标题，在浏览器标题栏显示--&gt;&lt;title&gt;xxx&lt;title/&gt;&lt;!--网页主体部分--&gt;&lt;body&gt;xxx&lt;/body&gt; 常用标签&lt;!DOCTYPE&gt;标签此标签可告知浏览器文档使用哪种 HTML 或 XHTML 规范。 BackCompat：怪异模式，浏览器使用自己的怪异模式解析渲染页面。 CSS1Compat：标准模式，浏览器使用W3C的标准解析渲染页面。内常用标签标签123456789&lt;!--&lt;meta&gt;标签共有两个属性，分别是name和http-equiv属性，两个属性具有不同的属性值--&gt;&lt;!--name属性主要用于描述网页，对应的属性值是content,content中的值是便于搜索引擎机器人查找和分类信息用的--&gt;&lt;meta name="kewwords" content="meta属性，meta参数值"&gt;&lt;meta name="description" content="description对应的值是搜索引擎描述用的"&gt;&lt;!--http-equiv标签,相当于http的文件头作用，它可以向浏览器传回一些有用的信息，以帮助正确地显示网页内容--&gt;&lt;!--即2秒后跳转到百度--&gt;&lt;meta http-equiv="Refresh" content="2;URL=https://www.baidu.com"&gt; &lt;!--编码格式--&gt;&lt;meta http-equiv="content-Type" charset="utf-8"&gt; 非标签123456&lt;title&gt;zhangdaxiang&lt;/title&gt;&lt;!--即网页的icon小图标--&gt;&lt;link rel="icon" href="http://xxxxx.ico"&gt;&lt;!--引入css和js--&gt;&lt;link rel="stylesheet" href="css.css"&gt;&lt;scrip src="js.js"&gt;&lt;/scrip&gt; 内常用标签块级标签和内联标签1234&lt;!--&lt;div&gt;只是一个块级元素，并无实际的意义。主要通过CSS样式为其赋予不同的表现--&gt;&lt;div&gt;xxx&lt;/div&gt;&lt;!--&lt;span&gt;表示了内联行(行内元素),并无实际的意义,主要通过CSS样式为其赋予不同的表现--&gt;&lt;span&gt;xxx&lt;/span&gt; 所谓块元素，是以另起一行开始渲染的元素，行内元素则不需另起一行。如果单独在网页中插入这两个元素，不会对页面产生任何的影响。这两个元素是专门为定义CSS样式而生的。 其他常用的基本标签1234567891011121314151617181920212223242526&lt;!--n的取值范围是1-6；从大到小，分别表示不同大小标题--&gt;&lt;h3&gt;xxx&lt;/h3&gt;&lt;!--段落标签，包裹的内容被换行，并且与上下内容有一行空白--&gt;&lt;p&gt;xxx&lt;/p&gt;&lt;!--两个都是加粗标签，&lt;b&gt;标签仿佛已经被弃用了--&gt;&lt;b&gt; &lt;strong&gt;&lt;!--为文字加上一条斜线--&gt;&lt;strike&gt;&lt;!--文字变成斜体--&gt;&lt;em&gt;&lt;!--上角标和下角标--&gt;&lt;sup&gt; &lt;sub&gt;&lt;!--换行--&gt;&lt;br&gt;&lt;!--水平线--&gt;&lt;hr&gt;&lt;!--特殊字符--&gt;&amp;lt;&amp;gt;&amp;quot;&amp;copy;&amp;reg;&lt;!--图形标签&lt;img&gt;--&gt;&lt;img src="要显示图片的路径" alt="图片没有加载成功时的提示" title="鼠标悬浮时的提示信息" width="图片的宽" height="图片的高 (宽高两个属性只用一个会自动等比缩放)"&gt;&lt;!--超链接标签(锚标签)--&gt;&lt;a href="" target="_blank"&gt;click&lt;/a&gt;&lt;!--href属性指定目标网页地址。该地址可以有几种类型：1.绝对URL - 指向另一个站点（比如 href="http://www.baidu.com）2.相对URL - 指当前站点中确切的路径（href="index.html"）3.锚URL - 指向页面中的锚（href="#id"）--&gt; 列表标签123456789101112131415&lt;!--无序列表 [type属性：disc(实心圆点)(默认)、circle(空心圆圈)、square(实心方块)]--&gt;&lt;ul&gt; &lt;li&gt;xxx&lt;/li&gt; &lt;li&gt;xxx&lt;/li&gt;&lt;/ul&gt;&lt;!--有序标签--&gt;&lt;ol&gt; &lt;li&gt;xxx&lt;/li&gt; &lt;li&gt;xxx&lt;/li&gt;&lt;/ol&gt;&lt;!--自定义标签--&gt;&lt;dl&gt; &lt;dt&gt;列表标题&lt;/dt&gt; &lt;dl&gt;列表项&lt;/dl&gt;&lt;/dl&gt; 表格标签12345678910111213141516171819202122&lt;!--&lt;tr&gt;: table row&lt;th&gt;: table head cell&lt;td&gt;: table data cell属性：border: 表格边框；cellpadding: 内边距；cellspacing: 外边距；width: 像素，百分比(最好通过css来设置)rowspan: 单元格横跨多少行colspan: 单元格横跨多少列(即合并单元格)--&gt;&lt;table&gt; &lt;tr&gt; &lt;th&gt;标题&lt;/th&gt; &lt;th&gt;标题&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;内容&lt;/td&gt; &lt;td&gt;内容&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 表单标签表单用于向服务器传输数据，从而实现用户与Web服务器的交互。表单属性：1.action:表单提交到哪,一般指向服务器端一个程序，比如https://www.baidu.com/web2.methon:表单提交方式,有post和get,默认就是get表单元素是允许用户在表单中输入内容,比如：文本域(textarea)、下拉列表、单选框(radio-buttons)、复选框(checkboxes)等等。 1234&lt;form&gt;input 元素&lt;!--input标签的name和values是传输给服务器的键值对--&gt;&lt;/form&gt; 文本域12345678&lt;!--文本域通过&lt;input type="text"&gt;标签来设定，在表单中输入字母数字等--&gt;&lt;form action="https://www.baidu.com/web" method="get"&gt; FirstName:&lt;input type="text" name="firstname"&gt; FamilyName:&lt;input type="texxt" name="familyname"&gt;&lt;/from&gt;&lt;form&gt; &lt;textarea rows="10" cols="30"&gt;这是一个文本框&lt;/textarea&gt;&lt;/form&gt; 字段密码1234&lt;!--密码字段通过标签&lt;input type="password"&gt; 来定义,密码字段不会明文显示，会以星号或者远点代替--&gt;&lt;form&gt; Password:&lt;input type="password" name="password"&gt;&lt;/form&gt; 单选按钮12345&lt;!--&lt;input type="radio"&gt; 标签定义了表单单选框选项,单选按钮的两个name是一致的，values是不一致的--&gt;&lt;form&gt; &lt;input type="radio" name="sex" value="male"&gt;Male&lt;br&gt; &lt;input type="radio" name="sex" value="female"&gt;Female&lt;/form&gt; 复选框12345&lt;!--&lt;input type="checkbox"&gt; 定义了复选框. 需要从若干给定的选择中选取一个或若干选项--&gt;&lt;form&gt; &lt;input type="checkbox" name="vehicle" value="bike"&gt;I have a bike&lt;br&gt; &lt;input type="checkbox" name="vehicle" value="car"&gt;I have a car&lt;/form&gt; 提交按钮1234567&lt;!--&lt;input type="submit"&gt;定义了提交按钮--&gt;&lt;!--当用户单击确认按钮时，表单的内容会被传送到另一个文件。表单的动作属性定义了目的文件的文件名。由动作属性定义的这个文件通常会对接收到的输入数据进行相关的处理--&gt;&lt;form name="input" action="www.baidu.com" methon="get"&gt; username:&lt;input type="text" name="username"&gt;&lt;br&gt; password:&lt;input type="password" name="password"&gt; &lt;input type="submit" value="Submit"&gt;&lt;/form&gt; select下拉标签属性12345678&lt;form&gt; &lt;select name="cars"&gt; &lt;option value="volvo"&gt;volvo&lt;/option&gt; &lt;option value="audi"&gt;audi&lt;/option&gt; &lt;option value="fiat"&gt;fiat&lt;/option&gt; &lt;option value="saab"&gt;saab&lt;/option&gt; &lt;/select&gt;&lt;/form&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程和多进程]]></title>
    <url>%2F2018%2F06%2F10%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%A4%9A%E8%BF%9B%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[threading模块线程对象的创建Thread类直接创建1234567891011121314import threadingimport timedef countNum(n): #定义线程需要运行的函数 print("running on number:%s"%n) time.sleep(3) if __name__ == '__main__': t1 = threading.Thread(target=countNum,args=(23,)) t2 = threading.Thread(target=countNum,args=(24,)) t1.start() #启动进程 t2.start() print("ending!") Thread类继承式创建12345678910111213141516171819import threadingimport timeclass MyThread(threading.Thread): def __init__(self,num): threading.Thread.__init__(self) self.num = num def run(self): print("running on number:%s"%self.num) time.sleep(3) t1=MyThread(56) #即实例化MyThreadt2=MyThread(78)t1.start() #即调用实例对象的run()方法t2.start() print("ending!") Thread类的实例方法join()和setDaemon()方法12345678910111213141516171819202122232425262728293031323334353637383940414243# join()：在子线程完成运行之前，这个子线程的父线程将一直被阻塞。# setDaemon(True)： ''' 将线程声明为守护线程，必须在start() 方法调用之前设置，如果不设置为守护线程程序会被无限挂起。 当我们在程序运行中，执行一个主线程，如果主线程又创建一个子线程，主线程和子线程 就分兵两路，分别运行，那么当主线程完成 想退出时，会检验子线程是否完成。如果子线程未完成，则主线程会等待子线程完成后再退出。但是有时候我们需要的是只要主线程 完成了，不管子线程是否完成，都要和主线程一起退出，这时就可以 用setDaemon方法啦''' import threadingfrom time import ctime,sleepdef music(name): print('&#123;name&#125; Begin listen music &#123;time&#125;'.format(name=name,time=ctime())) sleep(3) print('&#123;name&#125; End listen music &#123;time&#125;'.format(name=name,time=ctime()))def blog(name): print('&#123;name&#125; Begin write blog &#123;time&#125;'.format(name=name,time=ctime())) sleep(5) print('&#123;name&#125; End write blog &#123;time&#125;'.format(name=name,time=ctime()))t1 = threading.Thread(target=music,args=('Tony',))t2 = threading.Thread(target=blog,args=('Xiaoming',))thread = []thread.append(t1)thread.append(t2)if __name__ == '__main__': t2.setDaemon(True) #设在start()之前，主线程结束,则该守护线程也结束。 for t in thread: t.start() #t.join() #这里加join()的话,则会在t1线程结束前阻塞主线程，的for循环，t2和主线程不执行 #t1.join()#这里加join()，t1线程和t2线程同时执行，主线程阻塞 #t2.join() sleep(2) print('End!!') 当daemon被设置为True时，如果主线程退出，那么子线程也将跟着退出，反之，子线程将继续运行，直到正常退出。ps.在python3.5自带的IDE里面貌似有BUG，主线程结算之后还是会接着运行声明的守护线程。 多线程实例其他方法12345678#Thread实例对象的方法 #isAlive():返回线程是否活动 #getName():返回线程名 #setName():设置线程名称#threading模块其他方法 #threading.currentThread(): 返回当前的线程变量 #threading.enumerate():返回正在运行的线程list。正在运行包括启动后和结束前，不包括启动前和终止后的线程。 #threading.activeCount():返回正在运行的线程数，和len(threading.enumerate())返回相同值。 GIL]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>threading</tag>
        <tag>multiprocessing</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IO模型]]></title>
    <url>%2F2018%2F06%2F06%2FIO%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[对于一个network IO (这里我们以read举例)，它会涉及到两个系统对象，一个是调用这个IO的process (or thread)，另一个就是系统内核(kernel)。当一个read操作发生时，它会经历两个阶段： 等待数据准备 (Waiting for the data to be ready)*将数据从内核拷贝到进程中 (Copying the data from the kernel to the process) 以下几种IO Model的区别就是在两个阶段上各有不同的情况。 Blocking IO(阻塞IO)在linux中，默认情况下所有的socket都是blocking，一个典型的读操作流程大概是这样：当用户进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据。对于network io来说，很多时候数据在一开始还没有到达（比如，还没有收到一个完整的UDP包），这个时候kernel就要等待足够的数据到来。而在用户进程这边，整个进程会被阻塞。当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。所以，blocking IO的特点就是在IO执行的两个阶段都被block了。 non-Blocking IO(非阻塞IO)linux下，可以通过设置socket使其变为non-blockingsetblocking(False)。当对一个non-blocking socket执行读操作时，流程是这个样子：从图中可以看出，当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。所以，用户进程其实是需要不断的主动询问kernel数据好了没有。需要注意，拷贝数据整个过程，进程仍然是属于阻塞的状态。即”非阻塞将大的整片时间的阻塞分成N多的小的阻塞, 所以进程不断地有机会 ‘被’ CPU光顾”。 IO multiplexing(IO多路复用)IO多路复用即为select,poll,epoll。好处就在于单个process就可以同时处理多个网络连接的IO。基本原理就是select,poll,epoll会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。它的流程如图：当用户进程调用了select，那么整个进程会被block，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。这个图和blocking IO的图其实并没有太大的不同，事实上，还更差一些。因为这里需要使用两个system call (select 和 recvfrom)，而blocking IO只调用了一个system call (recvfrom)。但是，用select的优势在于它可以同时处理多个connection。（多说一句。所以，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。select,poll,epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。）在IO multiplexing Model中，实际中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。12345678910111213141516171819202122232425262728293031323334353637383940414243#***********************server.pyimport socketimport selectsk=socket.socket()sk.bind(("127.0.0.1",8800))sk.listen(5)sk.setblocking(False)inputs=[sk,]while True: r,w,e=select.select(inputs,[],[],5) print(len(r)) for obj in r: if obj==sk: conn,add=obj.accept() print("conn:",conn) inputs.append(conn) else: data_byte=obj.recv(1024) print(str(data_byte,'utf8')) if not data_byte: inputs.remove(obj) continue inp=input('回答%s: &gt;&gt;&gt;'%inputs.index(obj)) obj.sendall(bytes(inp,'utf8')) print('&gt;&gt;',r)#***********************client.pyimport socketsk=socket.socket()sk.connect(('127.0.0.1',8802))while True: inp=input("&gt;&gt;&gt;&gt;") # how much one night? sk.sendall(bytes(inp,"utf8")) data=sk.recv(1024) print(str(data,'utf8')) Asynchronous IO(异步IO)linux下的asynchronous IO其实用得很少。先看一下它的流程：用户进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。 IO模型比较]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos grub修改密码]]></title>
    <url>%2F2018%2F04%2F02%2FCentos-grub%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81%2F</url>
    <content type="text"><![CDATA[在linux中，grub是用来驱动系统内核的。有时候，我们也可以通过grub来修改root密码，只要在内核启动方式选择单用户启动就可以了（init 1）。为了保险起见，我们可以设置grub密码，来防止别人通过以上途径修改root密码。更改grub配置文件,1vim /etc/grub.conf 找到文件里面的title关键字，在title上面加个password就可以加密grub，在下面价格password就可以在进入系统的时候加密。如果我们需要md5加密这些密码的话，可以使用1grub-md5-crypt 输出一串加密后的字符串，复制，然后在/etc/grub.conf中就是password --md5 字符串]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sqlserver分区表]]></title>
    <url>%2F2018%2F01%2F15%2Fsqlserver%E5%88%86%E5%8C%BA%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[分区表的定义一般情况下，我们建立一个数据库的表，表里面的数据都会放在同一个文件里面。但是如果是分区表的话，表数据会根据我们自定义的规则给存放到不同的文件中。这样其实就相当于将一个大的数据文件拆分为多个小文件，这样文件的大小随着拆分而减小，可以得到硬件系统方面的假期。而且可以将这些小文件放在不同磁盘下的多个CPU来进行处理，大大提升数据的性能。概括一下，分区表的优势主要体现在：提供性能：这个是大多人数分区的目的，把一个表分部到不同的硬盘或其他存储介质中，会大大提升查询速度。提高稳定性：当一个分区出了问题，不会影响其他分区，仅仅是当前坏的分区不可用。便于管理：把一个大表分成若干个小表，则备份和恢复的时候不再需要备份整个表，可以单独备份分区。存档：将一些不太常用的数据，单独存放。如：将1年前的数据记录分到一个专门的存档服务器存放。但是这样仅限于大数据量的数据表，对于小数据量的表。这样还会产生不必要的开销，得不偿失。 创建文件组分区是要把一个表数据拆分为若干子集合，也就是把把一个数据文件拆分到多个数据文件中，然而这些文件的存放可以依托一个文件组或者多个文件组，由于多个文件组可以提高数据库的访问并发量，还可以把不同的分区配置到不同的磁盘中提高效率，所以创建时建议分区跟文件组个数相同。 创建文件组创建文件组的语法如下：1ALTER DATABASE &lt;数据库名&gt; ADD filegroup &lt;文件组名&gt; 1234---创建数据库文件组alter database testDB add filegroup ByBirGroup1alter database testDB add filegroup ByBirGroup2alter database testDB add filegroup ByBirGroup3 创建数据文件到文件组里面创建数据文件到文件组的语法如下：12ALTER DATABASE &lt;数据库名称&gt; ADD FILE &lt;数据标识&gt; TO FILEGROUP &lt;文件组名称&gt;---&lt;数据标识&gt; （name:文件名，fliename:物理路径文件名，size:文件初始大小kb/mb/gb/tb，filegrowth:文件自动增量kb/mb/gb/tb/%,maxsize:文件可以增加到的最大大小kb/mb/gb/tb/unlimited） 123456789alter database testDB add file (name=N'ByBirGroup1',filename=N'D:\Program Files\Microsoft SQL Server\MSSQL11.MSSQLSERVER\MSSQL\DATA\testDB1.mdf',size=5Mb,filegrowth=1mb)to filegroup ByBirGroup1alter database testDB add file (name=N'ByBirGroup2',filename=N'D:\Program Files\Microsoft SQL Server\MSSQL11.MSSQLSERVER\MSSQL\DATA\testDB2.mdf',size=5Mb,filegrowth=1mb)to filegroup ByBirGroup2alter database testDB add file (name=N'ByBirGroup3',filename=N'D:\Program Files\Microsoft SQL Server\MSSQL11.MSSQLSERVER\MSSQL\DATA\testDB3.mdf',size=5Mb,filegrowth=1mb)to filegroup ByBirGroup3 查询当前的所有文件组12SELECT name,type_desc,physical_name,state_desc,size,growthFROM sys.database_files 可以看到，成了。 分区表的操作步骤分区表分为三部分：分区函数，分区框架和分区表。他们之间的关系是：分区表依赖于分区构架，分区构架又依赖分区函数。所以定义分区表的顺序是定义分区函数-&gt;定义分区构架-&gt;定义分区表。我们实际操作的时候，需要有一张需要分区的表： 定义分区函数分区函数的作用是判断一行数据属于哪一个分区，通过在分区函数中设定边界值来使得根据行中特殊列的值来确定分区，比如上面的分区表：假如选择的是id列，那就是int类型，那么分区可以指定为1-100w是一个分区，100-200w是一个分区。假如选择的是birthday列，那就是datetime类型可以指定为2014-01-01至2017-01-01一个分区，2017-01-01以后一个分区。放一张CareySon大佬的图，方便理解。定义分区函数的语法如下：1234CREATE PARTITION FUNCTION partition_function_name ( input_parameter_type )AS RANGE [ LEFT | RIGHT ] FOR VALUES ( [ boundary_value [ ,...n ] ] ) [ ; ] 可以看到，定义函数的语法中，并没有涉及到具体的表，这是因为分区函数并不和具体的表相关联。其中的Range left和right决定这个边界值应该归属于左边还是右边。创建分区函数:123456---创建分区函数CREATE PARTITION FUNCTION Fun_test_zyz_birthday(DATETIME)AS RANGE LEFT FOR VALUES('2004-01-01','2007-01-01')--查看分区函数是否创建成功SELECT * FROM sys.partition_functions 查询结果如图所示： 定义分区框架分区函数决定了数据该分到哪个分区，而分配每个分区属于哪个文件组，则需要依赖分区框架。定义分区框架的语法如下：1234CREATE PARTITION SCHEME partition_scheme_nameAS PARTITION partition_function_name[ ALL ] TO ( &#123; file_group_name | [ PRIMARY ] &#125; [ ,...n ] )[ ; ] 根据之前的分区函数和文件组，可以得到：123456--基于之前的分区函数创建分区构架schemaCREATE PARTITION SCHEME SchemaForParirionAS PARTITION Fun_test_zyz_birthday --这个是之前创建的分区函数TO(ByBirGroup1,ByBirGroup2,ByBirGroup3) --FileGroup1是自己添加的文件组，因为有两个分界值，3个分区，所以要指定3个文件组，也可以使用ALL所谓的分区指向一个文件组--查看已创建的分区构架SELECT * FROM sys.partition_schemes 定义分区表需要知道一点的是，一个表在创建的时候就要决定是否是分区表了，虽然大多数情况下，我们是因为一个表的数据过大才决定分区的。所以，在创建表的时候确立为分区表123456CREATE TABLE [dbo].[test_zyz]( [id] [INT] NOT NULL, [name] [VARCHAR](50) NULL, [age] [INT] NULL, [birthday] [DATETIME] PRIMARY KEY NOT NULL)ON SchemaForParirion([birthday]) --SchemaForPartition是刚刚定义的分区架构，括号内为指定的分区列 插入测试数据可以通过下列语句来查看分区状况：123456789101112131415161718select convert(varchar(50), ps.name) as partition_scheme,p.partition_number, convert(varchar(20), ds2.name) as filegroup, convert(varchar(20), isnull(v.value, ''), 120) as range_boundary, str(p.rows, 9) as rowsfrom sys.indexes i INNER JOIN sys.partition_schemes ps on i.data_space_id = ps.data_space_id INNER JOIN sys.destination_data_spaces ddson ps.data_space_id = dds.partition_scheme_id INNER JOIN sys.data_spaces ds2 on dds.data_space_id = ds2.data_space_id INNER JOIN sys.partitions p on dds.destination_id = p.partition_numberand p.object_id = i.object_id and p.index_id = i.index_id INNER JOIN sys.partition_functions pf on ps.function_id = pf.function_id LEFT JOIN sys.Partition_Range_values v on pf.function_id = v.function_idand v.boundary_id = p.partition_number - pf.boundary_value_on_right WHERE i.object_id = object_id('test_zyz') --此处是表名and i.index_id in (0, 1) order by p.partition_number 可以看到各分区的具体数量查询某个分区的语法是：12SELECT * FROM test_zyzWHERE $partition.Fun_test_zyz_birthday(birthday)=2 ---$partition.分区函数(分区列) 分区表的分割与合并分区表的分割分区表的分割就相当于新建一个分区，将原有的分区内需要被分割的内容插入到新建的分区中，然后删除这部分内容。新加入一个分割点：2009-01-01。如图所示：对于上图的操作，分割时候，被分割的分区3内的内容复制到分区4，然后删除分区3中对于的部分。但是这种操作非常消耗IO，并且会在分割的过程中锁定分区3的内容，而且这个操作所产生的日志是被转移数据的4倍。所以最后在建表的时候就考虑到以后的分割点。分区分割分为两个步骤：首先要告诉SQL Server新建立的分区放到哪个文件组。建立新的分割点。现在增加一条测试数据：12INSERT INTO test_zyz(name,age,birthday)VALUES('xiaoming5',20,'2011-01-01 00:00:00.000') 执行长查询，得到：接下来可以执行分割操作：12345--分割出来的分区数据存在在哪个文件组ALTER PARTITION SCHEME SchemaForParirion NEXT USED 'ByBirGroup2'--添加分割点ALTER PARTITION FUNCTION Fun_test_zyz_birthday()SPLIT RANGE('2009-01-01') 再次查询可以得到： 分区表的合并分区表的合并可以看做是分割的逆操作，合并时必须提供分割点，且分割点存在，不然会报错：123--提供分割点，合并分区ALTER PARTITION FUNCTION Fun_test_zyz_birthday()MERGE RANGE('2009-01-01') 分区表数据迁移分区表一个分区的数据迁移到普通表从分区到普通表，需要满足以下条件：普通表必须建立在分区表切换出的分区所在的文件组上。普通表的表结构和分区表一致。普通表上的索引要和分区表一致，包括聚集索引和非聚集索引。普通表必须是空表。首先，创建和test_zyz结构相同的普通表：12345678910CREATE TABLE [dbo].[test_zyz2]( [id] [INT] IDENTITY(1,1) NOT NULL, [name] [VARCHAR](50) NULL, [age] [INT] NULL, [birthday] [DATETIME] NOT NULL, CONSTRAINT [PK_test_zyz2] PRIMARY KEY NONCLUSTERED ( [birthday] ASC)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [ByBirGroup2]) ON [ByBirGroup2] ---表格建在分区2上，这样我们就能迁移分区2的数据 然后从分区表中复制数据到普通表：12--将test_zyz分区表中的第2分区数据复制到普通表中alter table testdb..test_zyz switch partition 2 to testdb..test_zyz2 可以看到，分区2的数据已经没有了,迁移到了test_zyz2表中但是要注意的是，从普通表test_zyz2中还原数据到test_zyz这个分区表分区2的时候，还要新增另外一个条件：普通表必须加上和分区数据范围一致的 check 约束条件。12ALTER TABLE testdb..test_zyz2 ADD CONSTRAINT CK_SalesOrders_BirthdayCHECK(birthday&gt;'2004-01-01' AND birthday&lt;='2007-01-01') ---之前分区函数是left，所以应该是&lt;='2007-01-01' 成功建立check约束条件以后，就可以还原数据了：12--将普通表中的数据复制到test_zyz分区表中的第2分区alter table testdb..test_zyz2 switch to testdb..test_zyz partition 2 结语分区表分区切换并没有真正去移动数据,而是SQL Server在系统底层改变了表的元数据。因此分区表分区切换是高效、快速、灵活的。利用分区表的分区切换功能，我们可以快速加载数据到分区表、卸载分区数据到普通表，然后TRUNCATE普通表，以实现快速删除分区表数据，也可以快速迁移分区到历史表。本文学习自理解SQL SERVER中的分区表，感谢宋沄剑大大。]]></content>
      <tags>
        <tag>sqlserver</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jupyter notebook和charts实现数据可视化]]></title>
    <url>%2F2017%2F12%2F14%2Fjupyter-notebook%E5%92%8Ccharts%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%2F</url>
    <content type="text"><![CDATA[安装jupyterJupyter Notebook是一个交互式笔记本，是一个功能非常强大的交互式工具。一般来说，我们安装的话，只要使用pip install jupyter就可以了。但是如果安装失败，我们也可以使用anaconda这个包管理工具来安装，这个还是比较方便的。这里有一个jupyter notebook的教程，比较简单，但是也还不错。教程地址 chart模块安装首先pip安装charts模块，pip install charts。这个时候试试import是否成功，如果成功，那么OK。如果失败的话，找到site-packages文件路径，打开charts文件夹，将charts文件下的7个文件替换，替换地址为文件地址。 柱状图接下来我们把之前爬取到的赶集网的数据用图形表示出来,这样数据比较起来更加直观。12345678910111213141516171819202122232425import pymongoimport charts#连接之前爬取的数据，在Mongodb里面client = pymongo.MongoClient('localhost',27017)ganji = client['ganji']ganji3 = ganji['ganji3']cate_list = []#取之前爬取到的cates属性的第二个标签来分类cate_list = [i['cates'][2] for i in ganji3.find()]#set来进行去重，取出不重复的标签cate_index = list(set(cate_list))#取出每个标签对应的数量cate_list = [i['cates'][2] for i in ganji3.find()]num_list = [cate_list.count(i) for i in cate_index]#使用zip函数来一一对应def cate_num(): for k,v in zip(cate_index,num_list): data = &#123; 'name':k ,'data':[v] ,'type':'column' &#125; yield data#使用charts的plot方法生成柱状图charts.plot([i for i in cate_num()],show='inline',options=&#123;'title':&#123;'text':'ganji_cate'&#125;&#125;) 折线图1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import pymongofrom datetime import date,timedeltaimport charts#连接Mongodbclient = pymongo.MongoClient('localhost',27017)ganji3 = client['ganji']ganjisheet = ganji3['ganji3']#统一日期格式for i in ganjisheet.find(): if len(i['pub_date'].split('.'))&gt;1: ganjisheet.update(&#123;'_id':i['_id']&#125;,&#123;'$set':&#123;'pub_date':'-'.join(i['pub_date'].split('.'))&#125;&#125;) else: pass#返回一段时间，timedelte()和data()是处理日期的函数def date_num(date1,date2): #data()函数输入三个自然数，输出一个字符串 start_date = date(int(date1.split('-')[0]),int(date1.split('-')[1]),int(date1.split('-')[2])) end_date = date(int(date2.split('-')[0]),int(date2.split('-')[1]),int(date2.split('-')[2])) while start_date &lt;= end_date: yield start_date #timedelta(1)就表示1天 start_date += timedelta(1)#返回data生成器def ares_num(areas,date1,date2): for area in areas: area_num = [] for date in date_num(date1,date2): num = ganjisheet.find(&#123;'pub_date':date.strftime('%Y-%m-%d'),'area':area&#125;).count() area_num.append(num) data = &#123;'name':area ,'data':area_num ,'type':'line'&#125; yield data#表格参数options = &#123; 'title': &#123;'text': '我是标题'&#125; ,'subtitle': &#123;'text': '我是副标题'&#125; ,'xAxis': &#123;'categories': [i.strftime('%Y-%m-%d') for i in date_num('2016-01-01','2016-01-10')] ,'title':&#123;'text':'x轴标题'&#125;&#125; ,'yAxis':&#123;'title':&#123;'text':'y轴标题'&#125;&#125;&#125;series = [i for i in ares_num(['朝阳','海淀','通州'],'2016-01-01','2016-01-10')]charts.plot(series,show = 'inline',options = options)]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>charts</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sqlserver存储过程小技巧]]></title>
    <url>%2F2017%2F12%2F07%2Fsqlserver%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E5%B0%8F%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[数据写入表今天碰到一个问题，执行一个存储过程时1EXEC proc_orderday 返回了一系列的数据，但是并不能对这些数据进行处理,我们想要对这些数据进行操作的话，就要写把他们写入一个表。需要注意的是，一定要先建表，才能写入，直接select * into是不行的。12345678#先建一个临时表CREATE TABLE #tmp( ...)#写入存储过程数据INSERT INTO #tmpEXEC proc_orderday]]></content>
      <categories>
        <category>sqlserver</category>
      </categories>
      <tags>
        <tag>sqlserver</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python之路(8):IO编程]]></title>
    <url>%2F2017%2F12%2F04%2Fpython%E4%B9%8B%E8%B7%AF(8)IO%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[平常，我们用电脑浏览器访问页面，我们对网页服务器说，我们要你的HTML，这个是向网页服务器发数据，叫作Output。然后网页服务器把数据传过来，我们接收，这个叫作Input。再比如说我们从内存写入到磁盘文件，是Output，从磁盘文件读到内存是Input。这个地方我之前经常弄混，后来记住了，这个”进出”是相对于内存来说的，就明了了。 文件读写文件读写是最基本的IO操作。现代操作系统，一般不允许程序直接操作磁盘。所以，读写文件都是请求操作系统打开一个文件对象（通常称为文件描述符），然后通过系统提供的接口把数据写入这个文件对象，或者从这个文件对象读取数据。 读文件我们可以通过open()函数传入文件名和标识符来打开一个文件：1f=open('/users/text.txt','r') 这里的r表示这个文件是读。如果要打开的文件不存在，open()函数就会报出IOError的错误。如果打开成功，我们可以使用read()方法来读取文件的内容：1f.read() 操作完毕以后，需要用close()方法来关闭这个文件。如果不关闭的话，这个文件对象就会一直占用系统资源。而且如果open()报错的话，会影响程序接下去运行，我们一般用try...finally...的方法来解决这个问题：123456try: f = open('/user/text.txt','r') print(f.read())finally: if f: f.close() 这样太麻烦了，所以有一种用with的便捷的写法，这样写python会自己关闭文件：12with open('/user/text.txt','r'): print(f.read()) 这样就可以实现和上面一样的功能。要注意的是，read()方法会一次读取文件的所有内容。可以使用read(size)来一次读取size大小的内容，反复调用，从而获得全部。也可以使用readlines()来获取文件的一行内容。这些都是在utf-8编码下文本的情况，如果要读取视频，图片等二进制的文件，就要使用rb标识符：1234with open('/user/picture1.jpg','rb') as f: print(f.read())#输出b'\xff\xd8\xff\xe1\x00\x18Exif\x00\x00...' # 十六进制表示的字节 如果文件对象不是utf-8，可以使用encoding参数来读取，比如说gbk格式的：12with open('/user/text.txt','r',encoding='gbk') as f: print(f.read()) 有时候如果文件编码不规范的话，很容易产生错误，最简单方法是忽略，open()有一个errors来实现这个：12with open('/user/text.txt','r',encoding='gbk',errors='ignore') as f: print(f.read()) 写文件写文件和读文件的唯一区别就是把标识符改成w和wb。而且如果没有close()的话，会导致一部分写入的数据没有保存，所以一定要close()。同样的，with写法可以帮我们自动close()。 目录操作python的目录操作基本都在内置的os模块中，使用前记得导入。 环境变量python中的环境变量，全部保存在os.environ中：1234#导入os模块import os#查看环境变量os.environ 如果想查看某个环境变量的值，比如PATH，可以使用os.environ.get(&#39;key&#39;)：1234567os.environ.get('PATH')#输出'C:\\Ruby23-x64\\bin;C:\\Program Files (x86)\\Intel\\iCLS Client\\;'#如果环境变量不存在os.environ.get('x','default')#输出'default' 操作文件和目录python操作文件的函数都在os模块和os.path模块中：12345678910#查看当前目录的绝对路径&gt;&gt;&gt; os.path.abspath('.')'C:\\Users\\Administrator\\Desktop'#在某个目录下创建一个新目录，把新目录的完整路径表示出来&gt;&gt;&gt; os.path.join('\\test1\\test2','test3')'\\test1\\test2\\test3'#然后创建一个目录os.mkdir('C:\\Users\\Administrator\\Desktop\\test1\\test2\\test3')#删除目录os.rmdir('C:\\Users\\Administrator\\Desktop\\test1\\test2\\test3') 想要拼接两个路径，使用os.path.join()函数。在Linux/Unix/Mac下返回：1part-1/part-2 在Windows下会返回：1part-1\\part-2 还可以使使用os.path.split()和os.path.splitext()这两个函数来分割路径：123456#这个函数分割至文件名&gt;&gt;&gt; print(os.path.split('C:\\Users\\Administrator\\Desktop\\test1\\test2\\test3.txt'))('C:\\Users\\Administrator\\Desktop\\test1\\test2', 'test3.txt')#这个函数分割至文件后缀名&gt;&gt;&gt; print(os.path.splitext('C:\\Users\\Administrator\\Desktop\\test1\\test2\\test3.txt'))('C:\\Users\\Administrator\\Desktop\\test1\\test2\\test3', '.txt') 如果当前目录下有一个文件名text3.txt，文件操作的比如重命名，删除可以用一下两个函数：123456#重命名os.rename('text3.txt','text4.txt')#当然也可以这样写os.rename('C:\\Users\\Administrator\\Desktop\\test1\\test2\\test3.txt','C:\\Users\\Administrator\\Desktop\\test1\\test2\\test4.txt')#删除os.remove('text3.txt') 可以使用以下两个函数来判定是否为目录和文件：1234#判定是否为目录os.path.isdir(path)#判定是否为文件os.path.isfile(path) 可以使用一下的代码来实现筛选出当前目录下所有.py文件：1[x for x in os.path.listdir('.') if os.path.isfile(x) and os.path.splitext(x)[1]=='py'] 但是os模块里面没有移动文件的函数。。。感觉很不方便。好在shutil模块中有类似的函数来补充使用。 序列化序列化一般情况下，我们在内存中执行程序，如果定义了一个变量：1d = dict(name='zhangdaxiang',age=23,city='hangzhou') 这样子，变量是存储在内存中的，如果我们在程序中改变了这个dict，而没有保存到磁盘里。结算程序时，变量占用的内存被回收，下次运行程序，这个变量还是没有改变之前的值。想把对象保存到磁盘，就要序列化。我们把变量变成可以存储或者传输的过程就叫作序列化。而把序列化对象重新读取到内存中，就称作反序列化。python中提供了pickle模块来实现这个需求。可以用pickle.dumps()序列化成一个bytes，也可以使用pickle.dump()直接把对象序列化然后写入file-like Object中：1234567891011#导入pickle模块import pickled = dict(name='zhangdaxiang',age=23,city='hangzhou')#打开一个file-like Object文件with open('dump.txt','wb') as f: #写入序列化对象 pickle.dump(d,f)#序列化bytes&gt;&gt;&gt; pickle.dumps(d)b'\x80\x03&#125;q\x00(X\x03\x00\x00\x00ageq\x01K\x17X\x04\x00\x00\x00nameq\x02X\x0c\x00\x00\x00zhangdaxiangq\x03X\x04\x00\x00\x00cityq\x04X\x08\x00\x00\x00hangzhouq\x05u.' 可以使用pickle.loads()直接把一个bytes对象反序列化，也可以用pickle.load()函数从一个file-like Object中反序列化对象：12345678910111213import pickle#打开一个file-like Objectwith open('dump.txt','rb') as f: #反序列化 d = pickle.load(f) #因为变量之前的内存已经回来，反序列化出来的变量虽然值和之前一样，但是并不是一个变量了 print(d)#直接反序列化bytesd = dict(name='zhangdaxiang',age=23,city='hangzhou')#反序列化bytes&gt;&gt;&gt; pickle.loads(pickle.dumps(d))&#123;'city': 'hangzhou', 'name': 'zhangdaxiang', 'age': 23&#125; json如果我们想在不同的程序直接传递数据，可以把对象转换成json格式，json格式就是一个字符串，所以任何程序都可以读取。python提供了一个json模块来完成转换，和序列化类似的，也有dump()和dumps()来转换成json，也有load()和loads()来把json转换成python对象。比如说转换一个dict对象：12345&gt;&gt;&gt; import json&gt;&gt;&gt; d = dict(name='zhangdaxiang',age=23,city='hangzhou') #返回json对象&gt;&gt;&gt; json.dumps(d)'&#123;"city": "hangzhou", "age": 23, "name": "zhangdaxiang"&#125;' 和序列化类似，dump()函数是直接把json写入一个file-like Object对象。反序列化的loads()和load()函数也类似：12345#定义json对象&gt;&gt;&gt; json_str = '&#123;"city": "hangzhou", "age": 23, "name": "zhangdaxiang"&#125;'#反序列化，返回dict&gt;&gt;&gt; json.loads(json_str)&#123;'name': 'zhangdaxiang', 'city': 'hangzhou', 'age': 23&#125; 从上面可以看出，json中的{}是对应python中的dict，这样就可以互相转换。但是更多的时候，我们是用一个类来表示一个对象，如果用json模块来转换的话，就会报TypeError的错误。不必惊慌，dumps()函数有一个可选参数default，这个参数可以把对象转换成可以转换为json的对象，然后就可以和之前转换dict一样转换了。一般情况下，我们可以定义一个函数把类转换为dict来解决：12345678910111213141516171819#导入jsonimport json#定义一个类class People(): def __init__(self,name,age,city): self.name = name self.age = age self.city = city#定义一个转化函数def People2dict(x): return &#123;'name': x.name ,'age':x.age ,'city':x.city&#125;#实例化类people = People('zhangdaxiang',23,'city')#转换为jsonprint(json.dumps(people,default=People2dict))#输出&#123;"age": 23, "city": "hangzhou", "name": "zhangdaxiang"&#125; 这样就和之前一样了。我们也可以使用一个偷懒的方法，因为类的实例一般都有__dict__方法的话，people.__dict__后就可以认为是一个dict。我们只需要如此操作即可：123print(json.dumps(people,default=lambda x:x.__dict__))#输出&#123;"name": "zhangdaxiang", "age": 23, "city": "hangzhou"&#125; 同样的，我们想要反序列化json字段的话，我们先用loads()返回一个dict，然后自定义一个函数来把dict传入object_hook来转化成类。123456789#定义json对象json_str = '&#123;"city": "hangzhou", "age": 23, "name": "zhangdaxiang"&#125;'#字典转化为类实例def dict2People(x): return People(x['name'],x['age'],x['city'])#反序列化print(json.loads(json_str,object_hook = dict2People))#输出&lt;__main__.People object at 0x0000000003496EB8&gt; 这样就打印出了实例对象的内存地址。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows7安装Scrapy与Pyspider]]></title>
    <url>%2F2017%2F10%2F26%2FWindows7%E5%AE%89%E8%A3%85Scrapy%E4%B8%8EPyspider%2F</url>
    <content type="text"><![CDATA[说的python上面的爬虫框架，最有名的当然是Scrapy了，但是感觉他对windows操作系统不太友好，安装的时候各种报错。这个也加深了我好好学习linux的决心。经过多次尝试，总结一下windows上安装Scrapy和Pyspider的步骤。 Scrapy要求Twisted.whl，Pyspider要求lxml.whl 更新pip（可选）1python -m pip install -U pip 安装wheel进入python目录下的scripts目录1cd D:\\Python35\Scripts 安装wheel1pip install wheel 下载whl找到并下载lxml与Twisted两个包。 安装whl安装.whl12pip install lxml-3.6.4-cp35-cp35m-win_amd64.whlpip install Twisted-16.6.0-cp35-cp35m-win_amd64.whl 安装Scrapy、PySpider12pip install scrapypip install pyspider]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python爬虫同时添加用户代理和ip代理]]></title>
    <url>%2F2017%2F10%2F21%2Fpython%E7%88%AC%E8%99%AB%E5%90%8C%E6%97%B6%E6%B7%BB%E5%8A%A0%E7%94%A8%E6%88%B7%E4%BB%A3%E7%90%86%E5%92%8Cip%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[为何要设置User Agent 通过一段时间的爬虫学习，也成功实现了一些小的爬取项目，有的时候会出现代码正确但是无法爬取的情况。通过科学上网，了解到了有一些网站对于爬虫访问会有一定的措施，如果一段时间内同一ip访问次数过多，就会当做爬虫程序予以封杀。所以，我们需要伪装自己的爬虫程序，了解到伪装大致需要添加用户代理以及ip代理。下面是设置UA代理和ip代理的过程。 常见的User AgentAndroid123Mozilla/5.0 (Linux; Android 4.1.1; Nexus 7 Build/JRO03D) AppleWebKit/535.19 (KHTML, like Gecko) Chrome/18.0.1025.166 Safari/535.19Mozilla/5.0 (Linux; U; Android 4.0.4; en-gb; GT-I9300 Build/IMM76D) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30Mozilla/5.0 (Linux; U; Android 2.2; en-gb; GT-P1000 Build/FROYO) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1 Firefox12Mozilla/5.0 (Windows NT 6.2; WOW64; rv:21.0) Gecko/20100101 Firefox/21.0Mozilla/5.0 (Android; Mobile; rv:14.0) Gecko/14.0 Firefox/14.0 Google Chrome12Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/27.0.1453.94 Safari/537.36Mozilla/5.0 (Linux; Android 4.0.4; Galaxy Nexus Build/IMM76B) AppleWebKit/535.19 (KHTML, like Gecko) Chrome/18.0.1025.133 Mobile Safari/535.19 iOS12Mozilla/5.0 (iPad; CPU OS 5_0 like Mac OS X) AppleWebKit/534.46 (KHTML, like Gecko) Version/5.1 Mobile/9A334 Safari/7534.48.3Mozilla/5.0 (iPod; U; CPU like Mac OS X; en) AppleWebKit/420.1 (KHTML, like Gecko) Version/3.0 Mobile/3A101a Safari/419.3 添加方法添加UA123456789import urllib.requesturl ='https://www.cnblogs.com/AndyChen2015/p/7418280.html'headers = ("User-Agent","Mozilla/5.0 (iPod; U; CPU like Mac OS X; en) AppleWebKit/420.1 (KHTML, like Gecko) Version/3.0 Mobile/3A101a Safari/419.3")opener = urllib.request.build_opener()opener.addheaders = [headers]#将opener安装为全局，让urlopen()访问时也添加对应报头urllib.request.install_opener(opener)data1 = opener.open(url)data2 = urllib.request.urlopen(url) 添加ip代理123456import urllib.requestip = "192.168.1.1"proxy = urllib.request.ProxyHandler(&#123;"http":ip&#125;)opener = urllib.request.build_opener(proxy,urllib.request.HTTPHandler)#将opener安装为全局urllib.request.install_opener(opener) 完整代码(两者同时添加)12345678910111213141516171819202122232425262728#同时使用ip代理以及用户代理import urllib.requestimport random#用户代理池和ip代理池uapools = ["Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.221 Safari/537.36 SE 2.X MetaSr 1.0","Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Trident/4.0; Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1) ; Maxthon/3.0)","Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0; Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1) ; QIHU 360EE)"]ippools = ["61.135.217.7","118.114.77.47","111.224.104.161"]url = 'http://www.baidu.com'#添加用户代理以及ip代理def ua(uapools,ippools): req = urllib.request.Request(url) req.add_header("User-Agent",random.choice(uapools)) proxy = urllib.request.ProxyHandler(&#123;"https":random.choice(ippools)&#125;) opener = urllib.request.build_opener(proxy,urllib.request.HTTPHandler) #将opener安装为全局 urllib.request.install_opener(opener) return reqif __name__ == '__main__': for i in range(20): req = ua(uapools,ippools) try: data = urllib.request.urlopen(req) print(len(data.read())) print(data.getcode()) except Exception as err: print(err)]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sqlserver存储过程中output和return之我见]]></title>
    <url>%2F2017%2F03%2F28%2Fsqlserver%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E4%B8%ADoutput%E5%92%8Creturn%E4%B9%8B%E6%88%91%E8%A7%81%2F</url>
    <content type="text"><![CDATA[今天老大把我叫去，和我说以后把数据库开发的一部分工作交给我。之前做的都是一些数据提取统计之类的活，虽然也写过几个存储过程，也大多数是提取类的。其中也用到了output这样的参数，但是之前没有好好地看过原理，只是根据之前已有的存储过程生搬硬套，总感觉对于output和return的理解不够。所以，今天就来总结一下这两个的用法。 四种参数1.input 这个参数只是将信息从应用程序传输到存储过程。2.inputoutput这个参数可以将信息从应用程序传输到存储过程，并可以将信息传输回应用程序。3.output这个参数可以只可以将信息从存储过程传输回应用程序。4.returnvalue 这个参数表示存储过程的返回值。存储过程参数列表中不显示该参数。它只和存储过程的 return 语句中的值相关联。 参数实例不带输入参数123456789101112131415IF OBJECT_ID('user_info') IS NOT NULL DROP PROC user_info --GO起到了分割sql脚本的作用，上下语句可以视为两个脚本GOCREATE PROC user_infoASSET NOCOUNT ONDECLARE @name VARCHAR(10)BEGIN SELECT @name = name FROM userinfoEND PRINT @nameSET NOCOUNT OFF--执行存储过程EXEC user_info 带输入参数123456789101112131415161718IF OBJECT_ID('user_info') IS NOT NULL DROP PROC user_info --GO起到了分割sql脚本的作用，上下语句可以视为两个脚本GOCREATE PROC user_info( @id INT)ASSET NOCOUNT ONDECLARE @name VARCHAR(10)BEGIN SELECT @name = name FROM userinfo WHERE id = @idEND PRINT @nameSET NOCOUNT OFF--执行存储过程EXEC user_info @id = 1 带return参数这里涉及到一个存储过程返回值的概念，和用select输出一个结果集不同的是，return返回的是一个数字。如果存储过程中有return，则返回return出来的值。如果没有return的话，则返回0。这样子是返回作用的行数，即全局变量@@ROWCOUNT：1234567891011121314151617IF OBJECT_ID('user_info') IS NOT NULL DROP PROC user_info --GO起到了分割sql脚本的作用，上下语句可以视为两个脚本GOCREATE PROC user_infoASSET NOCOUNT ONDECLARE @name VARCHAR(10)BEGIN SELECT @name = name FROM userinfoEND RETURN @@ROWCOUNTSET NOCOUNT OFF--执行存储过程DECLARE @result INTEXEC @result = user_info SELECT @result 这样的话就是没有return关键字，其实就是return 0：1234567891011121314151617IF OBJECT_ID('user_info') IS NOT NULL DROP PROC user_info --GO起到了分割sql脚本的作用，上下语句可以视为两个脚本GOCREATE PROC user_infoASSET NOCOUNT ONDECLARE @name VARCHAR(10)BEGIN SELECT @name = name FROM userinfoEND --RETURN @@ROWCOUNTSET NOCOUNT OFF--执行存储过程DECLARE @result INTEXEC @result = user_info SELECT @result 注意的是，这里的@@ROWCOUNT虽然现实影响的行数是3，但是@name只是最近的一个。 带有输出参数1234567891011121314151617181920212223IF OBJECT_ID('user_info') IS NOT NULL DROP PROC user_info --GO起到了分割sql脚本的作用，上下语句可以视为两个脚本GOCREATE PROC user_info( @id INT ,@name VARCHAR(10)='' OUTPUT)ASSET NOCOUNT ONBEGIN SELECT @name = name FROM userinfo WHERE id = @idEND SET NOCOUNT OFF--执行存储过程DECLARE @name VARCHAR(10)--要注意的是，这里要重新declare一次OUTPUT参数@name,而且如果使用了@id=3这样的调用写法，OUTPUT参数也要用@name = value这样的写法。--第一种写法EXEC user_info @id = 3,@name = @name OUTPUT--第二种写法EXEC user_info 3,@name OUTPUTSELECT @name 同时带return参数和output参数123456789101112131415161718192021222324IF OBJECT_ID('user_info') IS NOT NULL DROP PROC user_info --GO起到了分割sql脚本的作用，上下语句可以视为两个脚本GOCREATE PROC user_info( @id INT ,@name VARCHAR(10) OUTPUT )ASSET NOCOUNT ONDECLARE @age INT BEGIN SELECT @name = name,@age = age FROM userinfo WHERE id = @id RETURN @ageEND SET NOCOUNT OFF--执行存储过程DECLARE @name VARCHAR(10)DECLARE @age INT EXEC @age = user_info @id = 1,@name = @name OUTPUT --当然这也写也是可以的，就像之前提到的EXEC @age = user_info 1,@name OUTPUT SELECT @name,@age]]></content>
      <categories>
        <category>sqlserver</category>
      </categories>
      <tags>
        <tag>sqlserver</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS 6.X版本下安装vsftpd]]></title>
    <url>%2F2017%2F02%2F08%2FCentOS-6-X%E7%89%88%E6%9C%AC%E4%B8%8B%E5%AE%89%E8%A3%85vsftpd%2F</url>
    <content type="text"><![CDATA[今天老大让我搭建一个开源的发布项目叫瓦力，我打算在自己的虚拟机里面先进行测试，其中的一步需要我搭建一个FTP服务器，vsftpd在Linux下是比较有名的FTP服务器，我就来试试这个。 实验环境： Centos 6.5 安装vsftpd查看是否已经安装vsftpd1rpm -qa | grep vsftpd 如果没有，就安装，并设置开机启动12yum -y install vsftpdchkconfig vsftpd on 基于虚拟用户的配置所谓虚拟用户就是没有使用真实的帐户，只是通过映射到真实帐户和设置权限的目的。虚拟用户不能登录CentOS系统。 修改配置文件打开/etc/vsftpd/vsftpd.conf，做如下配置1234567anonymous_enable=NO # 设定不允许匿名访问local_enable=YES # 设定本地用户可以访问。注：如使用虚拟宿主用户，在该项目设定为NO的情况下所有虚拟用户将无法访问ascii_upload_enable=YESascii_download_nable=YES # 设定支持ASCII模式的上传和下载功能chroot_list_enable=YES # 使用户不能离开主目录chroot_list_file=/etc/vsftpd/chroot_list # 是否限制在主目录下的用户名单，至于是限制名单还是排除名单，这取决于chroot_local_user的值。pam_service_name=vsftpd # PAM认证文件名。PAM将根据/etc/pam.d/vsftpd进行认证 以下这些是关于vsftpd虚拟用户支持的重要配置项，默认vsftpd.conf中不包含这些设定项目，需要自己手动添加123guest_enable=YES # 设定启用虚拟用户功能guest_username=ftp # 指定虚拟用户的宿主用户，CentOS中已经有内置的ftp用户了user_config_dir=/etc/vsftpd/vuser_conf # 设定虚拟用户个人vsftp的CentOS FTP服务文件存放路径。存放虚拟用户个性的CentOS FTP服务文件(配置文件名=虚拟用户名) 进行认证首先，安装Berkeley DB工具，很多人找不到db_load的问题就是没有安装这个包。1yum install db4 db4-utils 然后，创建用户密码文本/etc/vsftpd/vuser_passwd.txt ，注意奇行是用户名，偶行是密码12test123456 接着，生成虚拟用户认证的db文件1db_load -T -t hash -f /etc/vsftpd/vuser_passwd.txt /etc/vsftpd/vuser_passwd.db 随后，编辑认证文件/etc/pam.d/vsftpd，全部注释掉原来语句，再增加以下两句：12auth required pam_userdb.so db=/etc/vsftpd/vuser_passwdaccount required pam_userdb.so db=/etc/vsftpd/vuser_passwd 最后，创建虚拟用户配置文件12mkdir /etc/vsftpd/vuser_conf/vi /etc/vsftpd/vuser_conf/test # 文件名等于vuser_passwd.txt里面的账户名，否则下面设置无效 内容如下1234567local_root=/ftp/www # 虚拟用户根目录,根据实际情况修改write_enable=YES # 可写anon_umask=022 # 掩码anon_world_readable_only=NOanon_upload_enable=YESanon_mkdir_write_enable=YESanon_other_write_enable=YES 设置Selinux12setsebool -P ftp_home_dir=1 #设置ftp可以使用home目录setsebool -P allow_ftpd_full_access=1 # 设置ftp用户可以有所有权限 设置FTP根目录权限123mkdir /ftp/www # 创建目录chmod -R 755 /ftpchmod -R 777 /ftp/www 最新的vsftpd要求对主目录不能有写的权限所以ftp为755，主目录下面的子目录再设置777权限 设置防火墙打开/etc/sysconfig/iptables 在-A INPUT –m state --state NEW –m tcp –p –dport 22 –j ACCEPT，下添加：1-A INPUT -m state --state NEW -m tcp -p -dport 21 -j ACCEPT 然后保存，并关闭该文件，在终端内运行下面的命令，刷新防火墙配置：1service iptables restart OK，运行service vsftpd start，你就可以访问你的FTP服务器了。 配置PASV模式vsftpd默认没有开启PASV模式，现在FTP只能通过PORT模式连接，要开启PASV默认需要通过下面的配置 打开/etc/vsftpd/vsftpd.conf，在末尾添加1234pasv_enable=YES # 开启PASV模式pasv_min_port=40000 # 最小端口号pasv_max_port=40080 # 最大端口号pasv_promiscuous=YES 在防火墙配置内开启40000到40080端口1-A INPUT -m state --state NEW -m tcp -p -dport 40000:40080 -j ACCEPT 重启iptabls和vsftpd12service iptables restartservice vsftpd restart 现在可以使用PASV模式连接你的FTP服务器了~ CentOS 7中默认使用Firewalld做防火墙，所以修改iptables后，在重启系统后，根本不管用。 Firewalld中添加端口方法如下：12firewall-cmd --zone=public --add-port=3306/tcp --permanentfirewall-cmd --reload]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git学习(4):自定义git]]></title>
    <url>%2F2017%2F01%2F31%2Fgit%E5%AD%A6%E4%B9%A0(4)%E8%87%AA%E5%AE%9A%E4%B9%89git%2F</url>
    <content type="text"><![CDATA[自定义git我们还可以自定义很多git的配置项，比如，让git显示颜色，这样可以让命令行更加醒目：1git config --global color.ui true 忽略特殊文件有的时候，我们有一些文件放在git工作目录中，但是我们又不想把这些文件上传到远程仓库，比如说生成的文件之类的。我们可以在工作目录的根目录下创建一个.gitignore文件，在里面填写需要忽略的文件就可以了。最后，我们需要把.gitignore也推送到远程仓库。忽略文件的原则是：1.忽略操作系统自动生成的文件，比如缩略图等；2.忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件；3.忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。 配置别名比如git status这个命令，我们想用git st来表示，我们可以使用如下命令：1git config --global alias.st status 同理，其他命令也可以这样处理。注意的是，--config是全局变量，对于这台计算机的当前用户，修改后的命令都通用。如果不加这个参数的话，修改后的命令只对当前仓库生效。每个仓库的配置文件都存放在.git/config里，而别名就在[alias]之后。当前用户的git配置文件则存放在用户主目录的.gitconfig里。如果想要修改别名，直接修改这两个配置文件也可以。 搭建git服务器把远程服务器托管到github上是一个不错的选择，但是如果我们不交钱的话，我们的项目所有人都可以访问，就很没有隐私。如果我们即想隐藏自己的项目，也不想给万恶的美帝交钱的话，自己搭建一个git服务器无疑是一个更好的选择。我们前面说过，远程仓库其实和本地仓库是没有区别的，只是方便大家进行版本交换，所以搭建起来也很简单。我们需要一台linux系统的机器，搭建git服务器的话需要一台linux系统的机器，廖大推荐使用buntu或Debian，这样，通过几条apt命令就可以很快搭建了。我们需要一个有sudo权限的账户，然后简单几步安装。第一步，安装git：1sudo apt-get install git d第二步，创建一个git账户，来运行git服务：1sudo adduser git 第三步，创建证书登录：把所有要推送到这个远程仓库的用户的公钥收集过来，就类似于在github中的ssh认证一样，放在/home/git/.ssh/authorized_keys文件里，一行一个。第四步，初始化Git仓库：需要一个文件夹作为git的仓库，假设是假定是/srv/test.git，在/srv目录下输入命令：1sudo git init --bare test.git 这样子git会建立一个裸仓库，裸仓库是没有工作区的，所有git服务器不允许用户上来直接更改文件。而且服务器上的仓库通常以.git结尾。接下来我们把owner也改成git:1sudo chown -R git:git test.git 第五步，禁用shell登录：为了安全，原则上，我们禁止git用户能通过shell登录。我们找到/etc/passwd文件，把其中的一行1git:x:1001:1001:,,,:/home/git:/bin/bash 改成1git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell 这样处理之后，git用户只能通过ssh推送git，不能够通过shell登录到服务器。这样子，git服务器就搭建好了，我们可以像使用github一样使用他了。 管理公钥和权限廖大说，用Gitosis可以管理公钥。用Gitolite可以让git拥有像svn一样的权限。这两个我都还没有接触，暂且不表，等有机会的时候在尝试一下。]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git学习(3):分支和标签管理]]></title>
    <url>%2F2017%2F01%2F30%2Fgit%E5%AD%A6%E4%B9%A0(3)%E5%88%86%E6%94%AF%E5%92%8C%E6%A0%87%E7%AD%BE%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[分支管理用了git的分支之后，只想狠狠地给他打个call，和svn的分支比起来，git简直快了指数呗。说起来，svn的分支功能，我基本没有使用过，因为实在是不太方便。分支就像是两个平行宇宙，我在这个分支进行修改，并不会影响到另外一个分支。根据需要的话，修改完毕之后，可以将两个分支合并。分支在实际使用中具体表现在，如果我在开发一个新功能，只开发到一半。这个时候同事也想用这个代码库开发别的功能，但是开发到一半的代码库无疑会影响到新的开发。这个时候，如果你新建了一个分支，在自己的分支上做开发，别人就可以在原来的分支上开发，这样互不影响。都到都开发完毕了，再把两个分支合并，岂不美哉。 创建与合并分支通俗来讲，分支就像一个平行宇宙，每个平行宇宙都有一条时间线，我们每次commit就是串起了一条时间线。目前为止，我们只有一条时间线，即master分支。严格来讲，HEAD并不是指向提交，而是指向分支master，然后master才是指向提交。所以,HEAD指向的是当前分支。我们可以这样理解，新建了一个分支，其实就是在master这条时间线的某个时间节点分出了两条平行的时间线，一条还是按master原有的轨迹行走，另一条就按另一个方向前进。我们将这个时间线，也就是分支命名为dev。等到dev上的修改全部完成了，我们可以把dev这个分支和master分支合并。最简单的情况是这样的，如果master这个分支没有进行任何修改，那么我们可以直接将master指向dev这个分支。然后，我们就可以把dev这个分支删除了，其实也就是把dev的指针给删除掉。接下来是实际操作：我们要先创建一个分支，然后用git checkout &lt;name&gt;切换到这个分支，如果同时加上-b这个参数，就是创建的同时并切换分支：1git checkout -b dev 相当于相面两句代码：12git branch devgit checkout dev 同时，我们可以用git branch查看当前分支。等到dev分支的修改都完成后，我们需要把dev上的东西合并到master。首先用git checkout master切换到master分支，然后输入：1git merge dev git merge命令用于合并指定分支到当前分支。因为master没有修改，即是Fast-forward（快进模式）。直接把master指向dev的当前提交，所以速度非常地快。合并完成以后，就可以删除dev分支了：1git branch -d dev 如果要丢弃一个没有被合并过的分支，可以通过git branch -D &lt;name&gt;强行删除。 解决冲突但是现实使用中，master没有进行修改的情况是非常少见的。一般都是dev分支修改的同时，master分支也被修改了。这种情况下，我们就无法执行“快速合并”操作。如果我们在master分支运行git merge dev命令，git就会提示我们发生冲突，合并失败。为了解决这种问题，我们必须先手动解决冲突后，再进行合并。我们使用git status可以查看冲突的文件，在这条命令下，我们是可以看到冲突文件的内容的。Git用”&lt;&lt;&lt;&lt;&lt;&lt;&lt;”，”=======”，”&gt;&gt;&gt;&gt;&gt;&gt;&gt;”标记出不同分支的内容。我们手动修改工作区的冲突文件后，再合并，就成功了。这时候，我们使用带参数的git log命令可以查看分支情况：1git log --graph --pretty=oneline --abbrev-commit 最后，git branch -d dev删除dev分支。 分支管理策略通常情况下，git会尽可能地使用Fast forward模式，但是这样操作的话，在删除分支之后，分支的信息就会丢失。如果我们想在分支删除以后还保留分支信息的话，可以加上--no-ff参数来强制禁用Fast forward模式。一般来说，能使用快进模式来合并分支的话，都是master没有更改的情况，所以接下来合并命令的前提是master分支没有更改，我们要把更改了的dev分支合并到master上：1git merge --no-ff -m "merge with no-ff" dev 参数-m后面跟的是这次合并的注释。在实际开发中，我们要遵循以下几个原则：1.master分支是一个非常稳定的分支，我们平时不应该在上面直接做修改。2.平时我们应该都在dev分支上面做修改，比如我们要发布一个1.0新版本，应该在dev分支上完成1.0后，再合并到master分支。3.每个小伙伴应该都有自己的dev分支，不要混用。 bug分支很多情况下，我们的生产环境也就是master分支出现了bug，理论上，我们应该要新建一个bug1分支来修改bug，等到bug修复完成后，再把bug1合并到master分支。但是这个时候，我们手头的dev分支还在工作，而且只进行到一半。如果把工作到一半的dev分支合并到master，这当然是不可取的。写到一半的代码势必会影响到master的正常工作，这可如何是好。不必惊慌，这个一个非常常见的情况，git也给了相应的处理措施。我们可以使用git stash命令来把工作现场给储存起来，等以后恢复工作现场继续工作。在使用了git stash后，再用git status来查看工作区，会发现工作区是干净的，这说明，dev分支被保存起来了。接下来我们要修改master分支上的bug，我们需要先切换到master分支上，然后新建一个bug1分支：12git checkout mastergit checkout -b bug1 修复成功后，再切换到master分支，将bug1分支合并到master分支，然后删除：123git checkout mastergit merge --no-ff -m "mix bug1" bug1git branch -d bug1 这样，bug就修复完毕了，我们要接着干活，所以我们想要恢复刚刚的dev工作现场,我们先切换回dev，然后用git stash list命令查看所有工作现场：12git checkout devgit stash list 恢复stash的命令有两种，一种是git stash apply，这种恢复后stash不会删除。要删除的话，可以使用git stash pop恢复。如果我们之前进行了多次stash保存操作，恢复的时候可以用git stash list查看，然后恢复指定stash:1git stash apply stash@&#123;0&#125; 多人协助在进行多人共同开发一个项目的时候，不可避免要使用到远程仓库了。当我们从远程仓库克隆的时候，其实git已经把我们本地工作目录的master和远程master关联起来了，而且远程仓库的默认名称是origin，我们可以使用git remote来查看远程仓库的信息，加上-v参数可以让信息更加详细。要推送分支到远程的命令是：1git push origin 分支名 当我们从远程仓库git clone git@github.com:用户名/仓库名.git克隆时，默认情况下，我们只能看到master分支，别的分支是么有的。如果我们要在本地的dev上开发，在本地创建和远程分支对应的分支:1git checkout -b dev origin/dev 这个时候，我们就可以在本地修改dev分支，然后快乐地推送到远程了。但是我们有一个很烦人的小伙伴，我们叫他小辉，小辉现在也在本地修改dev分支，然后也推送了版本到远程仓库。如果我们恰好修改了同一个文件，我在小辉之后推送的话，就会报错，那是因为我们文件内容冲突了。解决这个方法其实也很简单，我们可以使用git pull命令把最新的提交从origin/dev上抓下来，解决冲突再合并就OK了。可是我们再次git pull的时候还是报错了，提示no tracking information,这是因为本地的dev没有关联到远程，使用命令：1git branch --set-upstream dev origin/dev 标签管理创建标签每个标签tags都是和一个commit绑定在一起的，他的优势就是，容易记住。因为commit都是一大串数字，而tags是可以自定义的，所以就很…ok。创建标签非常简单，我们需要切换到要打标签的分支,然后是用git tag &lt;name&gt;就可以打一个标签。默认标签是打在刚提交的commit上的。但是小辉非要给以前的commit打标签，好吧，这也是可以的。我们只要使用命令找到历史提交的commit id就可以了：12git log --pretty=oneline --abbrev-commitgit tag &lt;name&gt; commitid 我们可以使用git tag查看标签,使用git show &lt;tagname&gt;查看标签信息。还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字：1git tag -a &lt;name&gt; -m "tagv1.0" commitid 还可以通过-s用私钥签名一个标签：1git tag -s v2.0 -m "tagv2.0" commitid 操作标签如果标签打错了，我们也可以删除：1git tag -d &lt;tagname&gt; 这些操作都是在本地的，所有不用担心影响到远程仓库，如果我们想把标签推送到远程仓库，可以推送一个本地标签：1git push origin &lt;tagname&gt; 也可以一次性推送所有未推送标签:1git push origin --tags 如果推送到远程以后，发现标签错了，想要删除，也可以：12git tag -d &lt;tagname&gt;git push origin:refs/tags/&lt;tagname&gt; 成功删除。]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git学习(2):git版本库管理]]></title>
    <url>%2F2017%2F01%2F29%2Fgit%E5%AD%A6%E4%B9%A0(2)git%E7%89%88%E6%9C%AC%E5%BA%93%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[之前我们已经成功提交了一个readme.txt文件,接下来，可以对这个文件进行修改，然后运行git status命令可以看到结果，这个命令可以让我们随时掌握仓库的状态，如果我们要看看具体改了哪些内容，可以使用git diff这个命令来查看。然后如果要将修改的文件进行提交的话，操作就和之前的一样了。 版本控制版本回退git的版本回退就类似于快照，每次我们commit之后，就在版本库给我们建立一个快照。如果我们把文件误删了，或者搞混了，就可以从最近的一commit恢复。我们使用git log这个命令可以查看我们的历史记录，如果觉得输出太多，可以加上--pretty=oneline参数来提取commit id。这里需要注意的是，git的版本号和svn不一样，并不是1,2,3….这样递增的数字，而是一个通过SHA1计算得到的非常大的数字，并且用十六进制表示，这样可以从很大程度上避免版本号的冲突。现在，我们要开始进行版本回退，git必须知道当前版本，用HEAD表示当前版本，上一个版本就是HEAD^，再上一个版本就是HEAD^^，如果往上100个版本就写做HEAD~100。所以我们要回退到上一个版本的命令就是：1git resrt --hard HEAD^ 如果我们知道commit id的话，我也可以直接使用commit id，比如id是123456....，就是：1git reset --hard 123456 版本号没必要写全，写前面几位就可以了。如果我们忘记了摸个版本的commit id，我们可以使用git reflog来查看之前的历史命令，这样也可以查看到之前的commit id。git和svn相比，多了一个暂存区的概念。 工作区工作区的通俗来理解，应该就是我们的工作目录，也就是文件的目录。 版本库在工作区里有一个名为.git的隐藏目录，这个就是git的版本库。其中比较重要的就是被称为stage的暂存区，以及创建工作区是自动生成的master分支，以及指向master的名为HEAD的指针。之前我们提交的两步操作:第一步，git add就是将文件修改添加到暂存区。第二步，git commit就是 将文件修改一次性从暂存区提交到分支。 管理修改接下来我们需要了解到的是，git跟踪的是修改，而不是文件。举个栗子，我们修改了一个名为readme.txt的文件，先用git add readme.txt添加到暂存区，然后再次修改这个文件，最后用git commit提交到分支。这个时候我们用git status查看状态，可以发现，第二次修改并没有被提交。这是因为，第一次修改之后，我们使用了git add将修改添加到了暂存区，第二次修改却没有这样操作，所以git commit并不会将第二次修改提交到分支。如果我们想把第二次修改也提交到分支的话，可以在第二次修改之后，再次使用git add readme.txt，这样就可以一起提交了。如果我们想查看工作区和版本库之间的差别的话，可以使用：1git diff HEAD -- readme.txt 撤销修改如果发现工作区的文件在我们修改之后有错误，想把他恢复到上一个版本的状态。可以使用git checkout -- readme.txt来丢弃工作区的修改。这里分成两种情况:第一种，readme.txt修改之后没有提交到暂存区，这时候撤销修改就恢复到版本库里的状态。第二种，readme.txt修改之后提交到了暂存区，撤销修改就恢复到提交到暂存区时的状态。如果我们的修改在提交到暂存区之后才发现错误，这个时候要修改的话。我们需要先使用git reset HEAD readme.txt把暂存区的修改撤销掉，重新放回工作区。然后按之前修改工作区的文件的步骤进行。 删除文件当我们在工作区删除了一个文件之后，希望在版本库中也删除这个文件。我们先用git status查看状态，git会非常人性化地提示我们，版本库和工作区不一致，并且告诉我们哪个文件不一致。而且，他会给我们两个选择：一个是要从版本库里面也删除这个文件，我们可以使用git rm readme.txt来删除，然后用git commit提交。这样，版本库里的文件也被删除了。另一个是删错了，我们想要恢复工作区的文件，我们可以使用git checkout -- readme.txt来将误删的文件恢复到最新版本。 远程仓库说到远程仓库，首选当然是代码圈大型交友平台github啦，嘿嘿。 添加SSH我们想要把本地版本库和github上面的仓库关联起来，是通过SSH协议的。只需要两步就可以实现这个：第一步，在主目录下查看是否拥有.ssh文件夹，如果有，再看看是否有id_rsa和id_rsa.pub，其中id_rsa是私钥，id_rsa.pub是公钥。有的话就可以进行第二步了，没有的话，就打开shell窗口，执行以下代码：1ssh -keygen -t rsa -C "youemail@address.com" 在.ssh里生成上面的公钥和私钥。第二步，在github里打开Account settings，SSH Keys页面，然后，点Add SSH Key，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容。 添加远程库先在github上建立一个repository,然后在本地工作区打开shell，运行命令：1git remote add origin git@github.com:用户名/仓库名.git 添加以后，远程仓库就叫origin,这个是git的默认叫法，也可以改成别的。接下来，可以使用git push来讲本地版本库推送到远程仓库。第一次推送的时候，加上-u参数，git会把本地master分支推送到远程master分支，还会将两者关联起来。如下：1git push -u origin master 这样，github上也有了和本地一模一样的内容了。以后在本地修改，只要通过命令：1git push origin master 就可以把本地最新的master分支推送到github了。 从远程仓库克隆在一个空的文件夹，执行命令:1git clone git@github.com:用户名/仓库名.git 将远程仓库克隆到本地。Git支持多种协议，包括https，但通过ssh支持的原生git协议速度最快]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git学习(1):git介绍并创建版本库]]></title>
    <url>%2F2017%2F01%2F28%2Fgit%E5%AD%A6%E4%B9%A0(1)git%E4%BB%8B%E7%BB%8D%E5%B9%B6%E5%88%9B%E5%BB%BA%E7%89%88%E6%9C%AC%E5%BA%93%2F</url>
    <content type="text"><![CDATA[关于版本控制系统，我们公司目前用的是集中式的svn。集中式的版本控制系统就类似于一个图书馆，有一个寄存版本库的中央服务器。如果我们要修改代码的话，需要先从中央服务器获取最新版本，修改完再推送会中央服务器。就像从图书馆借一本书出来带回家，在家里改完了再还给图书馆。而git就是分布式版本控制系统的代表。分布式的就没有中央服务器的概念，每个人的电脑上都是一个完整的版本库。如果我在电脑上更改了一个文件，另一个人也同时更改了这个文件，我们俩只要相互推送，就可以看到对方更改的地方。这样两者相比起来，分布式的版本控制系统就有更高的安全性。如果是集中式的，中央服务器挂了，那整个版本库就没了。值得一提的是，分布式版本控制系统其实也很少在两人之间的电脑上推送版本库的修改，一般也有一台电脑来充当“中央服务器”，这台电脑仅仅是为了方便大家交换版本修改，没有这台机器的话，大家也能照常干活。但是svn最大的缺点还是他需要联网，如果在局域网内，如果带宽更大，其实也还好。但是如果在互联网上，网速慢就很坑爹了，而git就没有这方面的烦恼。于此同时，git的分支管理也异常强大。在这里，我要手动感谢廖雪峰廖大，他的git教程写得通俗易懂。（ps.他的python教程我也在看，当字典用不错，推荐一下。）git 是linux之父开发的，所以一开始，git也只能在linux和Unix系统上运行。随着时间的迁移，当然就会有好汉觉得，这么好用的东西，我win上面怎么可以不能用呢，于是，现在我们在windows上也可以运行git啦。 安装gitlinux上安装首先输入git查看系统是否安装，如果没有的话，很多linux系统都会提示我们如何安装的。一般输入sudo apt-get install git就可以安装git windows上安装百度git去官网下载一个exe，无脑下一步就可以啦。 创建版本库版本库就像一个仓库，在我们电脑里，可以理解成一个目录。里面所有文件的修改删除，git都能跟踪，我们可以在任何时刻追踪历史，进行还原。通过git init命令可以把一个目录变成可以管理的仓库：1git init 这样，我们就建立起了一个版本仓库，并且在当前目录下，多了一个.git的隐藏文件夹，这个文件夹是用来跟踪管理git版本库的，千万不要手贱去修改这个里面的文件。 把文件添加到版本库新建一个read.txt后，将文件添加到版本库，只需要两步：第一步，用命令git add，将文件添加到仓库：1git add readme.txt 第二步，用命令git commit，将文件提交到仓库,-m后面是对这次提交的说明:1git commit -m "bulid readme.txt" 注意的是，commit一次可以提交很多文件，所以我们可以多次add不同的文件，然后一次性commit。]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sqlserver中DATEADD和DATEDIFF的用法示例介绍]]></title>
    <url>%2F2016%2F12%2F21%2FMSSQL%E4%B8%ADDATEADD%E5%92%8CDATEDIFF%E7%9A%84%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[DATEDIFF函数是用于计算两个日期之间的小时、天、周、月、年等时间的间隔。DATEADD函数通过给定时间间隔对一个日期进行加减来获得一个新的日期。一个月的第一天1Select DATEADD(mm, DATEDIFF(mm,0,getdate()), 0) 本周的星期一1Select DATEADD(wk, DATEDIFF(wk,0,getdate()), 0) 一年的第一天1Select DATEADD(yy, DATEDIFF(yy,0,getdate()), 0) 季度的第一天1Select DATEADD(qq, DATEDIFF(qq,0,getdate()), 0) 当天的半夜1Select DATEADD(dd, DATEDIFF(dd,0,getdate()), 0) 上个月的最后一天1Select dateadd(ms,-3,DATEADD(mm, DATEDIFF(mm,0,getdate()), 0)) 去年的最后一天1Select dateadd(ms,-3,DATEADD(yy, DATEDIFF(yy,0,getdate()), 0)) 本月的最后一天1Select dateadd(ms,-3,DATEADD(mm, DATEDIFF(m,0,getdate())+1, 0)) 本年的最后一天1Select dateadd(ms,-3,DATEADD(yy, DATEDIFF(yy,0,getdate())+1, 0)) 本月的第一个星期一1select DATEADD(wk,DATEDIFF(wk,0,dateadd(dd,6datepart(day,getdate()),getdate())), 0)]]></content>
      <categories>
        <category>sqlserver</category>
      </categories>
      <tags>
        <tag>sqlserver</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sqlserver float 转 varchar 防止科学计数法]]></title>
    <url>%2F2016%2F12%2F20%2Fsqlserver-float-%E8%BD%AC-varchar-%E9%98%B2%E6%AD%A2%E7%A7%91%E5%AD%A6%E8%AE%A1%E6%95%B0%E6%B3%95%2F</url>
    <content type="text"><![CDATA[今天给同事处理数据需求的时候，发现了一个问题，直接将Float转化成Varchar，生成的字符串是科学计数法。研究了一下发现，用Cast转换两次即可。Float—&gt;&gt;Decimal—&gt;&gt;Varchar1select cast(cast(字段 as decimal(18,0)) as varchar) 哇咔咔]]></content>
      <categories>
        <category>sqlserver</category>
      </categories>
      <tags>
        <tag>sqlserver</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pymongo的基本操作]]></title>
    <url>%2F2016%2F12%2F14%2Fpymongo%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[前几天写了个简单爬虫爬取了58的数据，今天想要把他和Mongodb数据库连接起来。 Windows平台安装MongodbMongodb下载首先去Mongodb官网下载一个MongoDB 预编译二进制包，下载地址。 创建数据目录Mongodb将数据存储在db目录下，但是这个数据目录不会自己创建，我们需要在安装完成后创建它。(注意，数据目录要放在根目录下。比如C:\和D:\)我们创建一个db\data\目录。12cd /d D:\mkdir data\db\ 配置Mongodb服务先在data目录下再创建一个long文件夹：1mkdir data\log\ 然后在Mongodb目录文件下再创建一个配置文件C:\mongodb\mongod.cfg,其中指定 systemLog.path和storage.dbPath。具体配置如下：12345systemLog: destination: file #注意是四个空格不是Tab path: D:\data\log\mongod.logstorage: dbPath: D:\data\db 安装Mongodb服务通过执行mongod.exe，使用--install选项来安装服务，使用--config选项来指定之前创建的配置文件。这样我们可以开机自动启动Mongodb服务了。1"D:\mongodb\bin\mongod.exe" --config "D:\mongodb\mongod.cfg" --install 然后启动Mongodb服务：1net start MongoDB 完成，这时候，运行Mongodb目录下的mongo.exe，就可以进入交互模式了。 pymongo基本操作首先导入pymongo1import pymongo 创建连接指定host及port参数：1client = pymongo.MongoClient('localhost',27017) 或者这样1client = pymongo.MongoClient('mongodb://localhost:27017/') 连接数据库1tongcheng = client.tongcheng 或者1tongcheng = client['tongcheng'] 连接聚集相当于关系型数据库中的表1tongchengsheet = tongcheng.tongchengsheet 或者1tongchengsheet = tongcheng['tongchengsheet'] 查看数据库下面所有的聚集1tongcheng.collection_names() 插入记录123456data = &#123; 'name':name ,'age':age ,'city':city&#125;tongchengsheet.insert(data) 注意，这里插入的一定是一个字典。 按条件删除记录1tongchengsheet.remove(&#123;'name':name&#125;) 即为删除name值为“name”的记录。 更新数据1tongchengsheet.update(&#123;'name':name&#125;,&#123;'$set':&#123;'age':age,'city':city&#125;&#125;) 即为把name条件为“name”的行，age和city字段改成设定的值。这样只会修改发现的第一条数据，如果想修改所有的文档，需要把multi参数改成true。1tongchengsheet.update(&#123;'name':name&#125;,&#123;'set':&#123;'age':age,'city':city&#125;&#125;,&#123;'multi':true&#125;) 查找数据123456#find_one()查询一条数据，不带参数则返回第一条，带参数则按条件查找tongchengsheet.find_one()tongchengsheet.find_one(&#123;'name':name&#125;)#find_one()查询所有数据，不带参数则返回所有数据，带参数则按条件查找tongchengsheet.find()tongchengsheet.find(&#123;'name':name&#125;) 可以用count()方法查看聚集数据数量,limit()方法限制条数123tongchengsheet.find().count()#查看前n条tongchengsheet.find().limit(n) 类似于关系型数据库的ORDER BY,我们同样可以使用sort()函数来排序12345678#默认升序tongchengsheet.find().sort('name')#ASCENDING为升序tongchengsheet.find().sort('name',pymongo.ASCENDING)#DESCENDING为降序tongchengsheet.find().sort('name',pymongo.DESCENDING)#多字段排序tongchengsheet.find().sort([('name',pymongo,ASCENDING),('age',pymongo.DESCENDING)]) 结语其他操作以后用到再补充。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pymongo</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[openvpn 连接提示CreateFile failed on TAP device]]></title>
    <url>%2F2016%2F12%2F14%2Fopenvpn-%E8%BF%9E%E6%8E%A5%E6%8F%90%E7%A4%BACreateFile-failed-on-TAP-device%2F</url>
    <content type="text"><![CDATA[今天一大早有同事反映VPN连接不上，老大就让我去检查一下，我一个小虾米刚用VPN还不到1个月，着实有些为难啊，只能硬着头皮上了。 打开log一看，发现报错CreateFile failed on TAP device，遂百度，成功得到解决方法。 记录一下 1.关闭OpenVPN客户端2.进入OpenVPN安装目录\bin3.运行deltapall.bat，并按提示执行完成4.运行addtap.bat，并按提示执行完成5.重新运行OpenVPN客户端，完成连接即可]]></content>
      <categories>
        <category>PC</category>
      </categories>
      <tags>
        <tag>PC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python爬虫(1)Beautifulsoup和requests写一个简单的脚本]]></title>
    <url>%2F2016%2F12%2F11%2Fpython%E7%88%AC%E8%99%AB(1)Beautifulsoup%E5%92%8Crequests%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[主要是用bs4下的Beautifulsoup和requests库来编写一个简单的爬虫，爬取的是59同城网的一个详情页面http://bj.58.com/pingbandiannao/31804057080125x.shtml。1234567891011121314151617181920212223242526272829303132333435363738394041from bs4 import BeautifulSoupimport requestsurl = 'http://bj.58.com/pingbandiannao/31804057080125x.shtml'#可设置代理#proxies = &#123; # "http": "http://"+ip, # "https": "http://"+ip, #&#125;#这里可以添加`User-Agent`和`cookie`和`Referer`等请求参数。headers = &#123; 'User-Agent':'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.86 Safari/537.36' #这个表明网页调用接口的来源，不添加的话，之后调用浏览数的api不会返回具体浏览数，会返回0。 ,'Referer':'http://bj.58.com/pingbandiannao/31804057080125x.shtml'&#125;#requests以get()方法打开网页，然后使用text方法取出内容data = requests.get(url,headers = headers,proxies = proxies)#BeautifulSoup使用'lxml'来简析这个网页soup = BeautifulSoup(data.text,'lxml')#select方法是通过cssSelector选择器来筛选数据的type = soup.select('.crb_i')[0].get_text()title = soup.select('.col_sub.mainTitle &gt; h1')[0].get_text()time = soup.select('li.time')[0].get_text()#stripped_strings提取一个父标签下，被多个子标签分割的文本place = ' '.join(list(soup.select('span.c_25d')[0].stripped_strings))#浏览量是通过js异步加载的，我们需要调用返回浏览量的api#获取标签id：31804057080125apid = url.split('/')[-1].split('x.')[0]#拼接api地址api = 'http://jst1.58.com/counter?infoid=&#123;&#125;'.format(apid)print(api)api_data = requests.get(api,headers=headers)#获取浏览量view = api_data.text.split('=')[-1]data = &#123; 'type':type ,'title':title ,'time':time ,'place':place ,'view':view&#125;print(data) 这里Beautifulsoup的select方法是使用cssSelector选择器来筛选的。查看css选择器这样，一个详情页就爬取完毕了，如果想批量爬取多个详情页，观察各个详情页的url，找到规律，然后就可以爬取了。为了避免反爬，最好使用time.sleep(10)来限制爬取频率。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python之路(7):深入探讨super()]]></title>
    <url>%2F2016%2F12%2F01%2Fpython%E4%B9%8B%E8%B7%AF(7)%E6%B7%B1%E5%85%A5%E6%8E%A2%E8%AE%A8super()%2F</url>
    <content type="text"><![CDATA[入门使用在类的继承中，如果我们在子类重新定义了父类的同名方法，子类里的方法就会覆盖父类的。如果我们想调用父类的方法，就有两种：1.直接绑定父类的名称。2.使用super()。12345678910111213141516171819202122232425262728293031323334353637383940#创建一个父类class Father(): def __init__(self): self.name = self.__class__.__name__ def say_hello(self): print('Father') print(self.name)#绑定的方法调用父类say_helloclass Son1(Father): def say_hello(self): print('-'*20) print('Son1') #这里的self就是子类Son1的实例 Father.say_hello(self)#super()调用父类say_helloclass Son2(Father): def say_hello(self): print('-'*20) print('Son2') #这里的self就是子类Son1的实例 super(Son2,self).say_hello()#实例化子类son1 = Son1()son1.say_hello()son2 = Son2()son2.say_hello()#输出&gt;&gt;&gt; --------------------Son1FatherSon1--------------------Son2FatherSon2 这样咋一看，两种方法是一样的。super()好像很简单，无非就是获取了父类的方法，然后调用了父类的方法。实际上super()和父类没有关系。。。。。，上面的例子只是因为super()刚好获取到的类是父类。 深入探讨如果我们用一个复杂一点的例子，就很容易看出问题所在了：123456789101112131415161718192021222324252627282930313233343536#创建一个基类Baseclass Base(): def __init__(self): print('enter Base') print('leave Base')#创建父类为Base的两个子类A,Bclass A(Base): def __init__(self): print('enter A') super(A,self).__init__() print('leave A') class B(Base): def __init__(self): print('enter B') super(B,self).__init__() print('leave B')#创建A,B的子类Cclass C(A,B): def __init__(self): print('enter C') super(C,self).__init__() print('leave C')#输出&gt;&gt;&gt; c=C()enter Center Aenter Benter Baseleave Baseleave Bleave Aleave C 可以看到，如果super()是继承父类的话，enter A的下一句应该是enter Base，而不是enter B。 MRO列表实际上super()的调用顺序是根据MRO列表来的，也称之为方法解析顺序列表，它决定了类的继承顺序。我们可以通过以下的方式来获取：12&gt;&gt;&gt; C.mro() #or C.__mro__ or C().__class__.mro()[&lt;class '__main__.C'&gt;, &lt;class '__main__.A'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.Base'&gt;, &lt;class 'object'&gt;] 使用这个要注意三点原则：1.子类永远排在父类的前面。2.有多个父类的话，按照MRO列表中的顺序来判断。3.下一个类如果有两种选择的话，选择第一个父类。 super元类super()`的代码如下：12345def super(cls,self): #获取MRO列表 mro = self.__class__.mro() #获取当前类cls的下一个类 return mro[mro.index(cls) + 1] 这里的cls是类，self是实例。当我们使用super(cls,self)就会self的MRO列表里搜寻cls类的下一个类。我们运行super(C,self).__init__()，因为12#self.__class__.mro()的结果mro列表[&lt;class '__main__.C'&gt;, &lt;class '__main__.A'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.Base'&gt;, &lt;class 'object'&gt;] 所以下一个类是&lt;class &#39;__main__.A&#39;&gt;,打印enter A然后运行super(A,self).__init__(),因为下一个是类是&lt;class &#39;__main__.B&#39;&gt;，所以打印enter B，而不是enter Base。豁然开朗。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python之路(6):枚举类和元类]]></title>
    <url>%2F2016%2F11%2F24%2Fpython%E4%B9%8B%E8%B7%AF(6)%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%92%8C%E5%85%83%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[枚举类定义如果我们定义的类的属性是有限且固定的，我们可以使用枚举类。我们首先要从enum模块中导入Enum，然后在定义类的时候继承Enum：123456789from enum import Enumclass Weekday(Enum): Sunday = 1 Monday = 2 Tuesday = 3 Wednesday = 4 Thursday = 5 Friday = 6 Saturday = 7 这样我们就成功定义了星期的枚举类Weekday，他有固定的7个成员，比如Weekday.Sunday,Weekday.Monday等。而且每个成员都有他固定名称和值，比如说Weekday.Sunday的名称是Sunday，值是1。而且之前我们就知道，我们定义的类也是一种数据类型，和list,str这些数据类型没有任何区别。所以，每个成员的数据类型，都是他们所属于的枚举类。有几点需要注意一下：1.成员的名称不允许重复：1234from enum import Enumclass Weekday(Enum): Sunday = 1 Sunday = 2 这样子会有报错TypeError: Attempted to reuse key: &#39;Sunday&#39;。2.成员的值一般情况下是可以相同的。两个值相同的成员，第二个成员会视为第一个成员的别名：123class Weekday(Enum): Sunday = 1 Sunday_two = 1 Weekday.Sunday和Sunday_two具有相同的值，所以Sunday_two是作为Sunday的别名存在的。而且如果我们想获取值相同的成员，只能取到第一个。3.如果我们想限制枚举类，希望不能有重复值，可以使用@unique这个装饰器：123456from enum import Enum,unique@uniqueclass Weekday(Enum): Sunday = 1 Sunday_two = 1 这样就会报重复值的错误ValueError: duplicate values found in &lt;enum &#39;Weekday&#39;&gt;: Sunday_two -&gt; Sunday。 枚举取值可以直接通过成员名称来获取成员：12&gt;&gt;&gt; Weekday['Sunday']&lt;Weekday.Sunday: 1&gt; 通过成员的值来获取成员：12&gt;&gt;&gt; Weekday(1)&lt;Weekday.Sunday: 1&gt; 也可以通过成员来取他的名称和值：12345&gt;&gt;&gt; Week = Weekday.Sunday&gt;&gt;&gt; Week.name'Sunday'&gt;&gt;&gt; Week.value1 还可以使用for循环来遍历整个Weekday枚举类。但是如果有重复值，只会遍历第一个成员：12345678910111213141516171819202122from enum import Enumclass Weekday(Enum): Sunday = 1 Monday = 2 Tuesday = 3 Wednesday = 4 Thursday = 5 Friday = 6 Saturday = 7 Sunday_two = 1for i in Weekday: print(i)#输出Weekday.SundayWeekday.MondayWeekday.TuesdayWeekday.WednesdayWeekday.ThursdayWeekday.FridayWeekday.Saturday 如果我们希望重复的值也被遍历出来，可以加一个魔法方法__members__：123456789101112for i in Weekday.__members__.items(): print(i)#输出('Sunday', &lt;Weekday.Sunday: 1&gt;)('Monday', &lt;Weekday.Monday: 2&gt;)('Tuesday', &lt;Weekday.Tuesday: 3&gt;)('Wednesday', &lt;Weekday.Wednesday: 4&gt;)('Thursday', &lt;Weekday.Thursday: 5&gt;)('Friday', &lt;Weekday.Friday: 6&gt;)('Saturday', &lt;Weekday.Saturday: 7&gt;)('Sunday_two', &lt;Weekday.Sunday: 1&gt;) 枚举成员比较可以用is,is not和==,!=进行比较，但是不能比较大小：12345678&gt;&gt;&gt; Weekday.Sunday is Weekday.SundayTrue&gt;&gt;&gt; Weekday.Sunday is not Weekday.MondayTrue&gt;&gt;&gt; Weekday.Sunday == Weekday.SundayTrue&gt;&gt;&gt; Weekday.Sunday != Weekday.SundayFalse 元类吐槽元类真的很复杂，一开始看廖大关于元类的教程，完全看得云里雾里。感觉解释性的语言太少了，有点跳跃，如果对于类的概念理解不充分，就很难看懂。看第一遍的时候，只记住了这么一句话，元类就是生产类的工厂，我们可以把类看作是元类的“实例”。没办法，只能各种找关于元类的文档，看了挺多的，还是不得其法。这个时候看到了Python界领袖 Tim Peters的一句话： “元类就是深度的魔法，99%的用户应该根本不必为此操心。如果你想搞清楚究竟是否需要用到元类，那么你就不需要它。那些实际用到元类的人都非常清楚地知道他们需要做什么，而且根本不需要解释为什么要用元类。” 顿时计上心来，嘿嘿，正好看的头大，不如我就先把元类放着吧，等以后能用到的时候，再来好好研究一下，岂不美哉。然而鲁迅先生说过： “逃避并不能解决问题，只有在一个问题上苦下功夫，反复操练，才能学会！” （鲁迅：“劳资没说过。。。”）好吧，实际上是，在看到ORM时，发现用元类是真的很方便，那就回过头来好好把元类研究透彻。 元类和类的关系看到有大佬把元类和类的关系概括地挺好，我也非常喜欢。那就是： “道生一，一生二，二生三，三生万物。” 1.道的话就是type。2.一就是元类metaclass(也叫作类生成器)。3.二就是类class(也叫作实例生成器)。4.三就是实例instance。5.万物就是实例的属性和方法，我们平时调用的也就是这个。 首先来看看我们平时用class来定义类，然后生成实例的写法。我们举一个Hello的栗子：12345678910#首先定义一个class类class Hello(): def say_hello(self,name='world'): print("Hello,%s"%name)#生成Hello()实例hello = Hello()#调用hello实例的方法hello.say_hello()#输出&gt;&gt;&gt; Hello,world 这是我们平时最常见的写法，但是实际上，我们是用class定义了一个类，然后python调用了tpye()来生成他。这些都是在python解释器里面完成的，当然我们也可以直接使用type()来动态生成一个类。所以我们可以用这种写法：12345#先定义类的方法say_hellodef say_hello(self,name='world'): print("Hello,%s"%name)#使用type动态生成类Hello = type('Hello',(object,),&#123;'say_hello':say_hello&#125;) 这里type()依次传入三个函数：1.类的名称。2.类所继承的父类，这里是一个tuple，如果只继承一个父类，记得用tuple的单元素写法。3.类的属性和方法，是一个字典dict。 定义元类metaclass我们可以用type()直接生成class类，也可以先生成metaclass元类，然后批量生成class类。一般，我们讲元类命名成后缀为MetaClass，还是用一个Hello的栗子来说明：12345#先创建一个“打招呼”的元类class HelloMetaClass(type): def __new__(cls,name,bases,attrs): attrs['say_'+name]=lambda self,value,language=name:print(language+','+value) return type.__new__(cls,name,bases,attrs) 这里要说一下的是__new__这个魔法方法。__new__经常和__init__弄混淆，我们通常以为__init__是类实例化时调用的第一个方法，实际上__new__还在__init__之前调用。__new__魔法方法是用来生成类的实例的，而__init__是用来初始化这个生成的实例（要先生成实例才能初始化，这样是__new__方法先执行的原因）。然后我们在使用元类生成类的时候，可以使用metaclass参数引入元类HelloMetaClass。因为类实际上是由元类生成的，所以元类一定是一个可以创建类的东西。之前也提到了，我们可以把类看作是元类的一个实例。所以，元类在生成类的时候，实际上就是“实例化”，会调用HelloMetaClass这个元类的__new__方法，返回了一个type后的产物，即类。__new__方法里面的cls参数就类似于self参数，是要被“实例化”的”实例”。 元类生成类123456789#用元类创建类class Hello(object,metaclass=HelloMetaClass): pass#生成实例hello=Hello()#使用实例方法hello.say_Hello('world!')#输出&gt;&gt;&gt; Hello,world! 如果我们想使用元类生成另外一个名称不同的类，也是可以的：123456789#用元类创建类class Sayolala(object,metaclass=HelloMetaClass): pass#生成实例sayolala=Sayolala()#使用实例方法sayolala.say_Sayolala('japan!')#输出&gt;&gt;&gt; Sayolala,japan! 可以看到，我们只是修改了要生成的类，没有修改元类里面的__new__方法，就可以实现自己想要的功能。这样也体现了元类生成类的”定制性”。 元类编写ORMORM即是对象—关系映射，其实就是我们把一个类看作一个表，每个实例看作一个行。首先我们创建一个Field类，这个是用来保存字段名和字段类型的：1234567class Field(): def __init__(self,name,column_type): self.name = name self.column_type = column_type #直接打印类的实例会调用这个魔法方法 def __str__(self): return '&lt;%s,%s&gt;'%(self.__class__.__name__,self.name) 进一步我们可以在继承Field的基础上，创建StrField类来存储字符串，创建IntField来存储整型等。1234567class StrField(Field): def __init__(self,name): super(StrField,self).__init__(name,'varchar(100)') class IntField(Field): def __init__(self,name): super(IntField,self).__init__(name,'int') 这里我们使用super()来使得实例self可以直接调用父类Field的初始化方法__init__。这样咋一看，好像super()就是继承父类的方法，实际上super()和父类是没有关系的。这个在多继承的时候更为复杂，之后我会用另外一篇博客记录。首先创建一个元类ModelMetaClass：1234567891011121314151617181920class ModelMetaClass(type): def __new__(cls,name,bases,attrs): #排除对Model类的修改 if name == 'Model': return type.__new__(cls,name,bases,attrs) #定义一个字典存放Field类型的属性 mappings = &#123;&#125; for k,v in attrs.items(): if isinstance(v,Field): print('find mapping: %s ===&gt; %s'%(k,v)) mappings[k] = v #删除已赋值到mappings的属性 for k in mappings.keys(): #不删除的话，在后面调用Model基类的`__getattr__`魔法方法会有问题 attrs.pop(k) #保存列和属性的映射关系 attrs['_mappings'] = mappings #保存表名 attrs['_table'] = name return type.__new__(cls,name,bases,attrs) 这个元类实现了以下几个功能:1.排除对Model类的修改。2.对类的每一个属性进行遍历，如果是Field类型的，则将键值绑定到mappings中存储起来。3.删除传入mappings中的属性。4.创建一个属性_mappings来存储列和类型的映射关系。5.创建一个属性_table来存储表名。定义一个基类Model：1234567891011121314151617181920class Model(dict,metaclass=ModelMetaClass): #调用实例不存在的属性时,会调用这个魔法方法 def __getattr__(self,key): try: return self[key] except KeyError: raise AttributeError("'Model' object has no attribute '%s'" % key) #__setattr__的魔法方法会拦截所有属性的赋值语句，然后调用这个方法。而且，这个应该是貌似只有对实例的属性赋值才会拦截，对类属性赋值不会拦截，还没有测试过。 def __setattr__(self,key,value): self[key]=value #定制save方法，输出sql语句 def save(self): fields = [] args = [] for k,v in self._mappings.items(): fields.append(v.name) args.append(getattr(self,k,'Null')) sql = 'insert into %s(%s) values(%s)'%(self._table,','.join(fields),','.join([str(i) for i in args])) print('SQL:%s'%sql) print('ARGS:%s'%str(args)) 创建一个继承了Mode的User类，这个在ORM中也被看作是一个表，类的每个属性被看作是一个列。123456789class User(Model):#定义类的属性到列的映射#这下面的类的属性赋值就是我认为的不会触发__setattr__的 id = IntField('id') name = StrField('name') email = StrField('email') password = StrField('password')u = User(id=12345, name='Batman', email='batman@nasa.org', password='iamback')u.save() 通过不到70行的代码实现了一个简单的ORM，很好用。 结语真让人头大啊，让人头大啊，人头大啊，头大啊，大啊，啊。。。。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python之路(5):面向对象]]></title>
    <url>%2F2016%2F11%2F15%2Fpython%E4%B9%8B%E8%B7%AF(5)%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[面向过程编程讨论面向对象编程的时候，首先要知道与之相对的面向过程编程。先来说面向过程编程，也叫作top-down languages，顾名思义，就是一步步执行整个程序，从上到下，从头到尾。基本的思路就是我们如果要解决一个问题,先把这个问题分成小的问题,小的步骤,从而来降低其复杂性。但是这样有一个致命的缺点，就是代码的可维护性和可读性比较差，如果代码的某些地方要修改，那么从上至下的所有地方都要修改，很不方便。 我们来举个栗子，我们要输出一个学生的信息，比如说姓名和年龄。如果我们用面向过程编程的话，就分两步，第一步先用dict定义一个学生的信息：12student1 = &#123;'name':'zhangdaxiang','age':25&#125;student2 = &#123;'name':'xiaohui','age':26&#125; 然后第二步是用函数打印出学生的信息：123def print_info(std): print("%s's age is %d"%(student1['name'],student1['age']))print_info(student1) 面向对象编程而面向对象编程的中心思想则是，”万物皆对象”，把计算机程序视为一系列对象的集合，程序的运行，就是在各个对象之间相互传递信息。这样的话，就有很好的可维护性和拓展性，如果我们想修改什么，只需要修改涉及的对象即可。 类和实例化如果是使用面向对象编程的话，就是设计一个对象，把姓名和年龄这些个人信息都包含在对象里，叫作属性，把打印信息的函数也包含在对象里，叫作方法。也就是说，一个对象包含所有的东西，我们要得到属性，可以直接调用这个对象。我们要使用这个对象的方法，也可以直接调用这个对象。所有的东西都封装在对象里，外部仅仅是调用他。按上面所说的，student就是一个对象，我们称之为类，包含name和age两个属性，还有print_info这个方法。123456class Student(): def __init__(self,name,age): self.name = name self.age = age def print_info(self): print("%s's age is %d"%(self.name,self.age)) 这样就定义了一个类class，我们一般把类名的首字母大写。同时，student1和student2是student这个类的两个具体实现，我们称之为类的实例。概括一些，Student类是指学生，而student1和student2这两个实例则是两个具体的学生个体。要打印学生信息化的话，先将类实例化，然后每个实例打印各自的信息：12345678&gt;&gt;&gt; student1 = Student('zhangdaxiang',25)&gt;&gt;&gt; student2 = Student('xiaohui',25)&gt;&gt;&gt; student1.name'zhangdaxiang'&gt;&gt;&gt; student1.age25&gt;&gt;&gt; student1.print_info()zhangdaxiang's age is 25 我们可以给实例的属性重新赋值，也可以给实例添加一个新的属性：1234567891011&gt;&gt;&gt; student1.name = 'zhangxiaoxiang'&gt;&gt;&gt; student1.name'zhangxiaoxiang'&gt;&gt;&gt; student1.city = 'hangzhou'&gt;&gt;&gt; student1.city'hangzhou'&gt;&gt;&gt; student2.cityTraceback (most recent call last): File "&lt;pyshell#8&gt;", line 1, in &lt;module&gt; student2.cityAttributeError: 'Student' object has no attribute 'city' 访问限制从上面我们给name属性重新赋值可以看出来，我们现在依然可以通过代码来修改实例的内部属性。我们如果想让内部的属性无法访问的话，我们可以在属性名称前加两条下划线__.12345678class Student(): def __init__(self,name,age): self.__name = name self.__age = age def print_info(self): print("%s's age is %d"%(self.__name,self.__age))student1 = Student('zhangdaxiang',25)student2 = Student('xiaohui',25) 这样子，我们就不能直接从外部访问这两个属性了：12345&gt;&gt;&gt; student1.__nameTraceback (most recent call last): File "&lt;pyshell#0&gt;", line 1, in &lt;module&gt; student1.__nameAttributeError: 'Student' object has no attribute '__name' 实际上不能访问的的原因是因为属性名称变成了_Student__name，尝试一下：12&gt;&gt;&gt; student1._Student__name'zhangdaxiang' 如果我们想在外部获取这些属性，可以在类的里面定义一个获取属性的方法：12345678class Student(): ... def get_name(self): return self.__name def get_age(self): return self.__age 如果想修改类的内部属性的话呢，也可以再增加一个set的方法。而且这样做有一个好处，可以加上条件判定。比如我们希望修改的年龄在20岁以上：12345678class Student(): ... def set_age(self,age): if age&gt;20: self.__age=age else: print('年龄太小啦！') 我们运行一下就可以看到，果然和我们想的一样：1234567&gt;&gt;&gt; student1.get_age()25&gt;&gt;&gt; student1.set_age(10)年龄太小啦！&gt;&gt;&gt; student1.set_age(21)&gt;&gt;&gt; student1.get_age()21 值得注意的是，在python中，变量名类似于__XXX__这样的是属于特殊变量，是可以直接访问的。还有一种是变量面前只有一个下划线的_，比如说_name，这样的也是可以直接访问的。但是加这个下划线就是为了告诉我们，虽然我可以被访问，但是请默认我为不可以访问的变量。 继承和多态我们在定义一个类的时候，是可以继承另外一个类的，新定义的类就称之为子类，被继承的类被称为父类。比如我我们先定义一个类作为父类：123class People(): def eat(self): print('people is eating') 然后我们要建两个子类teacher和student，因为这两个子类也是人，所以可以把people当作父类来继承：123456789class Teacher(People): passclass Student(People): def eat(self): print('student is eating') def play(self): print('student is play') 继承的话，子类可以得到父类所以的属性和方法。也就是说，身为子类的student和teacher可以获得人people这个父类的所以属性和方法。12345678&gt;&gt;&gt; teacher = Teacher()&gt;&gt;&gt; student = Student()&gt;&gt;&gt; teacher.eat()people is eating&gt;&gt;&gt; student.eat()student is eating&gt;&gt;&gt; student.play()student is play 从上面可以看出，子类继承了父类的方法，但是如果子类自己又定义了一个同名的方法，则会覆盖父类的方法。而且，子类也可以自己定义新的方法，比如说play，这就是多态。要理解多态，我们首先要知道，我们定义的这些类，和python自带的list，str等等都是一样的，都可以看作一种数据类型。我们可以使用isinstance()来判定数据类型。12345678910111213&gt;&gt;&gt; a = list()&gt;&gt;&gt; b = People()&gt;&gt;&gt; c = Student()&gt;&gt;&gt; isinstance(a,list)True&gt;&gt;&gt; isinstance(b,People)True&gt;&gt;&gt; isinstance(c,Student)True&gt;&gt;&gt; isinstance(c,People)True&gt;&gt;&gt; isinstance(b,Student)False 我们可以看到c不但是Student类型的，还是People类型的。但是b只是People类型，却不是Student类型。这是因为Student类继承了People这个父类。总结一下，如果一个实例的数据类型是某个子类，那么他的数据类型也是父类。接下来用一个例子来理解多态的灵活性。123def eat_twice(people): people.eat() people.eat() 这个函数，可以传入people数据类型的参数。我们直接传入上面那些类的实例，其实也就是people数据类型的变量。123eat_twice(People())eat_twice(Student())eat_twice(Teacher()) 这些都是上面定义了的，如果我们要新增加一个继承了People类的Doctor，我们也可以这样写：123456class Doctor(People): def eat(self): print('doctor is eating')&gt;&gt;&gt; eat_twice(Doctor())doctor is eatingdoctor is eating 可以看到的是,People每新增一个子类，都可以传入以People数据类型为参数的函数中，这就是多态优越的地方。我们只需要知道传入的是People类型，而不需要知道他的子类型。只要传入了，我们就会安装People类型来处理，调用他的run的方法。而且，由于python是一种动态语言，数据类型是鸭子类型，就是说”一个东西看起来像是鸭子，那他就是鸭子。”翻译过来就是，如果一个对象，有eat这个方法，我们就认为他是People数据类型的，可以被eat_twice调用。 获取对象信息出了使用instance()之外，我们也可以使用type()函数来判定数据类型。12345678&gt;&gt;&gt; type(123)&lt;class 'int'&gt;&gt;&gt;&gt; type('123')&lt;class 'str'&gt;&gt;&gt;&gt; type(None)&lt;class 'NoneType'&gt;&gt;&gt;&gt; type([1,2,3])&lt;class 'list'&gt; 也可以判断函数或者类：123456&gt;&gt;&gt; type(abs)&lt;class 'builtin_function_or_method'&gt;&gt;&gt;&gt; type(People)&lt;class 'type'&gt;&gt;&gt;&gt; type(Student)&lt;class 'type'&gt; 也可以判定一个变量是否是某种类型：12&gt;&gt;&gt; type('123')==strTrue 判断基本数据类型可以直接写int，str等，但如果要判断一个对象是否是函数可以使用types模块中定义的常量：123456789101112&gt;&gt;&gt; import types&gt;&gt;&gt; def fun():... pass...&gt;&gt;&gt; type(fun)==types.FunctionTypeTrue&gt;&gt;&gt; type(abs)==types.BuiltinFunctionTypeTrue&gt;&gt;&gt; type(lambda x: x)==types.LambdaTypeTrue&gt;&gt;&gt; type((x for x in range(10)))==types.GeneratorTypeTrue 如果我们想要获得一个对象所有的属性和方法,可以使用dir()。1dir('123') 会返回一系列__XXX__的方法，比如说__len__返回长度,下面两种写法其实是一样的：1234&gt;&gt;&gt; len('123')3&gt;&gt;&gt; '123'.__len__()3 我们也可以在自己的类里面添加一个__len__方法。123456class People(): def __len__(self): return 20&gt;&gt;&gt; people=People()&gt;&gt;&gt; len(people)20 我们还可以用hasattr()，getattr()和setattr()这三个函数来操作对象的属性和方法：1234567891011121314151617class People(): def __init__(self,name): self.name=name def __len__(self): return 20&gt;&gt;&gt; people=People('zhangdaxiang')&gt;&gt;&gt; hasattr(people,'name')True&gt;&gt;&gt; getattr(people,'name')'zhangdaxiang'&gt;&gt;&gt; setattr(people,'name','xiaohui')&gt;&gt;&gt; getattr(people,'name')'xiaohui'&gt;&gt;&gt; hasattr(people,'__len__')True&gt;&gt;&gt; getattr(people,'__len__')&lt;bound method People.__len__ of &lt;__main__.People object at 0x00000000033EEF98&gt;&gt; 如果getattr一个不存在的方法或属性，则会报错，我们可以添加第三个参数使得不存在则返回第三个参数：12&gt;&gt;&gt; getattr(people,'age','no')'no' 类的属性和实例属性我们的类，也可以拥有自己的属性，而且这个类的每个实例都可以访问：12345678910111213class People(): name = 'zhangdaxiang'&gt;&gt;&gt; people = People()&gt;&gt;&gt; people.name #实例可以访问类的属性'zhangdaxiang'&gt;&gt;&gt; people.name = 'xiaohui' #给实例赋一个name属性的值&gt;&gt;&gt; people.name #属性名称相同，实例覆盖类'xiaohui'&gt;&gt;&gt; print(People.name) #类的属性还在zhangdaxiang&gt;&gt;&gt; del people.name #删除类的属性&gt;&gt;&gt; people.name'zhangdaxiang' 面向对象高级编程python中的类同时也拥有很多高级特性。 @property装饰器之前我们设置私有变量的时候,定义了set_age和get_age这么两个方法。如果我们希望能够像访问属性一样直接访问这两个方法的话，可以使用@property装饰器。这个装饰器有getter和setter两种方法，举个栗子：123456789101112131415161718192021222324class People(): @property def age(self): return self.__age @age.setter def age(self,value): if not isinstance(value,int): raise ValueError('Not int.') if value &lt; 0 or value &gt; 100: raise ValueError('value error.') self.__age = valueteacher=People()&gt;&gt;&gt; teacher.age=60 #实际上就是调用set_age(60)&gt;&gt;&gt; teacher.age #实际上就是调用get_age60&gt;&gt;&gt; teacher.age=101 #set_age()中要求age&lt;100,所以报错Traceback (most recent call last): File "&lt;pyshell#2&gt;", line 1, in &lt;module&gt; teacher.age=101 File "C:\Users\Administrator\Desktop\123.py", line 11, in age raise ValueError('value error.')ValueError: value error. __slots__在定义类的时候,定义一个__slots__属性，可以限制类能够绑定的属性。与之相对应的是，我们平时定义完一个类之后，是可以随意给类绑定属性和方法的：12345678class People(): def __init__(self,name): self.__name = name&gt;&gt;&gt; teacher=People('zhangdaxiang')&gt;&gt;&gt; teacher.age=23&gt;&gt;&gt; teacher.age23 要绑定方法的话,需要导入types模块中的MethodType：12345from types import MethodTypeteacher=People('zhangdaxiang')def eat(self): print( 'is eating')teacher.eat=MethodType(eat,teacher) 需要注意的是，给实例绑定的方法和属性，只有在这个实例可以访问，对于该类的其他实例不起作用。加入__slots__方法，则只能绑定规定的属性：12345678910class People(): __slots__ = ('name','age')teacher=People()&gt;&gt;&gt; teacher.name='zhangdaxiang'&gt;&gt;&gt; teacher.age=23&gt;&gt;&gt; teacher.cityTraceback (most recent call last): File "&lt;pyshell#2&gt;", line 1, in &lt;module&gt; teacher.cityAttributeError: 'People' object has no attribute 'city' __str__和__repr__类里面的__str__方法和__repr__方法可以使类的实例打印出来更好看，比如说我们平时没有定义这两个属性的类：12345class People(): def __init__(self,name): self.__name = name&gt;&gt;&gt; print(People('zhangdaxiang'))&lt;__main__.People object at 0x00000000035EB1D0&gt; 这样直接打印出来的是内存地址。如果我们添加了__str__方法，就可以定制打印出来的信息：123456789class People(): def __init__(self,name): self.__name = name def __str__(self): return 'object People(name,%s)'%self.__name&gt;&gt;&gt; print(People('zhangdaxiang')) #这样就打印出来了自己定制的信息object People(name,zhangdaxiang) &gt;&gt;&gt; People('zhangdaxiang') #直接输出实例没有变化&lt;__main__.People object at 0x00000000035EC208&gt; 但是我们直接输出实例没有变化，这个时候需要使用__repr__这个方法，而且通常因为__str__和__repr__代码是相同的，所以又便捷的写法：123456789class People(): def __init__(self,name): self.__name = name def __str__(self): return 'object People(name,%s)'%self.__name __repr__= __str__&gt;&gt;&gt; People('zhangdaxiang')object People(name,zhangdaxiang) #成了 __iter__如果我们想使用for...in...来迭代类的实例，可以使用__iter__。__iter__返回一个可迭代对象，之后python的for循环会一直调用实例的__next__方法,直到StopIteration。我们举一个最著名的栗子，斐波那契数列：12345678910111213141516171819202122232425262728class Fib(): def __init__(self,num): self.a,self.b=0,1 self.__num = num def __iter__(self): return self def __next__(self): self.a,self.b=self.b,self.a+self.b if self.a&gt;self.__num: raise StopIteration() return self.a&gt;&gt;&gt; fib = Fib(100)&gt;&gt;&gt; for i in fib: print(i) 1123581321345589 __getitem__如果我们想像列表下标一样取出斐波那契数列的元素，可以使用__getitem()来实现。12345678910111213141516class Fib(): def __getitem__(self,n): self.a,self.b=0,1 for i in range(n): self.a,self.b=self.b,self.a+self.b return self.a&gt;&gt;&gt; fib=Fib()&gt;&gt;&gt; fib[0]0&gt;&gt;&gt; fib[1]1&gt;&gt;&gt; fib[2]1&gt;&gt;&gt; fib[3]2 但是我们输入一个切片，依然不能正常工作，所以如果我们希望可以使用切片的话，应该要先判断参数是一个索引int，还是一个切片slice。123456789101112131415161718class Fib(): def __getitem__(self,n): self.a,self.b=1,1 if isinstance(n,int): #n是索引 for i in range(n): self.a,self.b=self.b,self.a+self.b return self.a if isinstance(n,slice): #n是切片 L=[] start = n.start stop = n.stop if start is None: start = 0 for i in range(stop): if i &gt;= start: L.append(self.a) self.a,self.b=self.b,self.a+self.b return L 当然现在还没有考虑负数等情况。 __getattr__平时我们调用实例不存在的属性，是会报错的。如果我们想要在调用实例不存在的属性的时候，返回我们想要的信息，可以利用__getattr__方法，来定义自己想要返回的内容：123456789101112131415class People(): def __init__(self): self.name = 'zhangdaxiang' self.age = 23 def __getattr__(self,str): if str == 'city': return '无家可归！' &gt;&gt;&gt; teacher=People()&gt;&gt;&gt; teacher.name'zhangdaxiang'&gt;&gt;&gt; teacher.age23&gt;&gt;&gt; teacher.city'无家可归！' 也就是调用类不存在的属性的时候，python就会调用__getattr__方法，__getattr__也可以返回一个函数：1234567891011class People(): def __init__(self): self.name = &apos;zhangdaxiang&apos; self.age = 23 def __getattr__(self,str): if str == &apos;city&apos;: return lambda x:x+15&gt;&gt;&gt; teacher=People()&gt;&gt;&gt; teacher.city(5)20 要注意的是，只有在没有找到属性的时候，才会调用__getattr__方法，而且如果我们调用的不是__getattr__方法里面判定过的属性，则会默认返回None。如果想让类只响应几个属性，正确的方法是调用不存在的参数抛出AttributeError错误：12345678910111213141516171819class People(): def __init__(self): self.name = 'zhangdaxiang' self.age = 23 def __getattr__(self,str): if str == 'city': return '无家可归' raise AttributeError("'People' object has not attribute '%s'"%str)&gt;&gt;&gt; teacher=People()&gt;&gt;&gt; teacher.city'无家可归'&gt;&gt;&gt; teacher.naeeTraceback (most recent call last): File "&lt;pyshell#2&gt;", line 1, in &lt;module&gt; teacher.naee File "C:\Users\Administrator\Desktop\123.py", line 8, in __getattr__ raise AttributeError("'People' object has not attribute '%s'"%str)AttributeError: 'People' object has not attribute 'naee' 基于这个方法，我们就可以完全动态调用类所有的方法和属性。举个栗子，现在很多网站都搞REST API，比如新浪微博、豆瓣啥的，调用API的URL类似： http://api.server/user/friendshttp://api.server/user/timeline/list我们完全可以用__getattr__方法来实现，比如说我们想实现/status/user/timeline/list这样的输出：1234567891011class Chain(): def __init__(self,path=''): self.__path = path def __getattr__(self,str): return Chain('%s/%s'%(self.__path,str)) def __str__(self): return self.__path __repr__=__str__&gt;&gt;&gt; Chain().status.user.timeline.list/status/user/timeline/list __call__如果我们想直接调用实例本身的话，可以使用__call__方法：12345678910class People(): def __init__(self): self.name = 'zhangdaxiang' self.age = 23 def __call__(self): print('people\'s name is %s'%self.name)&gt;&gt;&gt; teacher = People()&gt;&gt;&gt; teacher()people's name is zhangdaxiang 这样也就模糊了对象和函数的界限，完全可以把对象看成函数，把函数看成对象，因为这两者之间本来就没啥根本的区别。实际上，能够被调用的对象就是一个Callable对象，我们可以用callble来判定：12&gt;&gt;&gt; callable(People())True]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python之路(4):模块]]></title>
    <url>%2F2016%2F11%2F15%2Fpython%E4%B9%8B%E8%B7%AF(4)%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[在python中，一个.py文件就是一个模块，我们可以将模块导入，直接使用里面已经写好的功能，所以python的拓展性是非常好的。但是如果我们的.py文件和python原有的模块名称重复了，就会出现问题。要解决这种情况，有一种方法是引入包。比如说我们的zhangdaxiang.py模块以及bangbang.py模块与系统原有模块重名了。我们可以选择一个顶层包名mypy,文件结构就成了这样：1234mypy |____ __init__.py|____ zhangdaxiang.py|____ bangbang.py 这个时候,模块名就变成了mypy.zhandaxiang和mypy.bangbang，只要包名不一样，就没有问题。要注意的，每一个包目录下面都会有一个__init__.py的文件，这个文件是必须存在的，否则，Python就把这个目录当成普通目录，而不是一个包。__init__.py可以是空文件，也可以有Python代码，因为__init__.py本身就是一个模块，而它的模块名就是mypy。而且，也可以使用多级目录，但是每个目录下面都要有__init__.py这个文件，比如：1234567mypy|____ mymode| |____ __init__.py| |____ zhangdaxiang.py| |____ bangbang.py|____ __init__.py|____ abc.py 这个时候，模块名称就是mypy.mymode.zhangdaxiang。这种我们自己实现某些功能的模块就叫作第三方模块，于此对应的是python自带的功能模块叫作内置标准模块。记录一些平时经常用到的内置标准模块和第三方模块： 内置标准模块time模块时间表达形式在Python中，通常有这三种方式来表示时间：时间戳、格式化的时间字符串、元组(struct_time)即结构化时间。1.时间戳(timestamp) ：通常来说，时间戳表示的是从1970年1月1日00:00:00开始按秒计算的偏移量。我们运行type(time.time())，返回的是float类型。2.格式化的时间字符串(Format String)： ‘1994-11-05’3.元组(struct_time) ：struct_time元组共有9个元素共九个元素:(年，月，日，时，分，秒，一年中第几周，一年中第几天等）1234567891011import time#时间戳&gt;&gt;&gt; time.time() #返回当前时间的时间戳1424710567.7350585#时间字符串&gt;&gt;&gt; time.strftime("%Y-%m-%d %X") #%X为时分秒'2017-04-26 11:48:36'#时间元组&gt;&gt;&gt; time.localtime() #本地结构化时间time.struct_time(tm_year=2017, tm_mon=4, tm_mday=26, tm_hour=11, tm_min=50, tm_sec=16, tm_wday=3, tm_yday=116, tm_isdst=0)&gt;&gt;&gt; time.gmtime() #格里尼治结构化时间 以上的函数，不加默认值，均为当前时间。总之，时间戳是计算机能够识别的时间，时间字符串是人能够看懂的时间，元组则是用来操作时间的。 三种形式转换转换规则可以看下二图1234567891011#时间戳&lt;－－－－&gt;结构化时间： localtime/gmtime mktime&gt;&gt;&gt; time.localtime(time.time())&gt;&gt;&gt; time.gmtime(time.time())&gt;&gt;&gt; time.mktime(time.localtime()) &gt;&gt;&gt; time.mktime(time.gmtime())#字符串时间&lt;－－－－&gt;结构化时间： strftime／strptime&gt;&gt;&gt; time.strftime("%Y-%m-%d %X", time.localtime())&gt;&gt;&gt; time.strptime("2017-04-26","%Y-%m-%d") 1234&gt;&gt;&gt; time.asctime(time.localtime(time.time()))'Wed Apr 26 17:26:00 2017'&gt;&gt;&gt; time.ctime(time.time())'Wed Apr 26 17:26:04 2017' 12#其他方法time.sleep() #单位秒 random模块12345678910111213141516&gt;&gt;&gt; import random&gt;&gt;&gt; random.random() #大于0且小于1之间的小数&gt;&gt;&gt; random.randint(1,5) #大于等于1且小于等于5之间的整数&gt;&gt;&gt; random.randrange(1,5) #大于等于1且小于5之间的整数&gt;&gt;&gt; random.choice([1,'23',[4,5]]) #1或者23或者[4,5]&gt;&gt;&gt; random.sample([1,'23',[4,5]],2) #列表元素任意2个组合&gt;&gt;&gt; random.uniform(1,3) #大于1小于3的小数# 打乱次序&gt;&gt;&gt; item=[1,3,5,7,9]&gt;&gt;&gt; random.shuffle([1,3,5,7,9])&gt;&gt;&gt; item[5, 1, 3, 7, 9]&gt;&gt;&gt; random.shuffle(item)&gt;&gt;&gt; item[5, 9, 7, 1, 3] os模块12345678910111213141516171819&gt;&gt;&gt; import os&gt;&gt;&gt; os.getcwd() #当前python脚本工作的目录路径&gt;&gt;&gt; os.chdir() #改变工作目录&gt;&gt;&gt; os.curdir() #返回当前目录，即('.')&gt;&gt;&gt; os.pardir() #返回上一级目录,即('..')&gt;&gt;&gt; os.makedirs('dirname1/dirname2') #生成多层递归目录&gt;&gt;&gt; os.removedirs('dirname1') #若目录为空，则删除，并递归到上一级目录，如若也为空，则删除，依此类推&gt;&gt;&gt; os.mkdir('dirname') #生成单级目录&gt;&gt;&gt; os.rmdir('dirname') #删除单级目录&gt;&gt;&gt; os.listdir() #列出当前目录下的文件和子目录，包括隐藏的文件&gt;&gt;&gt; os.remove() #删除一个文件&gt;&gt;&gt; os.rename("oldname","newname") #重命名文件/目录&gt;&gt;&gt; os.sep #输出操作系统特定的路径分隔符，win下为"\\",Linux下为"/"&gt;&gt;&gt; os.linesep #输出当前平台使用的行终止符，win下为"\t\n",Linux下为"\n"&gt;&gt;&gt; os.pathsep #输出用于分割文件路径的字符串 win下为;,Linux下为:&gt;&gt;&gt; os.name #输出字符串指示当前使用平台。win-&gt;'nt'; Linux-&gt;'posix'&gt;&gt;&gt; os.system("bash command") #运行shell命令，直接显示&gt;&gt;&gt; os.environ #获取系统环境变量&gt;&gt;&gt; os.stat('path/filename') #获取文件/目录信息 123456789101112#os.stat('path/filename')的结构st_mode: inode 保护模式st_ino: inode 节点号。st_dev: inode 驻留的设备。st_nlink: inode 的链接数。st_uid: 所有者的用户ID。st_gid: 所有者的组ID。st_size: 普通文件以字节为单位的大小；包含等待某些特殊文件的数据。st_atime: 上次访问的时间。st_mtime: 最后一次修改的时间。st_ctime: 由操作系统报告的"ctime"。在某些系统上（如Unix）是最新的元数据更改的时间，在其它系统上（如Windows）是创建时间（详细信息参见平台的文档）。 123456789101112&gt;&gt;&gt; os.path.abspath(path) #返回path规范化的绝对路径&gt;&gt;&gt; os.path.split(path) #将path分割成目录和文件名二元组返回&gt;&gt;&gt; os.path.dirname(path) #返回path的目录。即os.path.split(path)的第一个元素&gt;&gt;&gt; os.path.basename(path) #返回path最后的文件名。若path以／或\结尾，那么就会返回空值。即os.path.split(path)的第二个元素&gt;&gt;&gt; os.path.exists(path) #如果path存在，返回True；如果path不存在，返回False&gt;&gt;&gt; os.path.isabs(path) #如果path是绝对路径，返回True&gt;&gt;&gt; os.path.isfile(path) #如果path是一个存在的文件，返回True。否则返回False&gt;&gt;&gt; os.path.isdir(path) #如果path是一个存在的目录，则返回True。否则返回False&gt;&gt;&gt; os.path.join(path1[, path2[, ...]]) #将多个路径组合后返回，第一个绝对路径之前的参数将被忽略&gt;&gt;&gt; os.path.getatime(path) #返回path所指向的文件或者目录的最后访问时间&gt;&gt;&gt; os.path.getmtime(path) #返回path所指向的文件或者目录的最后修改时间&gt;&gt;&gt; os.path.getsize(path) #返回path的大小 sys模块1234567&gt;&gt;&gt; import sys&gt;&gt;&gt; sys.argv #命令行参数的list，python 123.py a b c，第一个元素是程序本身路径,即返回[abspath//123.py,a,b,c]&gt;&gt;&gt; sys.exit(n) #退出程序，正常退出时exit(0)&gt;&gt;&gt; sys.maxint #最大的int值&gt;&gt;&gt; sys.platform #输出当前作系统平台名称&gt;&gt;&gt; sys.path #输出python的模块搜索路径，即环境变量&gt;&gt;&gt; sys.version #输出解释器版本 logging模块logging模块分5种高级级别，默认是WARNING。默认的日志格式为日志级别：Logger名称：用户输出消息。 123456&gt;&gt;&gt; import logging logging.debug('debug message') logging.info('info message') logging.warning('warning message') logging.error('error message') logging.critical('critical message') 配置日志格式，可以通过logging.basicConfig来配置。1234567891011logging.basicConfig(level=logging.DEBUG, format=&apos;%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s&apos;, datefmt=&apos;%a, %d %b %Y %H:%M:%S&apos;, filename=&apos;/tmp/test.log&apos;, filemode=&apos;w&apos;) logging.debug(&apos;debug message&apos;) logging.info(&apos;info message&apos;) logging.warning(&apos;warning message&apos;) logging.error(&apos;error message&apos;) logging.critical(&apos;critical message&apos;) 配置参数12345678910111213141516171819202122232425logging.basicConfig()函数中可通过具体参数来更改logging模块默认行为，可用参数有：filename：用指定的文件名创建FiledHandler，这样日志会被存储在指定的文件中。filemode：文件打开方式，在指定了filename时使用这个参数，默认值为“a”还可指定为“w”。format：指定handler使用的日志显示格式。datefmt：指定日期时间格式。level：设置rootlogger的日志级别stream：用指定的stream创建StreamHandler。可以指定输出到sys.stderr,sys.stdout或者文件(f=open(‘test.log’,’w’))，默认为sys.stderr。若同时列出了filename和stream两个参数，则stream参数会被忽略。format参数中可能用到的格式化串：%(name)s Logger的名字%(levelno)s 数字形式的日志级别%(levelname)s 文本形式的日志级别%(pathname)s 调用日志输出函数的模块的完整路径名，可能没有%(filename)s 调用日志输出函数的模块的文件名%(module)s 调用日志输出函数的模块名%(funcName)s 调用日志输出函数的函数名%(lineno)d 调用日志输出函数的语句所在的代码行%(created)f 当前时间，用UNIX标准的表示时间的浮 点数表示%(relativeCreated)d 输出日志信息时的，自Logger创建以 来的毫秒数%(asctime)s 字符串形式的当前时间。默认格式是 “2003-07-08 16:49:45,896”。逗号后面的是毫秒%(thread)d 线程ID。可能没有%(threadName)s 线程名。可能没有%(process)d 进程ID。可能没有%(message)s用户输出的消息 一般我们用的比较多的是创建Logger对象，然后来输出日志，如下12345678910111213141516171819202122232425262728import logginglogger = logging.getLogger()#设定日志级别logger.setLevel('DEBUG')#创建一个写入文件的HandlerfileHandler = logging.FileHandler('test.log')#创建一个输出到屏幕的HandlerstreamHandler = logging.StreamHandler()#格式化字符串formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')fileHandler.setFormatter(formatter)streamHandler.setFormatter(formatter)#logger对象可以添加多个Handlerlogger.addHandler(fileHandler)logger.addHandler(streamHandler)logger.debug('logger debug message')logger.info('logger info message')logger.warning('logger warning message')logger.error('logger error message')logger.critical('logger critical message') 日志等级分别有以下几种：123456CRITICAL : 'CRITICAL',ERROR : 'ERROR',WARNING : 'WARNING',INFO : 'INFO',DEBUG : 'DEBUG',NOTSET : 'NOTSET' hashlib模块hashlib是个专门提供hash算法的库，现在里面包括md5,sha1,sha224,sha256,sha384,sha512。123456789101112import hashlibmd51 = hashlib.md5()md51.update('12345678'.encode('utf-8'))print(md51.hexdigest())#如果数据量过大，可以分多次update()，结果一样md52 = hashlib.md5()md52.update('1234'.encode('utf-8'))md52.update('5678'.encode('utf-8'))print(md52.hexdigest()) 由于常用口令的MD5值很容易被计算出来，所以，要确保存储的用户口令不是那些已经被计算出来的常用口令的MD5，这一方法通过对原始口令加一个复杂字符串来实现，俗称“加盐”：1hashlib.md5("salt".encode("utf8")) 第三方模块]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>module</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python之路(3):高级特性]]></title>
    <url>%2F2016%2F11%2F13%2Fpython%E4%B9%8B%E8%B7%AF(3)%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[高级特性呢能使得我们代码越来越少,越来越精简。代码这个东西，当然是越少越好了。 列表生成式有个需求，要把列表[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]的每个值加1，有两种写法：123456#第一种for i in range(len(L)); L[i]+=1#第二种for index,i in enumerate(L): L[index]+=1 我们使用列表生成式的话可以这样写：1[i+1 for i in L] 感觉既简单又清晰。for循环后面还可以加上if判断，这样我们就可以筛选出仅偶数的平方：12&gt;&gt;&gt; [x * x for x in range(1, 13) if x % 2 == 0][4, 16, 36, 64, 100,144] 还可以使用两层循环，可以生成全排列：12&gt;&gt;&gt; [m + n for m in 'ABC' for n in 'XYZ']['AX', 'AY', 'AZ', 'BX', 'BY', 'BZ', 'CX', 'CY', 'CZ'] 也可以同时作用在两个变量来生成列表表达式：123&gt;&gt;&gt; people=&#123;'name':'张大象','age':'25','city':'hangzhou'&#125;&gt;&gt;&gt; [k+'='+v for k,v in people.items()]['city=hangzhou', 'name=张大象', 'age=25'] 生成器通过列表生成式,我们可以很方便地生成一个列表。但是如果我们要生成一个数量很大的列表，这样会占用很多的空间和资源。如果我们只访问其中的一部分元素，那其他的元素所占的空间都浪费了。python有一个叫生成器(generator)的东西，可是使得我们在循环的时候，边循环边生成，这样就不会浪费很多空间了。创建一个生产器常用的有两种方法，第一种方法很简单。就是把列表生成式的[]改成()，这样就是一个generator了：123456&gt;&gt;&gt; L = [i*i for i in range(8)]&gt;&gt;&gt; L[0, 1, 4, 9, 16, 25, 36, 49]&gt;&gt;&gt; g = (i*i for i in range(8))&gt;&gt;&gt; g&lt;generator object &lt;genexpr&gt; at 0x000000000348FBF8&gt; 可以看到,L是一个列表，而g是一个生成器。要调用的话,我们可以使用next()函数：123456789101112131415161718192021&gt;&gt;&gt; next(g)0&gt;&gt;&gt; next(g)1&gt;&gt;&gt; next(g)4&gt;&gt;&gt; next(g)9&gt;&gt;&gt; next(g)16&gt;&gt;&gt; next(g)25&gt;&gt;&gt; next(g)36&gt;&gt;&gt; next(g)49&gt;&gt;&gt; next(g)Traceback (most recent call last): File "&lt;pyshell#13&gt;", line 1, in &lt;module&gt; next(g)StopIteration 生成器保存的是算法,每次调用g，就是计算出下一个元素的值，直到最后一个元素，没有元素的时候，就会报出StopIteration的错误。当然了,一直用next()调用生成器显得很麻烦，其实我们也可以用for循环来迭代生成器：12345678910111213&gt;&gt;&gt; g=(i*i for i in range(8))&gt;&gt;&gt; for i in g: print(i) 014916253649 而且全部迭代完了以后,也不会报错。我们也可以使用函数的方法来生成一个生成器,比如说斐波拉契数列很难用列表生成式写出来,但是写一个函数很简单,同样的,我们也可以用函数生成一个斐波拉契数列的生成器,只要函数里有yield就可以了。这就是生成生成器的另一种方法：12345678910111213141516def fib(max): a,b,n=1,1,0 while n&lt;max: yield a a,b=b,a+b n+=1 return 'done'&gt;&gt;&gt; for i in fib(5): print(i) 11235 这一类生成器的规则是，每次执行遇到yield则会返回，然后停止，直到下次运行的时候，就会从yield处接着执行。而且我们发现，用for循环来执行函数生成器，并不能获得return的值。这是因为，return值包含在StopIteration的value中。可以这样来捕获StopIteration值：1234567891011121314g=fib(5)while True: try: x=next(g) print(x) except StopIteration as e: print(e.value) break11235done 成了,这样就捕获到了return的值。(2017年2月更新)今天了解到了生成器还有send()和throw()两种方法，深感之前学的都是皮毛。总结一下这两个方法,看这个示例代码：1234567def gen(): for i in range(5): tmp = yield i if tmp == 'hello': print('zhangdaxiang') else: print(str(tmp)) 123&gt;&gt;&gt; g=gen()&gt;&gt;&gt; next(g)0 我们先调用next()方法，使生成器运行到yield位置，此时暂停执行环境，并返回yield的值。所以返回出来的是1，并暂停执行环境。123&gt;&gt;&gt; next(g)None1 可以看到,这里返回了两个值None和1，是不是感觉很奇怪。其实也很简单，因为上一次运行到yield 0暂停运行环境，现在恢复运行，先给tmp赋值(但是这里tmp获得的值不是i的值，而是send方法传过来的值)。由于我们没有调用send()方法，所以tmp的值是None。运行顺序是，先print出tmp的值，然后运行到yield 1，返回1，然后暂停执行环境。123&gt;&gt;&gt; g.send('hello')zhangdaxiang2 上一次我们运行到yield 1后暂停，现在我们输入send(&#39;hello&#39;)，程序接收到hello并给tmp赋值hello。此时tmp==&#39;hello&#39;为真，所以打印出zhangdaxiang，然后执行到下一次yield 2，返回2。（next()等价于send(None)）当yield全部运行结束以后将会报出StopIteration的错误，看下面这段代码：123456789101112def stoperror(x): if x=='daxiang': yield x else: print('nono')&gt;&gt;&gt; g=stoperror('bangbang')&gt;&gt;&gt; next(g)nonoTraceback (most recent call last): File "&lt;pyshell#1&gt;", line 1, in &lt;module&gt; next(g)StopIteration 果然,先打印出nono，然后因为没有yield，就StopIteration报错了。再通过下面这段代码，我们来理解throw()方法的使用：123456789101112131415161718def throwerror(x): try: yield x except ValueError: print('value error') finally: print('clean')&gt;&gt;&gt; g=throwerror('daxiang')&gt;&gt;&gt; next(g)'daxiang'&gt;&gt;&gt; g.throw(ValueError)value errorcleanTraceback (most recent call last): File "&lt;pyshell#2&gt;", line 1, in &lt;module&gt; g.throw(ValueError)StopIteration 先调用next()，返回daxiang，然后用throw()传入一个ValueError的错误，except捕捉然后打印出value error和clean。更神奇的是,我们可以用生成器在单线程的情况下实现并发运算：123456789101112131415161718def fun1(): for i in range(4): yield 'a'+str(i)def fun2(): for i in range(4): yield 'b'+str(i)L=[]L.append(fun1())L.append(fun2())def run(L): for i in L: try: print(next(i)) except StopIteration: pass else: L.append(i)run(L) 迭代器迭代器原理能够直接作用于for循环的对象就可以称之为可迭代对象(Iterable)，我们可以用isinstance()来判定一个对象是否为可迭代对象。123456789&gt;&gt;&gt; from collections import Iterable&gt;&gt;&gt; isinstance((x for x in range(5)),Iterable)True&gt;&gt;&gt; isinstance([1,2,3],Iterable)True&gt;&gt;&gt; isinstance('zhangdaxiang',Iterable)True&gt;&gt;&gt; isinstance(1000,Iterable)False 以此同时,生成器不但可以使用for循环，还可以调用next()函数，来返回下一个值，最好抛出StopIteration错误来终止。对于这种可以调用next()的可迭代对象，称之为迭代器。同样也可以使用isinstance()函数来判断一个对象是否为Iterator(迭代器)：1234567&gt;&gt;&gt; from collections import Iterator&gt;&gt;&gt; isinstance((x for x in range(5)),Iterator)True&gt;&gt;&gt; isinstance([1,2,3],Iterator)False&gt;&gt;&gt; isinstance('zhangdaxiang',Iterator)False 可以看到，生成器不但是Iterable也是Iterator，而str,list和dict这些，只是Iterable而不是Iterator。对于str,list和dict这些不是迭代器的对象，可以使用iter()函数来让他变成迭代器：1234&gt;&gt;&gt; isinstance(iter([1,2,3]),Iterator)True&gt;&gt;&gt; isinstance(iter('zhangdaxiang'),Iterator)True str,list和dict这些对象不是迭代器的原因是，在python中，迭代器Iterator是一个数据流，我们可以通过next()函数来计算出下一个值，直到StopIteration报错。我们可以把它看作一个有序的数据流，但是我们并不知道他的具体长度。所以，Iterator是惰性的，只有需要返回下一个值的时候它才会计算。实际上，在python中，for循环就是通过不断地调用next()来实现的：12for i in range(5): print(i) 等价于123456g=iter(range(5))while True: try: print(next(g)) except StopIteration: break 利用Iterator和filter求质数上一篇我们学习了filter()筛选函数，现在我们可以用Iterator来表示无限序列，所以我们可以来利用Iterator和filter求所有质数。要计算质数我们首先要理解一个算法，叫作埃氏筛法：1.先把1给剔除，因为数学界中1既不是质数也不是合数。2.将当前队列中最小的数2和2的倍数全部剔除。3.将当前队列中最小的数3和3的倍数全部剔除。4.将当前队列中最小的数5和5的倍数全部剔除。5.不断筛选下去，直到范围内所求的数全部剔除。首先我们构建一个从3开始的奇数数列，我们可以用Iterator来表示一个无限数列：12345def odd(): n=1 while True: n=n+2 yield n 然后再定义一个筛选函数：12def fun(n): return lambda x:x%n!=0 然后定义一个生成器，不断返回质数：1234567def p_number(): yield 2 num=odd() while True: n=next(num) yield n num=filter(fun(n),num) 可以看到,因为p_number()也是一个无限序列，加一个跳出条件就可以调用：12345for i in p_number(): if i &lt; 1000: print(i) else: break 装饰器软件开发的时候有一个原则，叫作”开放-封闭”原则，简单来说，就是已经实现功能的代码不允许被修改，但是可以被拖着，即：封闭：已经实现的代码块不允许被修改。开放：可以对已实现的功能进行拓展。所以我们在给一个函数添加新功能的时候,一般就不会直接修改原有的函数模块,而是在函数外部添加新的代码块来添加新功能。python中就有这么一个语法糖来实现这个，叫做装饰器decorator。装饰器实际上就是一个把原函数作为参数传入的高阶函数，返回另一个在内部定义的函数。 基本写法我们举一个”开放-封闭”的例子：比如说我们的视频网站有好多版块：123456def animal(): print('aniaml'.join(['-'*10]*2))def china(): print('china'.join(['-'*10]*2))def japan(): print('japan'.join(['-'*10]*2)) 现在有一个要求，我们的animal版块和china版块，需要会员登录才能访问，而japan版本不受影响。秉着”开放-封闭”的原则，我们不修改原有的函数，在外部直接添加会员登录的新功能。12345678910111213141516171819202122232425262728293031user_status=False#如果用户验证通过，则会改为Truedef login(fun): def inner(*args,**kwargs): _user_name='zhangdaxiang' _password='123456' global user_status if user_status==False: username=input('输入用户名：') password=input('输入密码：') if username==_user_name and password==_password: print('登录成功！') user_status=True else: print('密码错误！') if user_status==True: return fun(*args,**kwargs) return inner#返回内部函数inneranimal=login(animal)china=login(china)&gt;&gt;&gt; animal()输入用户名：zhangdaxiang输入密码：123456登录成功！----------aniaml----------&gt;&gt;&gt; china()----------china----------&gt;&gt;&gt; japan()----------japan---------- 实际上按照装饰器的写法，也可以写成这样：12345678910@logindef animal(): print('aniaml'.join(['-'*10]*2))@logindef china(): print('china'.join(['-'*10]*2)) def japan(): print('japan'.join(['-'*10]*2)) 实际上123@logindef animal(): pass 等价于1animal=login(animal) 添加新功能如果我们想再新加一个功能,比如登录之后输出一个欢迎语句,直接在修饰器里面改变就好了：123456789101112131415161718192021222324252627282930313233343536373839404142user_status=Falsedef login(fun): def inner(*args,**kwargs): _user_name='zhangdaxiang' _password='123456' global user_status if user_status==False: username=input('输入用户名：') password=input('输入密码：') if username==_user_name and password==_password: print('登录成功！') user_status=True else: print('密码错误！') if user_status==True: print('welcom to %s'%fun.__name__)#添加一个欢迎语句，输出函数名称 return fun(*args,**kwargs) return inner@logindef animal(): print('aniaml'.join(['-'*10]*2))@logindef china(): print('china'.join(['-'*10]*2)) def japan(): print('japan'.join(['-'*10]*2))&gt;&gt;&gt; animal()输入用户名：zhangdaxiang输入密码：123456登录成功！welcom to animal----------aniaml----------&gt;&gt;&gt; china()welcom to china----------china----------&gt;&gt;&gt; japan()----------japan---------- 带参数的装饰器如果decorator本身也需要传入一个参数，就需要编写一个返回decorator的高阶函数，比如：123456789101112131415161718192021222324252627282930313233343536user_status=Falsedef login(text): def inner1(fun): def inner2(*args,**kwargs): _user_name='zhangdaxiang' _password='123456' global user_status if user_status==False: username=input('输入用户名：') password=input('输入密码：') if username==_user_name and password==_password: print('登录成功！') user_status=True else: print('密码错误！') if user_status==True: print('welcom to %s,%s'%(fun.__name__,text)) return fun(*args,**kwargs) return inner2 return inner1animal=login('thx')(animal)#login('thx')返回inner1，所以inner1('thx')返回inner2。china=login('thx')(china)&gt;&gt;&gt; animal()输入用户名：zhangdaxiang输入密码：123456登录成功！welcom to animal,thx----------aniaml----------&gt;&gt;&gt; china()welcom to china,thx----------china----------&gt;&gt;&gt; japan()----------japan---------- 和预期一样,我们也可以用这种写法：12345678910@login(&apos;thx&apos;)def animal(): print(&apos;aniaml&apos;.join([&apos;-&apos;*10]*2))@login(&apos;thx&apos;)def china(): print(&apos;china&apos;.join([&apos;-&apos;*10]*2)) def japan(): print(&apos;japan&apos;.join([&apos;-&apos;*10]*2)) 实际上，123@log('thx')def animal(): pass 等价于1anmial=login('thx')(animal) 首先执行login(&#39;thx&#39;)，返回的是inner1函数，再调用返回的函数，参数是animal函数，返回值最终是inner2函数。 返回函数的name但是需要注意的是，aninmal函数经过装饰器装饰以后，他的__name__已经从原来的animal变成了inner2:12&gt;&gt;&gt; animal.__name__'inner2' 因为最后返回的那个inner2()函数名字就是inner2，所以需要把原始函数的__name__等属性复制到inner2()中，否则一些依赖函数签名的代码执行就会出错。不过并不需要编写inner2.__name__=func.__name__这样的代码，python内置的functools.wraps就是专门处理这个的，所以一个完整的decorator的写法是这样的：123456import functoolsdef login(fun): @functools.wraps(func) def inner(*args,**kwargs): return func(*args,**kwargs) return inner 或者对于有参数的decorator：123456789import functoolsdef login(text): def inner1(fun): @functools.wraps(fun) def inner2(*args,**kwargs): print（'%s'%fun.__name__） return fun(*args,**kwargs) return inner2 return inner1 只需要最返回函数前加上@functools.wraps(fun)即可。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python之路(2):函数]]></title>
    <url>%2F2016%2F11%2F08%2Fpython%E4%B9%8B%E8%B7%AF(2)%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[函数基础函数的定义函数是指一个封装好的语句集合,我们想要调用这些语句,只需要调用这些函数名即可。使用函数的话，我们可以获得以下的几个特性：1.减少代码的重复性。2.增加程序的可维护性。3.使得程序变得可拓展。定义函数：123def fun(): #函数名称 pass #函数内容fun() #调用函数 注意,上面的函数内容是pass，这代表该函数是一个空函数，即直接略过函数内容，调用他没有任何意义。如果想要定义一个有实际内容的函数，将其中的pass改为实际代码即可。 函数的返回在函数中使用return可以返回函数的运行结果：12345def num(a,b): sum=a+b return sum #返回函数运行结果&gt;&gt;&gt; num(1,2)3 如果没有return，函数运行完毕后也会返回一个None，也就是return None，可以简写成return。函数也可以返回多个值：123456def sum(a,b,c): sum1=a+b sum2=a+c return sum1,sum2&gt;&gt;&gt; sum(1,2,3)(3, 4) 可以看到,函数返回多个值,实际上是返回一个tuple。 函数的参数检查python中有很多可以直接调用的函数,称之为内置函数。如果是内置函数输入类型不正确的参数，就会报错。而我们定义的函数，因为没有参数检查，所以虽然也会报错，但是python不会替我们检查，所以和内置函数的报错不一样。为了使得报错更直观，我们可以引入参数检查。我们定义一个求绝对值的函数：12345def my_abs(x): if x&gt;=0: return x else: return -x 比较my_abs和内置函数abs的报错信息有什么区别：123456789&gt;&gt;&gt; my_abs('A')Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; File "&lt;stdin&gt;", line 2, in my_absTypeError: unorderable types: str() &gt;= int()&gt;&gt;&gt; abs('A')Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;TypeError: bad operand type for abs(): 'str' 可以看到，内置函数有参数检查。为my_abs添加一个参数检查,检查传入参数是否为浮点数或整数：1234567def my_abs(x): if not isinstance(x,(int,float)): raise TypeError('error type!') if x&gt;=0: return x else: return -x 这时候，如果输入参数错误的话，python会进行参数检查：1234567&gt;&gt;&gt; my_abs('A')Traceback (most recent call last): File "&lt;pyshell#0&gt;", line 1, in &lt;module&gt; my_abs('A') File "C:\Users\Administrator\Desktop\123.py", line 3, in my_abs raise TypeError('error type!')TypeError: error type! 函数的参数定义函数的时候,我们把函数的名称和参数确定下来,函数接口的定义就已经完成了。使用者只需要了解函数的怎么正确传递参数，以及函数返回什么类型的值就可以了。内部封装好的逻辑，使用者不用去管。python函数定义非常灵活，参数在除位置参数外,还有默认参数,可变参数,关键字参数。 默认参数我们在定义一个函数的时候,可以为一个或者更多的参数设置默认值,这样的参数在调用的时候如果没有输入,则会使会用默认值。使用默认参数的话，可以大大降低函数调用的难度，而一旦需要更复杂的调用时，又可以传递更多的参数来实现。无论是简单调用还是复杂调用，函数只需要定义一个：12345678910def sum(a,b,c=3): sum1=a+b sum2=a+c return sum1,sum2&gt;&gt;&gt; sum(1,2,2)(3, 3)&gt;&gt;&gt; sum(1,2,3)(3, 4)&gt;&gt;&gt; sum(1,2) #这里就使用了默认参数，c默认为3，和上面是一样的(3, 4) 使用默认参数要注意两点：1.位置参数在前，默认参数在后。2.变化大的默认参数在前，变化小的默认参数在后。还有一点值得注意的是，默认参数有一个巨大的坑，是关于可变对象的。我们要记住，默认参数尽量使用不可变对象。123def my_add(L=[]): L.append('*') return L 我们来尝试调用这个函数：123456&gt;&gt;&gt; my_add() #一开始调用结果是对的['*']&gt;&gt;&gt; my_add() #再次调用结果就不对了['*', '*']&gt;&gt;&gt; my_add()['*', '*', '*'] 这是因为,在定义函数的时候,默认参数的值已经被计算出来了,就是[]，而默认参数L也是一个变量，指向的是[],每次调用函数，L只想的对象也变了，所以默认参数的内容也就随之改变了。 可变参数当我们不能确定使用者要传入多少参数时,可以定义一个可变参数,用*args,仅仅需要在参数前面加一个*就可以了。实际上，可变参数是作为一个tuple传入的。可以这样定义:1234567def my_sum(*numbers): sum=0 for i in numbers: sum+=i return sum&gt;&gt;&gt; my_sum(1,2,3,4,5,6)21 如果传入的参数是一个列表,我们也可以灵活调用我们的可变参数函数:123&gt;&gt;&gt; L=[1,2,3,4,5,6]&gt;&gt;&gt; my_sum(*L)21 关键字参数可变参数是允许传入0或多个参数,组成一个tuple。而关键字参数则是允许你传入0或多个带有参数名的参数，组成一个dict,可以使用关键字参数*kw来表示。定义如下：12def people(name, age, **kw): print('name:', name, 'age:', age, 'other:', kw) 可以看到，people函数除了name和age两个位置参数以外，还有一个关键词参数kw。我们在调用的时候，可以只传入位置参数：12&gt;&gt;&gt; people('张大象',25)name: 张大象 age: 25 other: &#123;&#125; 也可以传入任意个关键词参数：1234&gt;&gt;&gt; people('张大象',25,city='杭州')name: 张大象 age: 25 other: &#123;'city': '杭州'&#125;&gt;&gt;&gt; people('张大象',25,city='杭州',job='student')name: 张大象 age: 25 other: &#123;'city': '杭州', 'job': 'student'&#125; 关键词参数的作用就体现在这里，我们保证能够接收到name和age这两个参数，但是如果调用者传入更多的参数，我们也可以接收到。同样的，类似于可变参数，我们也可以灵活地调用关键词参数：123&gt;&gt;&gt; others=&#123;'city':'杭州','job':'student'&#125;&gt;&gt;&gt; people('张大象',25,**others)name: 张大象 age: 25 other: &#123;'city': '杭州', 'job': 'student'&#125; 命名关键字参数命名关键字参数的作用是限制关键字参数的开放性,限制可以传入的关键字参数。比如我们限制只能传入city和job这两个关键词参数：12def people(name,age,*,city,job): print(name,age,city,job) 和**kw关键词参数不同，使用了一个特殊分隔符*，后面的参数就视为命名关键字参数。调用方法如下:1234567&gt;&gt;&gt; people('张大象',25,city='杭州',job='student')张大象 25 杭州 student&gt;&gt;&gt; people('张大象',25,city='杭州',sex='man') #传入其他参数则会报错Traceback (most recent call last): File "&lt;pyshell#2&gt;", line 1, in &lt;module&gt; people('张大象',25,city='杭州',sex='man')TypeError: people() got an unexpected keyword argument 'sex' 如果前面的参数已经有*args可变参数，就不想要特殊分隔符*，可变参数后面的就是命名关键字参数。12def peope(name,age,*args,city,job): print(name,age,args,city,job) 而且命名关键字参数必须传入参数名，这和位置参数不同。如果没有传入参数名，将会报错：12345&gt;&gt;&gt; people('张大象',25,'杭州','student')Traceback (most recent call last): File "&lt;pyshell#0&gt;", line 1, in &lt;module&gt; people('张大象',25,'杭州','student')TypeError: people() takes 2 positional arguments but 4 were given 调用的时候没有因为没有参数名，python把四个参数都看作位置参数，所以报错。 递归函数 如果一个函数在函数内部调用了自己，那这个函数就是一个递归函数。具有以下特效： 1.必须要有一个比较明确的结束条件。 2.没进行一次递归，数据规模总比上一次要减少。 3.递归效率不高，递归次数太多会造成栈溢出。 阶乘计算阶乘n! = 1 x 2 x 3 x ... x n，用函数fact(n)表示:12345def fact(n): if n==1: return n else: return n*fact(n-1) 计算机中，函数的调用是通过栈这种数据结构实现的。每调用一次函数，就占用一个栈帧，函数返回一次就减少一个栈帧。因为栈帧不是无限的，所以要注意使用递归的时候，防止占用栈帧过多，导致栈溢出。 二分查找123456789101112131415161718data = [1, 3, 6, 7, 9, 12, 14, 16, 17, 18, 20, 21, 22, 23, 30, 32, 33, 35]def mid_search(data,num): print(data) if len(data)&gt;1: mid_num=int(len(data)/2) if num == data[mid_num]: print('找到数字',data[mid_num]) elif num &gt; data[mid_num]: print('数字在%s右边'%data[mid_num]) return mid_search(data[mid_num+1:],num) elif num &lt; data[mid_num]: print('数字在%s左边'%data[mid_num]) return mid_search(data[0:mid_num],num) elif len(data)==1: if num==data[0]: print('找到数字',data[0]) else: print('没有这个数字') 匿名函数匿名函数就是不需要显式的指定函数:12345678#这段代码def my_sum(a,b): return a+bprint(my_sum(1,2)) #换成匿名函数my_sum=lambda a,b:a+bprint(my_sum(1,2)) 高阶函数我们知道,变量可以指向一个函数,这样的话,一个函数就可以接收另外一个函数作为参数:12def fun(x,y,f): return f(x)+f(y) map/reducepython有两个非常有用的函数map()和reduce()。先说map()，map()接受两个参数，一个是函数，另一个是Iterable。map()依次将函数作用于Iterable的每一个元素，然后返回一个Iterator。举个栗子,现在有一个函数f(x)=x+1，我们可以使用map()函数来使得整个函数作用在列表[1,2,3,4,5,6,7]的每一个元素上。123456def fun(x): x = x+1 return xL = map(fun,[1,2,3,4,5,6,7])&gt;&gt;&gt; print(list(L))[2, 3, 4, 5, 6, 7, 8] 因为返回的L是一个惰性序列Iterator，我们使用list()将每一个元素计算出来并返回一个list。接下来看reduce()的用法，reduce是将一个函数作用在一个序列[x1,x2,x3,x4…..]上，这个函数需要接收两个参数，然后将返回的结果和下一个参数继续传给这个函数。就是：1reduce(f,[x1,x2,x3,x4])=f(f(f(x1,x2),x3),x4) 这个例子其实是没什么用的,但是我们可以根据这个例子来再配合map()来写出str和int相互转换的函数：123456789from functools import reducedef str2int(s): def fun(x,y): return 10*x+y def str2num(x): return &#123;'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9&#125;[x] return reduce(fun,map(str2num,s))&gt;&gt;&gt; str2int('19941105')19941105 这个其实就和python内置的int()效果是一样的。 filterpython内置的filter()函数可以用于对序列进行过滤。和map()一样，filter()也是作用于一个序列的，对每个序列进行判定，True则保留，False则剔除。比如说我们要剔除一个list里面的奇数，保留偶数：1234def fun(x): return x%2==0&gt;&gt;&gt; list(filter(fun,[1,2,3,4,5,6]))[2, 4, 6] 由于filter()函数返回的也是一个Iterator，也是一个惰性函数，所以需要使用list()来计算所有值，并返回一个列表。 sortedpython内置的sorted()函数可以对一个序列进行排序：12345678&gt;&gt;&gt; L=[3,2,5,7,10]&gt;&gt;&gt; sorted(L)[2, 3, 5, 7, 10]&gt;&gt;&gt; L[3, 2, 5, 7, 10]&gt;&gt;&gt; L.sort()&gt;&gt;&gt; L[2, 3, 5, 7, 10] 我们可以看到,list的方法sort()和sorted()是不一样的。同时，sorted也是一个高阶函数，可以传入一个key函数作为参数进行自定义排序。比如说我们要按序列的绝对值进行排序：12&gt;&gt;&gt; sorted([-8,1,10,-3,4,6],key=abs)[1, -3, 4, 6, -8, 10] 如果是对字符串进行比较的话，是按照ASCII码的顺序进行排序的，比如：12&gt;&gt;&gt; sorted(['apple','banana','Ales','zero','Sex'])['Ales', 'Sex', 'apple', 'banana', 'zero'] 因为在ASCII中，S是排在a前面的，所以Sex排在apple前面。如果我们想要忽略字母大写排序的话，可以这样：12&gt;&gt;&gt; sorted(['apple','banana','Ales','zero','Sex'],key=str.lower)['Ales', 'apple', 'banana', 'Sex', 'zero'] 要倒叙排序的话，可以使用第三个参数reverse=True，并不需要对key进行改动：12&gt;&gt;&gt; sorted(['apple','banana','Ales','zero','Sex'],key=str.lower,reverse=True)['zero', 'Sex', 'banana', 'apple', 'Ales']]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python之路(1):python基础]]></title>
    <url>%2F2016%2F11%2F06%2Fpython%E4%B9%8B%E8%B7%AF(1)python%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[数据类型和变量python的数据类型可以分为以下几种： 整数python中的整数和数学中的整数定义并没有什么不同，但是由于计算机使用的是二进制，所以用0x为前缀的十六进制来表示更为方便，比如0xa5b4c4d2等 浮点数浮点数就是我们通常意义上的小数,对于很大的浮点数,我们需要用科学计数法来表示,把其中的10用e来代替。比如说1.6x10^9就表示为1.6e9。 字符串字符串就是用&#39;和&quot;双引号括起来的任意文本，比如&#39;abc&#39;和&quot;abc&quot;就是同一字符串。如果字符串中同时包含&#39;和&quot;的话，可以使用转义符\来转义：1'I\'m \"daxiang\"' 就是1I'm "daxiang" 转义符\还可以转义很多东西，比如\n就是换行，\t就是制表符，而\\表示的就是\。为了避免转义符带来的困扰，python还引入了r&#39;&#39;原始字符串的概念，r&#39;&#39;中间的字符串默认不转义。 布尔值布尔值就是True和False,拥有运算and,or,not。 空值空值在python中用None表示，None不等同于0，0在python是有实际意义的一个数字，而None是一个特殊的空值。 字符串和编码字符编码说到字符编码，首先要介绍一下他的产生历史。一开始呢，只有127个字符被编码到了计算机里面，就是一些大小写字母和一些特俗符合，这个叫做ASCII码。这个对于外国人来说，已经够用了。但是如果我们想处理中文的话，显然这套编码是不够用的。所以中国人就制定了GB2312编码提供给自己使用。同样的，每种语言都给自己制定了一套编码。很快，编码世界就非常混乱，多语言的文本经常出现乱码问题。所以，经过讨论，制定出了一种适合所有语言的编码，叫做Unicode。这套编码把所有语言都包含进去了，所以也不存在乱码的问题。但是，存在的问题也很明显。ASCII编码占用的是一个字节，而Unicode编码通常占用两个字节。。虽然乱码的问题解决了，但是存储和传输所消耗的资源却比之前多很多。对于之前适用ASCII编码的那些字符，套用Unicode编码就显得非常不合适。本着节约的精神，”可变长编码”utf-8编码也就应运而生。utf把将Unicode编码的字符根据数字大小编码成1-6个字节。常见的英文字母被编码成1个字节，而中文一般被编码成3个字节，只有一些生僻的字符才会被编码成4-6个字节。同时，还可以将ASCII编码视为utf-8编码的一部分，这样也可以和之前使用ASCII编码的程序兼容，解决历史遗留问题。然后，我们概括一下计算机中编码的工作方式：在计算机内存里，统一使用Unicode编码，在需要保存和传输的时候，转换成utf-8编码。比如说我们在编辑一个txt文件，我们先将从文件中读取的utf-8字符转换成Unicode字符存放在内存里。在编辑完以后，再转换成utf-8字符存储到txt文件。再比如说我们在浏览一个网页，服务器先将动态生成的Unicode转换成utf-8字符，然后传输给我们。我们接收到utf-8字符再转换成Unicode字符展现出来。 python的字符串字符串最大的特点,即不可变，不论使用什么函数，字符串的本身是不会变化的。在python3中，已经适配了Unicode编码，所以说python3可以直接输出中文，而不会像python2那样乱码了。同时，python3提供了ord()来将字符转换成编码的整数形式，提供了chr()将整数形式的编码转换成字符。1234&gt;&gt;&gt; ord('A')65&gt;&gt;&gt; chr(66)'B' 也可以用十六进制来表示整数:12&gt;&gt;&gt; '\u5f20\u5927\u8c61''张大象' 这两张写法是完全等价的。在python3中，字符串类型是str，在内存中以Unicode表示，一个字符对应几个字节。如果需要传输或者保存的话，就需要通过encode()方法转换成以字节为单位的字符串类型bytes。在python中对于bytes类型的数据，用带b前缀的单引号或者双引号表示。12&gt;&gt;&gt; b'ABC'b'ABC' 这里的b&#39;ABC&#39;和&#39;ABC&#39;是不一样的，一个是bytes，一个是str。其中b&#39;ABC&#39;是以字节为单位的。如果b&#39;&#39;中间的字符不是ASCII中的，则会报错：12&gt;&gt;&gt; b'张大象'SyntaxError: bytes can only contain ASCII literal characters. 同时，对于无法用ASCII编码表示的字符，python会用/x###来表示：1234&gt;&gt;&gt; 'ABC'.encode('utf-8')b'ABC'&gt;&gt;&gt; '张大象'.encode('utf-8')b'\xe5\xbc\xa0\xe5\xa4\xa7\xe8\xb1\xa1' 反过来，如果从磁盘中或者浏览器得到bytes的字节流，我们希望转换成Unicode的字符，可以使用decode()：1234&gt;&gt;&gt; b'ABC'.decode('utf-8')'ABC'&gt;&gt;&gt; b'\xe5\xbc\xa0\xe5\xa4\xa7\xe8\xb1\xa1'.decode('utf-8')'张大象' 可以使用len()来计算长度，str计算的是字符数，bytes计算的是字节数：1234&gt;&gt;&gt; len('张大象')3&gt;&gt;&gt; len(b'\xe5\xbc\xa0\xe5\xa4\xa7\xe8\xb1\xa1')9 由此可见，中文在utf-8中一般编码成3个字节。记录一下字符串的常见操作：1.去除空格:1234567&gt;&gt;&gt; name=' zhangdaxiang '&gt;&gt;&gt; name.strip() #删除字符串两边的指定字符，括号的写入指定字符，默认为空格'zhangdaxiang'&gt;&gt;&gt; name.lstrip() #删除字符串左边的指定字符，括号的写入指定字符，默认为空格'zhangdaxiang '&gt;&gt;&gt; name.rstrip() #删除字符串右边指定字符，默认为空格' zhangdaxiang' 2.连接字符串:123456789101112#万恶的加号&gt;&gt;&gt; name='zhangdaxiang '&gt;&gt;&gt; profession=' student'&gt;&gt;&gt; str=name+'is a'+profession&gt;&gt;&gt; str'zhangdaxiangis astudent'#使用一次加号会开辟一个name+profession大小的存储单元，如果使用N次加号，就会开辟N次，这是非常消耗资源的，也是"万恶"的来源。&gt;&gt;&gt; num='12345'&gt;&gt;&gt; str='+'&gt;&gt;&gt; result=str.join(num)&gt;&gt;&gt; result'1+2+3+4+5' 3.查找字符串：12345678910111213#str.index()和str.find()函数的区别在于，str.find()查找失败会返回-1，不影响程序运行，而str.index()会报错，所以我们一般使用str.find()!=-1或str.find()&gt;-1作为判断条件。&gt;&gt;&gt; name='zhangdaxiang'&gt;&gt;&gt; name.index('a')2&gt;&gt;&gt; name.find('a')2&gt;&gt;&gt; name.find('j')-1&gt;&gt;&gt; name.index('j')Traceback (most recent call last): File "&lt;pyshell#31&gt;", line 1, in &lt;module&gt; name.index('j')ValueError: substring not found 4.是否包含指定字符串：使用in和not in，返回的是True和False。5.字符串中字母大小写转换123456789&gt;&gt;&gt; name='zHangdaXiAng'&gt;&gt;&gt; name.lower() #全部转换为小写'zhangdaxiang'&gt;&gt;&gt; name.upper() #全部转换成大写'ZHANGDAXIANG'&gt;&gt;&gt; name.swapcase() #大小写互换'ZhANGDAxIaNG'&gt;&gt;&gt; name.capitalize() #首字母大写'Zhangdaxiang' 6.将字符串放入中心位置可指定长度以及位置两边字符：123&gt;&gt;&gt; name='zhangdaxiang'&gt;&gt;&gt; name.center(40,'*')'**************zhangdaxiang**************' 7.字符串统计:123&gt;&gt;&gt; name='zhangdaxiang'&gt;&gt;&gt; name.count('a')3 8.字符串的判断函数:123456789S.startswith(prefix[,start[,end]]) #是否以prefix开头 S.endswith(suffix[,start[,end]]) #以suffix结尾 S.isalnum() #是否全是字母和数字，并至少有一个字符 S.isalpha() #是否全是字母，并至少有一个字符 S.isdigit() #是否全是数字，并至少有一个字符 S.isspace() #是否全是空白字符，并至少有一个字符 S.islower() #S中的字母是否全是小写 S.isupper() #S中的字母是否便是大写 S.istitle() #S是否是首字母大写的 列表和元组列表列表(List)是python中的一种有序集合。我们可以很方便地存储数据，并添加删除。定义列表：1names=['zhangdaxiang','张大象','bangbangtang','棒棒糖'] 通过下标访问元素：1234&gt;&gt;&gt; names[2]'bangbangtang'&gt;&gt;&gt; names[-1]'棒棒糖' 如果希望同时访问多个数据，可以使用切片：12345678910111213141516&gt;&gt;&gt; names[1:3] #取下标1至下标4之间的数字，包括1，不包括3['张大象', 'bangbangtang']&gt;&gt;&gt; names[1:-1] #取下标1至-1的值，不包括-1['张大象', 'bangbangtang']&gt;&gt;&gt; names[0:3] ['zhangdaxiang', '张大象', 'bangbangtang']&gt;&gt;&gt; names[:3] #如果是从头开始取，0可以忽略，跟上句效果一样['zhangdaxiang', '张大象', 'bangbangtang']&gt;&gt;&gt; names[2:] #如果想取最后一个，必须不能写-1，只能这么写['bangbangtang', '棒棒糖']&gt;&gt;&gt; names[2:-1] #这样-1就不会被包含了['bangbangtang']&gt;&gt;&gt; names[0::2] #后面的2是代表，每隔一个元素，就取一个['zhangdaxiang', 'bangbangtang']&gt;&gt;&gt; names[::2] #和上句效果一样['zhangdaxiang', 'bangbangtang'] 如果想在列表最后添加一个元素可以使用append():123&gt;&gt;&gt; names.append('biaobiao')&gt;&gt;&gt; names['zhangdaxiang', '张大象', 'bangbangtang', '棒棒糖', 'biaobiao'] 使用insert()可以在指定位置插入元素：123&gt;&gt;&gt; names.insert(1,'飙飙')&gt;&gt;&gt; names['zhangdaxiang', '飙飙', '张大象', 'bangbangtang', '棒棒糖', 'biaobiao'] 要删除末尾元素可以使用pop(),删除指定位置元素使用pop(i):12345678&gt;&gt;&gt; names.pop()'biaobiao'&gt;&gt;&gt; names['zhangdaxiang', '飙飙', '张大象', 'bangbangtang', '棒棒糖']&gt;&gt;&gt; names.pop(1)'飙飙'&gt;&gt;&gt; names['zhangdaxiang', '张大象', 'bangbangtang', '棒棒糖'] 这样又回到了初始状态。也可以使用del和remove()来删除：123456&gt;&gt;&gt; del names[2]&gt;&gt;&gt; names['zhangdaxiang', '张大象', '棒棒糖']&gt;&gt;&gt; names.remove('棒棒糖') #删除指定元素&gt;&gt;&gt; names['zhangdaxiang', '张大象'] 也可以同时添加多个元素,使用extend():123&gt;&gt;&gt; names.extend(['bangbangtang','棒棒糖'])&gt;&gt;&gt; names['zhangdaxiang', '张大象', 'bangbangtang', '棒棒糖'] 使用index()可以查看元素所在下标：12&gt;&gt;&gt; names.index('张大象')1 使用count()可以实现计数功能：12345&gt;&gt;&gt; names.append('张大象')&gt;&gt;&gt; names['zhangdaxiang', '张大象', 'bangbangtang', '棒棒糖', '张大象']&gt;&gt;&gt; names.count('张大象')2 翻转和排序：12345678910111213&gt;&gt;&gt; names=['zhangdaxiang', '张大象', 'bangbangtang', '棒棒糖', 1, 2, 3]&gt;&gt;&gt; names.sort() #排序Traceback (most recent call last): File "&lt;pyshell#37&gt;", line 1, in &lt;module&gt; names.sort()TypeError: unorderable types: int() &lt; str() #3.0里不同数据类型不能放在一起排序了&gt;&gt;&gt; names=['zhangdaxiang', '张大象', 'bangbangtang', '棒棒糖', '1', '2', '3']&gt;&gt;&gt; names.sort()&gt;&gt;&gt; names['1', '2', '3', 'bangbangtang', 'zhangdaxiang', '张大象', '棒棒糖']&gt;&gt;&gt; names.reverse()#翻转&gt;&gt;&gt; names['棒棒糖', '张大象', 'zhangdaxiang', 'bangbangtang', '3', '2', '1'] 元组元组(tuple)和list是非常相似的，也是一个有序的集合。但是元组有一个特性，那就是不可更改。这样，tuple具有更高的安全性，所以我们如果在可以用tuple代替list的地方，就劲量使用tuple。定义一个tuple:123&gt;&gt;&gt; names = ('zhangdaxiang','张大象')&gt;&gt;&gt; names('zhangdaxiang', '张大象') 定义一个空的tuple:123&gt;&gt;&gt; names=()&gt;&gt;&gt; names() 定义一个单一元素的tuple:123&gt;&gt;&gt; names=('zhangdaxiang',)&gt;&gt;&gt; names('zhangdaxiang',) 如果使用names=(&#39;zhangdaxiang&#39;),虽然不会报错，但是实际上python所做的操作是将&#39;zhangdaxiang&#39;这个字符串赋值给了names变量，并不是tuple。 字典和集合字典python内置了字典(dict)，就是一种键值(key-value)对应的存储模式。这个和列表相比是无序的，但是和字典一样，非常便于查找，有很快的查找速度。定义字典：123&gt;&gt;&gt; names=&#123;'name':'zhangdaxiang','age':'25','city':'hangzhou'&#125;&gt;&gt;&gt; names&#123;'name': 'zhangdaxiang', 'city': 'hangzhou', 'age': '25'&#125; 其中要注意的两点是：无序，key值是唯一的。我们要额外增加一个元素的话很简单：123&gt;&gt;&gt; names['friend']='bangbangtang'&gt;&gt;&gt; names&#123;'name': 'zhangdaxiang', 'city': 'hangzhou', 'friend': 'bangbangtang', 'age': '25'&#125; 修改元素：123&gt;&gt;&gt; names['friend'] = '飙飙'&gt;&gt;&gt; names&#123;'name': 'zhangdaxiang', 'city': 'hangzhou', 'friend': '飙飙', 'age': '25'&#125; 删除操作的话和list也非常类似：1234567891011&gt;&gt;&gt; names.pop('age')#最常用的删除方式'25'&gt;&gt;&gt; names&#123;'name': 'zhangdaxiang', 'city': 'hangzhou', 'friend': '飙飙'&#125;&gt;&gt;&gt; del names['friend']&gt;&gt;&gt; names&#123;'name': 'zhangdaxiang', 'city': 'hangzhou'&#125;&gt;&gt;&gt; names.popitem()#随机删除('name', 'zhangdaxiang')&gt;&gt;&gt; names&#123;'city': 'hangzhou&#125; 查找元素：123456789101112131415&gt;&gt;&gt; names=&#123;'name': 'zhangdaxiang', 'city': 'hangzhou', 'friend': '飙飙', 'age': '25'&#125;&gt;&gt;&gt; 'name' in names #标准用法True&gt;&gt;&gt; names.get('city') #获取'hangzhou'#如果key不存在，可以返回None，或者自己指定的value&gt;&gt;&gt; name.get('age1',-1)-1&gt;&gt;&gt; names['age'] #同上，但是如果key不存在会报错，如下'25'&gt;&gt;&gt; name['age1'] #key不存在Traceback (most recent call last): File "&lt;pyshell#18&gt;", line 1, in &lt;module&gt; name['age1']NameError: name 'name' is not defined 多级字典嵌套已经操作：12345678910111213141516171819av_catalog = &#123; "欧美":&#123; "www.youporn.com": ["很多免费的,世界最大的","质量一般"], "www.pornhub.com": ["很多免费的,也很大","质量比yourporn高点"], "letmedothistoyou.com": ["多是自拍,高质量图片很多","资源不多,更新慢"], "x-art.com":["质量很高,真的很高","全部收费,屌比请绕过"] &#125;, "日韩":&#123; "tokyo-hot":["质量怎样不清楚,个人已经不喜欢日韩范了","听说是收费的"] &#125;, "大陆":&#123; "1024":["全部免费,真好,好人一生平安","服务器在国外,慢"] &#125;&#125;av_catalog["大陆"]["1024"][1] += ",可以用爬虫爬下来"print(av_catalog["大陆"]["1024"])#ouput ['全部免费,真好,好人一生平安', '服务器在国外,慢,可以用爬虫爬下来'] 我们还需要了解的是dict的其他操作：1234567891011121314151617181920212223242526&gt;&gt;&gt; names=&#123;'name': 'zhangdaxiang', 'city': 'hangzhou', 'friend': '飙飙', 'age': '25'&#125;#values&gt;&gt;&gt; names.values()dict_values(['zhangdaxiang', 'hangzhou', '飙飙', '25'])#keys&gt;&gt;&gt; names.keys()dict_keys(['name', 'city', 'friend', 'age'])#item&gt;&gt;&gt; names.items()dict_items([('name', 'zhangdaxiang'), ('city', 'hangzhou'), ('friend', '飙飙'), ('age', '25')])#setdefault&gt;&gt;&gt; names.setdefault('school','JL')'JL'&gt;&gt;&gt; names&#123;'name': 'zhangdaxiang', 'city': 'hangzhou', 'friend': '飙飙', 'age': '25', 'school': 'JL'&#125;&gt;&gt;&gt; names.setdefault('friend','bangbangtang')'飙飙'&gt;&gt;&gt; names&#123;'name': 'zhangdaxiang', 'city': 'hangzhou', 'friend': '飙飙', 'age': '25', 'school': 'JL'&#125;#update&gt;&gt;&gt; names=&#123;'name': 'zhangdaxiang', 'city': 'hangzhou', 'friend': '飙飙'&#125;&gt;&gt;&gt; updates=&#123;'name':'张大象','age':'25'&#125;&gt;&gt;&gt; names.update(updates)&gt;&gt;&gt; names&#123;'name': '张大象', 'city': 'hangzhou', 'friend': '飙飙', 'age': '25'&#125; 了解这么多dict的基本操作方法，其实我们平时用到dict的时候，很多都是循环的，这是两种常用的循环方法：123456#方法1for key in names: print(key,names[key])#方法2for key,value in names.items(): print(key,values) 集合集合(set)和dict非常相似，也是一个存储key的集合。但是set不存储value,同时，在set中，key值也是不可重复的。定义set：123&gt;&gt;&gt; names=set(['张大象','飙飙','棒棒糖'])&gt;&gt;&gt; names&#123;'张大象', '飙飙', '棒棒糖'&#125; 要注意的是，这里的三个元素和dict里是一样的，是没有顺序的。如果是重复元素的话，在set中会被直接过滤：123&gt;&gt;&gt; names=set(['张大象','飙飙','棒棒糖','张大象'])&gt;&gt;&gt; names&#123;'张大象', '飙飙', '棒棒糖'&#125; 我们可以使用add(key)来为set添加元素，但是如果添加的是重复项的话，虽然不会报错，但是也不会有任何效果：123456&gt;&gt;&gt; names.add('biaobiao')&gt;&gt;&gt; names&#123;'biaobiao', '张大象', '飙飙', '棒棒糖'&#125;&gt;&gt;&gt; names.add('张大象')&gt;&gt;&gt; names&#123;'biaobiao', '张大象', '飙飙', '棒棒糖'&#125; 然后，使用remove(key)可以删除：123&gt;&gt;&gt; names.remove('biaobiao')&gt;&gt;&gt; names&#123;'张大象', '飙飙', '棒棒糖'&#125; set和dict是非常像的，他们的区别就是有没有放入value。同样值得注意的是，set和dict都不可以放入可变对象，因为不能判定两个可变对象是否相等，这样就不能保证内部的唯一性。 不可变对象上面我们提到了list，dict之类的是可变对象，str字符串是不可变对象。对于可变对象，比如说list进行操作，对象是会改变的：1234&gt;&gt;&gt; names=['张大象','飙飙','棒棒糖']&gt;&gt;&gt; names.sort()&gt;&gt;&gt; names['张大象', '棒棒糖', '飙飙'] 而对于不可变对象,str不论进行什么操作，对象都不会改变：12345&gt;&gt;&gt; name='zhangdaxiang'&gt;&gt;&gt; name.replace('a','A')'zhAngdAxiAng'&gt;&gt;&gt; name'zhangdaxiang' 这样是不会改变的，想要改变的话，要把新生成的值赋给另外一个变量：12345&gt;&gt;&gt; cname=name.replace('a','A')&gt;&gt;&gt; name'zhangdaxiang'&gt;&gt;&gt; cname'zhAngdAxiAng']]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2016%2F11%2F05%2Fhello-world%2F</url>
    <content type="text"><![CDATA[“hello，world！”清晨起床，他站在窗口，神采奕奕地向着这个世界打招呼。世界脸色铁青地看着这个男人。按照它的运行法则，这个人应该早就死了才对。可是无论它用尽什么办法，第二天朝阳升起来的时候，他都依然活着，慢腾腾地提起裤子，带上眼镜，仿佛对这个世界最大恶意的嘲讽。“exciting！”男人嘻嘻笑着，握紧拳头在胸前轻轻一挥，仿佛在玩着一个最有趣的游戏。]]></content>
  </entry>
</search>
