<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>大象无形</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-12-27T03:09:35.011Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>张大象</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>html</title>
    <link href="http://yoursite.com/2018/06/13/html/"/>
    <id>http://yoursite.com/2018/06/13/html/</id>
    <published>2018-06-13T14:58:22.000Z</published>
    <updated>2018-12-27T03:09:35.011Z</updated>
    
    <content type="html"><![CDATA[<h3 id="html结构"><a href="#html结构" class="headerlink" title="html结构"></a>html结构</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--告诉浏览器使用什么样的html或者xhtml来解析html文档--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="comment">&lt;!--文档的开始结束标签，说明这是一个html文档--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">html</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!--出现在文档的开头部门。标签内的东西不会在浏览器的文档窗口显示--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">head</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!--定义网页标题，在浏览器标题栏显示--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>xxx<span class="tag">&lt;<span class="name">title</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--网页主体部分--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="常用标签"><a href="#常用标签" class="headerlink" title="常用标签"></a>常用标签</h3><h4 id="lt-DOCTYPE-gt-标签"><a href="#lt-DOCTYPE-gt-标签" class="headerlink" title="&lt;!DOCTYPE&gt;标签"></a>&lt;!DOCTYPE&gt;标签</h4><p>此标签可告知浏览器文档使用哪种 HTML 或 XHTML 规范。</p><ul><li>BackCompat：怪异模式，浏览器使用自己的怪异模式解析渲染页面。</li><li>CSS1Compat：标准模式，浏览器使用W3C的标准解析渲染页面。<h4 id="内常用标签"><a href="#内常用标签" class="headerlink" title="内常用标签"></a><head><meta name="generator" content="Hexo 3.8.0">内常用标签</head></h4><h5 id="标签"><a href="#标签" class="headerlink" title="标签"></a><meta>标签</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--&lt;meta&gt;标签共有两个属性，分别是name和http-equiv属性，两个属性具有不同的属性值--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--name属性主要用于描述网页，对应的属性值是content,content中的值是便于搜索引擎机器人查找和分类信息用的--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"kewwords"</span> <span class="attr">content</span>=<span class="string">"meta属性，meta参数值"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"description"</span> <span class="attr">content</span>=<span class="string">"description对应的值是搜索引擎描述用的"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--http-equiv标签,相当于http的文件头作用，它可以向浏览器传回一些有用的信息，以帮助正确地显示网页内容--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--即2秒后跳转到百度--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Refresh"</span> <span class="attr">content</span>=<span class="string">"2;URL=https://www.baidu.com"</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!--编码格式--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"content-Type"</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="非标签"><a href="#非标签" class="headerlink" title="非标签"></a>非<meta>标签</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>zhangdaxiang<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--即网页的icon小图标--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"icon"</span> <span class="attr">href</span>=<span class="string">"http://xxxxx.ico"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--引入css和js--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"css.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scrip</span> <span class="attr">src</span>=<span class="string">"js.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">scrip</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="内常用标签-1"><a href="#内常用标签-1" class="headerlink" title="内常用标签"></a><body>内常用标签</body></h4><h5 id="块级标签和内联标签"><a href="#块级标签和内联标签" class="headerlink" title="块级标签和内联标签"></a>块级标签和内联标签</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--&lt;div&gt;只是一个块级元素，并无实际的意义。主要通过CSS样式为其赋予不同的表现--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--&lt;span&gt;表示了内联行(行内元素),并无实际的意义,主要通过CSS样式为其赋予不同的表现--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p>所谓块元素，是以另起一行开始渲染的元素，行内元素则不需另起一行。如果单独在网页中插入这两个元素，不会对页面产生任何的影响。<br>这两个元素是专门为定义CSS样式而生的。</p><h5 id="其他常用的基本标签"><a href="#其他常用的基本标签" class="headerlink" title="其他常用的基本标签"></a>其他常用的基本标签</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--n的取值范围是1-6；从大到小，分别表示不同大小标题--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--段落标签，包裹的内容被换行，并且与上下内容有一行空白--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--两个都是加粗标签，&lt;b&gt;标签仿佛已经被弃用了--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span> <span class="tag">&lt;<span class="name">strong</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--为文字加上一条斜线--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">strike</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--文字变成斜体--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">em</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--上角标和下角标--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sup</span>&gt;</span> <span class="tag">&lt;<span class="name">sub</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--换行--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--水平线--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--特殊字符--&gt;</span></span><br><span class="line">&amp;lt;&amp;gt;&amp;quot;&amp;copy;&amp;reg;</span><br><span class="line"><span class="comment">&lt;!--图形标签&lt;img&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"要显示图片的路径"</span> <span class="attr">alt</span>=<span class="string">"图片没有加载成功时的提示"</span> <span class="attr">title</span>=<span class="string">"鼠标悬浮时的提示信息"</span> <span class="attr">width</span>=<span class="string">"图片的宽"</span> <span class="attr">height</span>=<span class="string">"图片的高 (宽高两个属性只用一个会自动等比缩放)"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--超链接标签(锚标签)--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">""</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span>click<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--href属性指定目标网页地址。该地址可以有几种类型：</span></span><br><span class="line"><span class="comment">1.绝对URL - 指向另一个站点（比如 href="http://www.baidu.com）</span></span><br><span class="line"><span class="comment">2.相对URL - 指当前站点中确切的路径（href="index.html"）</span></span><br><span class="line"><span class="comment">3.锚URL - 指向页面中的锚（href="#id"）--&gt;</span></span><br></pre></td></tr></table></figure><h5 id="列表标签"><a href="#列表标签" class="headerlink" title="列表标签"></a>列表标签</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--无序列表 [type属性：disc(实心圆点)(默认)、circle(空心圆圈)、square(实心方块)]--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--有序标签--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--自定义标签--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dt</span>&gt;</span>列表标题<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span>列表项<span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="表格标签"><a href="#表格标签" class="headerlink" title="表格标签"></a>表格标签</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">&lt;tr&gt;: table row</span></span><br><span class="line"><span class="comment">&lt;th&gt;: table head cell</span></span><br><span class="line"><span class="comment">&lt;td&gt;: table data cell</span></span><br><span class="line"><span class="comment">属性：</span></span><br><span class="line"><span class="comment">border: 表格边框；</span></span><br><span class="line"><span class="comment">cellpadding: 内边距；</span></span><br><span class="line"><span class="comment">cellspacing: 外边距；</span></span><br><span class="line"><span class="comment">width: 像素，百分比(最好通过css来设置)</span></span><br><span class="line"><span class="comment">rowspan: 单元格横跨多少行</span></span><br><span class="line"><span class="comment">colspan: 单元格横跨多少列(即合并单元格)</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">th</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">th</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>内容<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>内容<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="表单标签"><a href="#表单标签" class="headerlink" title="表单标签"></a>表单标签<form></form></h4><p>表单用于向服务器传输数据，从而实现用户与Web服务器的交互。<br>表单属性：<br>1.action:表单提交到哪,一般指向服务器端一个程序，比如<a href="https://www.baidu.com/web" target="_blank" rel="noopener">https://www.baidu.com/web</a><br>2.methon:表单提交方式,有post和get,默认就是get<br>表单元素是允许用户在表单中输入内容,比如：文本域(textarea)、下拉列表、单选框(radio-buttons)、复选框(checkboxes)等等。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">input 元素</span><br><span class="line"><span class="comment">&lt;!--input标签的name和values是传输给服务器的键值对--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="文本域"><a href="#文本域" class="headerlink" title="文本域"></a>文本域</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--文本域通过&lt;input type="text"&gt;标签来设定，在表单中输入字母数字等--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"https://www.baidu.com/web"</span> <span class="attr">method</span>=<span class="string">"get"</span>&gt;</span></span><br><span class="line">FirstName:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"firstname"</span>&gt;</span></span><br><span class="line">FamilyName:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"texxt"</span> <span class="attr">name</span>=<span class="string">"familyname"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">rows</span>=<span class="string">"10"</span> <span class="attr">cols</span>=<span class="string">"30"</span>&gt;</span>这是一个文本框<span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="字段密码"><a href="#字段密码" class="headerlink" title="字段密码"></a>字段密码</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--密码字段通过标签&lt;input type="password"&gt; 来定义,密码字段不会明文显示，会以星号或者远点代替--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">Password:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="单选按钮"><a href="#单选按钮" class="headerlink" title="单选按钮"></a>单选按钮</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--&lt;input type="radio"&gt; 标签定义了表单单选框选项,单选按钮的两个name是一致的，values是不一致的--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"sex"</span> <span class="attr">value</span>=<span class="string">"male"</span>&gt;</span>Male<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"sex"</span> <span class="attr">value</span>=<span class="string">"female"</span>&gt;</span>Female</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="复选框"><a href="#复选框" class="headerlink" title="复选框"></a>复选框</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--&lt;input type="checkbox"&gt; 定义了复选框. 需要从若干给定的选择中选取一个或若干选项--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"vehicle"</span> <span class="attr">value</span>=<span class="string">"bike"</span>&gt;</span>I have a bike<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"vehicle"</span> <span class="attr">value</span>=<span class="string">"car"</span>&gt;</span>I have a car</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="提交按钮"><a href="#提交按钮" class="headerlink" title="提交按钮"></a>提交按钮</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--&lt;input type="submit"&gt;定义了提交按钮--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--当用户单击确认按钮时，表单的内容会被传送到另一个文件。表单的动作属性定义了目的文件的文件名。由动作属性定义的这个文件通常会对接收到的输入数据进行相关的处理--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">name</span>=<span class="string">"input"</span> <span class="attr">action</span>=<span class="string">"www.baidu.com"</span> <span class="attr">methon</span>=<span class="string">"get"</span>&gt;</span></span><br><span class="line">username:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">password:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"Submit"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="select下拉标签属性"><a href="#select下拉标签属性" class="headerlink" title="select下拉标签属性"></a>select下拉标签属性</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">"cars"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"volvo"</span>&gt;</span>volvo<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"audi"</span>&gt;</span>audi<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"fiat"</span>&gt;</span>fiat<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"saab"</span>&gt;</span>saab<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;html结构&quot;&gt;&lt;a href=&quot;#html结构&quot; class=&quot;headerlink&quot; title=&quot;html结构&quot;&gt;&lt;/a&gt;html结构&lt;/h3&gt;&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutt
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="html" scheme="http://yoursite.com/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>多线程和多进程</title>
    <link href="http://yoursite.com/2018/06/10/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%A4%9A%E8%BF%9B%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/06/10/多线程和多进程/</id>
    <published>2018-06-10T15:08:13.000Z</published>
    <updated>2018-12-27T02:46:29.803Z</updated>
    
    <content type="html"><![CDATA[<h2 id="threading模块"><a href="#threading模块" class="headerlink" title="threading模块"></a>threading模块</h2><h3 id="线程对象的创建"><a href="#线程对象的创建" class="headerlink" title="线程对象的创建"></a>线程对象的创建</h3><h4 id="Thread类直接创建"><a href="#Thread类直接创建" class="headerlink" title="Thread类直接创建"></a>Thread类直接创建</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countNum</span><span class="params">(n)</span>:</span> <span class="comment">#定义线程需要运行的函数</span></span><br><span class="line">print(<span class="string">"running on number:%s"</span>%n)</span><br><span class="line">time.sleep(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">t1 = threading.Thread(target=countNum,args=(<span class="number">23</span>,))</span><br><span class="line">t2 = threading.Thread(target=countNum,args=(<span class="number">24</span>,))</span><br><span class="line"></span><br><span class="line">t1.start() <span class="comment">#启动进程</span></span><br><span class="line">t2.start() </span><br><span class="line">print(<span class="string">"ending!"</span>)</span><br></pre></td></tr></table></figure><h4 id="Thread类继承式创建"><a href="#Thread类继承式创建" class="headerlink" title="Thread类继承式创建"></a>Thread类继承式创建</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,num)</span>:</span></span><br><span class="line">threading.Thread.__init__(self)</span><br><span class="line">self.num = num</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">print(<span class="string">"running on number:%s"</span>%self.num)</span><br><span class="line">time.sleep(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">t1=MyThread(<span class="number">56</span>) <span class="comment">#即实例化MyThread</span></span><br><span class="line">t2=MyThread(<span class="number">78</span>)</span><br><span class="line"></span><br><span class="line">t1.start() <span class="comment">#即调用实例对象的run()方法</span></span><br><span class="line">t2.start() </span><br><span class="line"></span><br><span class="line">print(<span class="string">"ending!"</span>)</span><br></pre></td></tr></table></figure><h3 id="Thread类的实例方法"><a href="#Thread类的实例方法" class="headerlink" title="Thread类的实例方法"></a>Thread类的实例方法</h3><h4 id="join-和setDaemon-方法"><a href="#join-和setDaemon-方法" class="headerlink" title="join()和setDaemon()方法"></a>join()和setDaemon()方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># join()：在子线程完成运行之前，这个子线程的父线程将一直被阻塞。</span></span><br><span class="line"><span class="comment"># setDaemon(True)：</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">         将线程声明为守护线程，必须在start() 方法调用之前设置，如果不设置为守护线程程序会被无限挂起。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">         当我们在程序运行中，执行一个主线程，如果主线程又创建一个子线程，主线程和子线程 就分兵两路，分别运行，那么当主线程完成</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">         想退出时，会检验子线程是否完成。如果子线程未完成，则主线程会等待子线程完成后再退出。但是有时候我们需要的是只要主线程</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">         完成了，不管子线程是否完成，都要和主线程一起退出，这时就可以 用setDaemon方法啦</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">         </span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> ctime,sleep</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">music</span><span class="params">(name)</span>:</span></span><br><span class="line">print(<span class="string">'&#123;name&#125; Begin listen music &#123;time&#125;'</span>.format(name=name,time=ctime()))</span><br><span class="line">sleep(<span class="number">3</span>)</span><br><span class="line">print(<span class="string">'&#123;name&#125; End listen music &#123;time&#125;'</span>.format(name=name,time=ctime()))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">blog</span><span class="params">(name)</span>:</span></span><br><span class="line">print(<span class="string">'&#123;name&#125; Begin write blog &#123;time&#125;'</span>.format(name=name,time=ctime()))</span><br><span class="line">sleep(<span class="number">5</span>)</span><br><span class="line">print(<span class="string">'&#123;name&#125; End write blog &#123;time&#125;'</span>.format(name=name,time=ctime()))</span><br><span class="line"></span><br><span class="line">t1 = threading.Thread(target=music,args=(<span class="string">'Tony'</span>,))</span><br><span class="line">t2 = threading.Thread(target=blog,args=(<span class="string">'Xiaoming'</span>,))</span><br><span class="line"></span><br><span class="line">thread = []</span><br><span class="line"></span><br><span class="line">thread.append(t1)</span><br><span class="line">thread.append(t2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">t2.setDaemon(<span class="keyword">True</span>) <span class="comment">#设在start()之前，主线程结束,则该守护线程也结束。</span></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> thread:</span><br><span class="line">t.start()</span><br><span class="line"><span class="comment">#t.join() #这里加join()的话,则会在t1线程结束前阻塞主线程，的for循环，t2和主线程不执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#t1.join()#这里加join()，t1线程和t2线程同时执行，主线程阻塞</span></span><br><span class="line"><span class="comment">#t2.join()</span></span><br><span class="line">sleep(<span class="number">2</span>)</span><br><span class="line">print(<span class="string">'End!!'</span>)</span><br></pre></td></tr></table></figure><p>当daemon被设置为True时，如果主线程退出，那么子线程也将跟着退出，反之，子线程将继续运行，直到正常退出。<br>ps.在python3.5自带的IDE里面貌似有BUG，主线程结算之后还是会接着运行声明的守护线程。</p><h4 id="多线程实例其他方法"><a href="#多线程实例其他方法" class="headerlink" title="多线程实例其他方法"></a>多线程实例其他方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Thread实例对象的方法</span></span><br><span class="line"><span class="comment">#isAlive():返回线程是否活动</span></span><br><span class="line"><span class="comment">#getName():返回线程名</span></span><br><span class="line"><span class="comment">#setName():设置线程名称</span></span><br><span class="line"><span class="comment">#threading模块其他方法</span></span><br><span class="line"><span class="comment">#threading.currentThread(): 返回当前的线程变量</span></span><br><span class="line"><span class="comment">#threading.enumerate():返回正在运行的线程list。正在运行包括启动后和结束前，不包括启动前和终止后的线程。</span></span><br><span class="line"><span class="comment">#threading.activeCount():返回正在运行的线程数，和len(threading.enumerate())返回相同值。</span></span><br></pre></td></tr></table></figure><h3 id="GIL"><a href="#GIL" class="headerlink" title="GIL"></a>GIL</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;threading模块&quot;&gt;&lt;a href=&quot;#threading模块&quot; class=&quot;headerlink&quot; title=&quot;threading模块&quot;&gt;&lt;/a&gt;threading模块&lt;/h2&gt;&lt;h3 id=&quot;线程对象的创建&quot;&gt;&lt;a href=&quot;#线程对象的创建&quot; c
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="threading" scheme="http://yoursite.com/tags/threading/"/>
    
      <category term="multiprocessing" scheme="http://yoursite.com/tags/multiprocessing/"/>
    
  </entry>
  
  <entry>
    <title>IO模型</title>
    <link href="http://yoursite.com/2018/06/06/IO%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2018/06/06/IO模型/</id>
    <published>2018-06-06T02:09:22.000Z</published>
    <updated>2018-12-27T02:46:29.798Z</updated>
    
    <content type="html"><![CDATA[<p>对于一个network IO (这里我们以read举例)，它会涉及到两个系统对象，一个是调用这个IO的process (or thread)，另一个就是系统内核(kernel)。当一个read操作发生时，它会经历两个阶段：</p><ul><li>等待数据准备 (Waiting for the data to be ready)<br>*将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)</li></ul><p>以下几种IO Model的区别就是在两个阶段上各有不同的情况。</p><h3 id="Blocking-IO-阻塞IO"><a href="#Blocking-IO-阻塞IO" class="headerlink" title="Blocking IO(阻塞IO)"></a>Blocking IO(阻塞IO)</h3><p>在linux中，默认情况下所有的socket都是blocking，一个典型的读操作流程大概是这样：<br><img src="/img/IO模型/Blocking IO.jpg" alt="Blocking_IO"><br>当用户进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据。对于network io来说，很多时候数据在一开始还没有到达（比如，还没有收到一个完整的UDP包），这个时候kernel就要等待足够的数据到来。而在用户进程这边，整个进程会被阻塞。当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。<br>所以，blocking IO的特点就是在IO执行的两个阶段都被block了。</p><h3 id="non-Blocking-IO-非阻塞IO"><a href="#non-Blocking-IO-非阻塞IO" class="headerlink" title="non-Blocking IO(非阻塞IO)"></a>non-Blocking IO(非阻塞IO)</h3><p>linux下，可以通过设置socket使其变为non-blocking<code>setblocking(False)</code>。当对一个non-blocking socket执行读操作时，流程是这个样子：<br><img src="/img/IO模型/non-Blocking IO.jpg" alt="non-Blocking_IO"><br>从图中可以看出，当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。所以，用户进程其实是需要不断的主动询问kernel数据好了没有。需要注意，拷贝数据整个过程，进程仍然是属于阻塞的状态。<br>即”非阻塞将大的整片时间的阻塞分成N多的小的阻塞, 所以进程不断地有机会 ‘被’ CPU光顾”。</p><h3 id="IO-multiplexing-IO多路复用"><a href="#IO-multiplexing-IO多路复用" class="headerlink" title="IO multiplexing(IO多路复用)"></a>IO multiplexing(IO多路复用)</h3><p>IO多路复用即为<code>select</code>,<code>poll</code>,<code>epoll</code>。好处就在于单个process就可以同时处理多个网络连接的IO。基本原理就是<code>select</code>,<code>poll</code>,<code>epoll</code>会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。它的流程如图：<br><img src="/img/IO模型/IO multiplexing.jpg" alt="IO_multiplexing"><br>当用户进程调用了<code>select</code>，那么整个进程会被block，而同时，kernel会“监视”所有<code>select</code>负责的socket，当任何一个socket中的数据准备好了，<code>select</code>就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。<br>这个图和blocking IO的图其实并没有太大的不同，事实上，还更差一些。因为这里需要使用两个system call (select 和 recvfrom)，而blocking IO只调用了一个system call (recvfrom)。但是，用<code>select</code>的优势在于它可以同时处理多个connection。（多说一句。所以，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。<code>select</code>,<code>poll</code>,<code>epoll</code>的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。）<br>在IO multiplexing Model中，实际中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。只不过process是被<code>select</code>这个函数block，而不是被socket IO给block。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#***********************server.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> select</span><br><span class="line">sk=socket.socket()</span><br><span class="line">sk.bind((<span class="string">"127.0.0.1"</span>,<span class="number">8800</span>))</span><br><span class="line">sk.listen(<span class="number">5</span>)</span><br><span class="line">sk.setblocking(<span class="keyword">False</span>)</span><br><span class="line">inputs=[sk,]</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    r,w,e=select.select(inputs,[],[],<span class="number">5</span>)</span><br><span class="line">    print(len(r))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> obj <span class="keyword">in</span> r:</span><br><span class="line">        <span class="keyword">if</span> obj==sk:</span><br><span class="line">            conn,add=obj.accept()</span><br><span class="line">            print(<span class="string">"conn:"</span>,conn)</span><br><span class="line">            inputs.append(conn)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">            data_byte=obj.recv(<span class="number">1024</span>)</span><br><span class="line">            print(str(data_byte,<span class="string">'utf8'</span>))</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> data_byte:</span><br><span class="line">                inputs.remove(obj)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            inp=input(<span class="string">'回答%s: &gt;&gt;&gt;'</span>%inputs.index(obj))</span><br><span class="line">            obj.sendall(bytes(inp,<span class="string">'utf8'</span>))</span><br><span class="line"></span><br><span class="line">    print(<span class="string">'&gt;&gt;'</span>,r)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#***********************client.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">sk=socket.socket()</span><br><span class="line">sk.connect((<span class="string">'127.0.0.1'</span>,<span class="number">8802</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    inp=input(<span class="string">"&gt;&gt;&gt;&gt;"</span>)   <span class="comment"># how much one night?</span></span><br><span class="line">    sk.sendall(bytes(inp,<span class="string">"utf8"</span>))</span><br><span class="line">    data=sk.recv(<span class="number">1024</span>)</span><br><span class="line">    print(str(data,<span class="string">'utf8'</span>))</span><br></pre></td></tr></table></figure></p><h3 id="Asynchronous-IO-异步IO"><a href="#Asynchronous-IO-异步IO" class="headerlink" title="Asynchronous IO(异步IO)"></a>Asynchronous IO(异步IO)</h3><p>linux下的asynchronous IO其实用得很少。先看一下它的流程：<br><img src="/img/IO模型/Asynchronous IO.jpg" alt="Asynchronous _IO"><br>用户进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。</p><h3 id="IO模型比较"><a href="#IO模型比较" class="headerlink" title="IO模型比较"></a>IO模型比较</h3><p><img src="/img/IO模型/compare IO models.jpg" alt="compare IO models"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于一个network IO (这里我们以read举例)，它会涉及到两个系统对象，一个是调用这个IO的process (or thread)，另一个就是系统内核(kernel)。当一个read操作发生时，它会经历两个阶段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;等待数据准备 (Wait
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="IO" scheme="http://yoursite.com/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>Centos grub修改密码</title>
    <link href="http://yoursite.com/2018/04/02/Centos-grub%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81/"/>
    <id>http://yoursite.com/2018/04/02/Centos-grub修改密码/</id>
    <published>2018-04-02T07:24:54.000Z</published>
    <updated>2018-12-27T02:46:29.797Z</updated>
    
    <content type="html"><![CDATA[<p>在<code>linux</code>中，<code>grub</code>是用来驱动系统内核的。有时候，我们也可以通过<code>grub</code>来修改<code>root</code>密码，只要在内核启动方式选择单用户启动就可以了（init 1）。<br>为了保险起见，我们可以设置<code>grub</code>密码，来防止别人通过以上途径修改<code>root</code>密码。更改<code>grub</code>配置文件,<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/grub.conf</span><br></pre></td></tr></table></figure></p><p>找到文件里面的<code>title</code>关键字，在<code>title</code>上面加个<code>password</code>就可以加密<code>grub</code>，在下面价格<code>password</code>就可以在进入系统的时候加密。<br>如果我们需要<code>md5</code>加密这些密码的话，可以使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grub-md5-crypt</span><br></pre></td></tr></table></figure></p><p>输出一串加密后的字符串，复制，然后在<code>/etc/grub.conf</code>中就是<br><code>password --md5 字符串</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在&lt;code&gt;linux&lt;/code&gt;中，&lt;code&gt;grub&lt;/code&gt;是用来驱动系统内核的。有时候，我们也可以通过&lt;code&gt;grub&lt;/code&gt;来修改&lt;code&gt;root&lt;/code&gt;密码，只要在内核启动方式选择单用户启动就可以了（init 1）。&lt;br&gt;为了保险
      
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>sqlserver分区表</title>
    <link href="http://yoursite.com/2018/01/15/sqlserver%E5%88%86%E5%8C%BA%E8%A1%A8/"/>
    <id>http://yoursite.com/2018/01/15/sqlserver分区表/</id>
    <published>2018-01-15T06:36:24.000Z</published>
    <updated>2018-12-27T02:46:29.803Z</updated>
    
    <content type="html"><![CDATA[<h3 id="分区表的定义"><a href="#分区表的定义" class="headerlink" title="分区表的定义"></a>分区表的定义</h3><p>一般情况下，我们建立一个数据库的表，表里面的数据都会放在同一个文件里面。但是如果是分区表的话，表数据会根据我们自定义的规则给存放到不同的文件中。这样其实就相当于将一个大的数据文件拆分为多个小文件，这样文件的大小随着拆分而减小，可以得到硬件系统方面的假期。而且可以将这些小文件放在不同磁盘下的多个CPU来进行处理，大大提升数据的性能。<br>概括一下，分区表的优势主要体现在：<ul><li>提供性能：这个是大多人数分区的目的，把一个表分部到不同的硬盘或其他存储介质中，会大大提升查询速度。</li><li>提高稳定性：当一个分区出了问题，不会影响其他分区，仅仅是当前坏的分区不可用。</li><li>便于管理：把一个大表分成若干个小表，则备份和恢复的时候不再需要备份整个表，可以单独备份分区。</li><li>存档：将一些不太常用的数据，单独存放。如：将1年前的数据记录分到一个专门的存档服务器存放。</li></ul>但是这样仅限于大数据量的数据表，对于小数据量的表。这样还会产生不必要的开销，得不偿失。</p><h3 id="创建文件组"><a href="#创建文件组" class="headerlink" title="创建文件组"></a>创建文件组</h3><p>分区是要把一个表数据拆分为若干子集合，也就是把把一个数据文件拆分到多个数据文件中，然而这些文件的存放可以依托一个文件组或者多个文件组，由于多个文件组可以提高数据库的访问并发量，还可以把不同的分区配置到不同的磁盘中提高效率，所以创建时建议分区跟文件组个数相同。</p><h4 id="创建文件组-1"><a href="#创建文件组-1" class="headerlink" title="创建文件组"></a>创建文件组</h4><p>创建文件组的语法如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">DATABASE</span> &lt;数据库名&gt; <span class="keyword">ADD</span> filegroup &lt;文件组名&gt;</span><br></pre></td></tr></table></figure></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">---创建数据库文件组</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> testDB <span class="keyword">add</span> filegroup ByBirGroup1</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> testDB <span class="keyword">add</span> filegroup ByBirGroup2</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> testDB <span class="keyword">add</span> filegroup ByBirGroup3</span><br></pre></td></tr></table></figure><h4 id="创建数据文件到文件组里面"><a href="#创建数据文件到文件组里面" class="headerlink" title="创建数据文件到文件组里面"></a>创建数据文件到文件组里面</h4><p>创建数据文件到文件组的语法如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">DATABASE</span> &lt;数据库名称&gt; <span class="keyword">ADD</span> <span class="keyword">FILE</span> &lt;数据标识&gt; <span class="keyword">TO</span> FILEGROUP &lt;文件组名称&gt;</span><br><span class="line"><span class="comment">---&lt;数据标识&gt; （name:文件名，fliename:物理路径文件名，size:文件初始大小kb/mb/gb/tb，filegrowth:文件自动增量kb/mb/gb/tb/%,maxsize:文件可以增加到的最大大小kb/mb/gb/tb/unlimited）</span></span><br></pre></td></tr></table></figure></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> testDB <span class="keyword">add</span> <span class="keyword">file</span> </span><br><span class="line">(<span class="keyword">name</span>=N<span class="string">'ByBirGroup1'</span>,filename=N<span class="string">'D:\Program Files\Microsoft SQL Server\MSSQL11.MSSQLSERVER\MSSQL\DATA\testDB1.mdf'</span>,<span class="keyword">size</span>=<span class="number">5</span>Mb,filegrowth=<span class="number">1</span>mb)</span><br><span class="line"><span class="keyword">to</span> filegroup ByBirGroup1</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> testDB <span class="keyword">add</span> <span class="keyword">file</span> </span><br><span class="line">(<span class="keyword">name</span>=N<span class="string">'ByBirGroup2'</span>,filename=N<span class="string">'D:\Program Files\Microsoft SQL Server\MSSQL11.MSSQLSERVER\MSSQL\DATA\testDB2.mdf'</span>,<span class="keyword">size</span>=<span class="number">5</span>Mb,filegrowth=<span class="number">1</span>mb)</span><br><span class="line"><span class="keyword">to</span> filegroup ByBirGroup2</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> testDB <span class="keyword">add</span> <span class="keyword">file</span> </span><br><span class="line">(<span class="keyword">name</span>=N<span class="string">'ByBirGroup3'</span>,filename=N<span class="string">'D:\Program Files\Microsoft SQL Server\MSSQL11.MSSQLSERVER\MSSQL\DATA\testDB3.mdf'</span>,<span class="keyword">size</span>=<span class="number">5</span>Mb,filegrowth=<span class="number">1</span>mb)</span><br><span class="line"><span class="keyword">to</span> filegroup ByBirGroup3</span><br></pre></td></tr></table></figure><p>查询当前的所有文件组<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span>,type_desc,physical_name,state_desc,<span class="keyword">size</span>,growth</span><br><span class="line"><span class="keyword">FROM</span> sys.database_files</span><br></pre></td></tr></table></figure></p><p>可以看到，成了。<br><img src="/img/sqlserver_分区表/sqlserver_fenqu6.jpg" alt="fenqu6" width="800" height="800"></p><h3 id="分区表的操作步骤"><a href="#分区表的操作步骤" class="headerlink" title="分区表的操作步骤"></a>分区表的操作步骤</h3><p>分区表分为三部分：分区函数，分区框架和分区表。他们之间的关系是：<strong>分区表依赖于分区构架，分区构架又依赖分区函数。</strong>所以定义分区表的顺序是定义分区函数-&gt;定义分区构架-&gt;定义分区表。我们实际操作的时候，需要有一张需要分区的表：<br><img src="/img/sqlserver_分区表/sqlserver_fenqu1.jpg" alt="fenqu1" width="400" hight="400"></p><h4 id="定义分区函数"><a href="#定义分区函数" class="headerlink" title="定义分区函数"></a>定义分区函数</h4><p>分区函数的作用是判断一行数据属于哪一个分区，通过在分区函数中设定边界值来使得根据行中特殊列的值来确定分区，比如上面的分区表：<br>假如选择的是<code>id</code>列，那就是<code>int</code>类型，那么分区可以指定为1-100w是一个分区，100-200w是一个分区。<br>假如选择的是<code>birthday</code>列，那就是<code>datetime</code>类型可以指定为<code>2014-01-01</code>至<code>2017-01-01</code>一个分区，<code>2017-01-01</code>以后一个分区。放一张<code>CareySon</code>大佬的图，方便理解。<br><img src="/img/sqlserver_分区表/sqlserver_fenqu2.jpg" alt="" fenqu2="" width="400" hight="600"><br>定义分区函数的语法如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PARTITION</span> <span class="keyword">FUNCTION</span> partition_function_name ( input_parameter_type )</span><br><span class="line"><span class="keyword">AS</span> <span class="keyword">RANGE</span> [ <span class="keyword">LEFT</span> | <span class="keyword">RIGHT</span> ] </span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">VALUES</span> ( [ boundary_value [ ,...n ] ] ) </span><br><span class="line">[ ; ]</span><br></pre></td></tr></table></figure></p><p>可以看到，定义函数的语法中，并没有涉及到具体的表，这是因为分区函数并不和具体的表相关联。其中的<code>Range left</code>和<code>right</code>决定这个边界值应该归属于左边还是右边。<br><img src="/img/sqlserver_分区表/sqlserver_fenqu3.jpg" alt="fenqu3" width="400" height="600"><br>创建分区函数:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">---创建分区函数</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PARTITION</span> <span class="keyword">FUNCTION</span> Fun_test_zyz_birthday(DATETIME)</span><br><span class="line"><span class="keyword">AS</span> <span class="keyword">RANGE</span> <span class="keyword">LEFT</span> </span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">VALUES</span>(<span class="string">'2004-01-01'</span>,<span class="string">'2007-01-01'</span>)</span><br><span class="line"><span class="comment">--查看分区函数是否创建成功</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> sys.partition_functions</span><br></pre></td></tr></table></figure></p><p>查询结果如图所示：<br><img src="/img/sqlserver_分区表/sqlserver_fenqu4.jpg" alt="fenqu4" width="1000" height="1000"></p><h4 id="定义分区框架"><a href="#定义分区框架" class="headerlink" title="定义分区框架"></a>定义分区框架</h4><p>分区函数决定了数据该分到哪个分区，而分配每个分区属于哪个文件组，则需要依赖分区框架。<br>定义分区框架的语法如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PARTITION</span> SCHEME partition_scheme_name</span><br><span class="line"><span class="keyword">AS</span> <span class="keyword">PARTITION</span> partition_function_name</span><br><span class="line">[ ALL ] <span class="keyword">TO</span> ( &#123; file_group_name | [ PRIMARY ] &#125; [ ,...n ] )</span><br><span class="line">[ ; ]</span><br></pre></td></tr></table></figure></p><p><img src="/img/sqlserver_分区表/sqlserver_fenqu5.jpg" alt="fenqu5" width="400" height="600"><br>根据之前的分区函数和文件组，可以得到：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--基于之前的分区函数创建分区构架schema</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PARTITION</span> SCHEME SchemaForParirion</span><br><span class="line"><span class="keyword">AS</span> <span class="keyword">PARTITION</span> Fun_test_zyz_birthday    <span class="comment">--这个是之前创建的分区函数</span></span><br><span class="line"><span class="keyword">TO</span>(ByBirGroup1,ByBirGroup2,ByBirGroup3)   <span class="comment">--FileGroup1是自己添加的文件组，因为有两个分界值，3个分区，所以要指定3个文件组，也可以使用ALL所谓的分区指向一个文件组</span></span><br><span class="line"><span class="comment">--查看已创建的分区构架</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> sys.partition_schemes</span><br></pre></td></tr></table></figure></p><h3 id="定义分区表"><a href="#定义分区表" class="headerlink" title="定义分区表"></a>定义分区表</h3><p>需要知道一点的是，一个表在创建的时候就要决定是否是分区表了，虽然大多数情况下，我们是因为一个表的数据过大才决定分区的。<br>所以，在创建表的时候确立为分区表<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [dbo].[test_zyz](</span><br><span class="line">[<span class="keyword">id</span>] [<span class="built_in">INT</span>]  <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">[<span class="keyword">name</span>] [<span class="built_in">VARCHAR</span>](<span class="number">50</span>) <span class="literal">NULL</span>,</span><br><span class="line">[age] [<span class="built_in">INT</span>] <span class="literal">NULL</span>,</span><br><span class="line">[birthday] [DATETIME]  PRIMARY <span class="keyword">KEY</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">ON</span> SchemaForParirion([birthday]) <span class="comment">--SchemaForPartition是刚刚定义的分区架构，括号内为指定的分区列</span></span><br></pre></td></tr></table></figure></p><p>插入测试数据<br><img src="/img/sqlserver_分区表/sqlserver_fenqu7.jpg" alt="fenqu7" width="400" height="400"><br>可以通过下列语句来查看分区状况：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">convert</span>(<span class="built_in">varchar</span>(<span class="number">50</span>), ps.name) <span class="keyword">as</span> partition_scheme,</span><br><span class="line">p.partition_number, </span><br><span class="line"><span class="keyword">convert</span>(<span class="built_in">varchar</span>(<span class="number">20</span>), ds2.name) <span class="keyword">as</span> filegroup, </span><br><span class="line"><span class="keyword">convert</span>(<span class="built_in">varchar</span>(<span class="number">20</span>), <span class="keyword">isnull</span>(v.value, <span class="string">''</span>), <span class="number">120</span>) <span class="keyword">as</span> range_boundary, </span><br><span class="line"><span class="keyword">str</span>(p.rows, <span class="number">9</span>) <span class="keyword">as</span> <span class="keyword">rows</span></span><br><span class="line"><span class="keyword">from</span> sys.indexes i </span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> sys.partition_schemes ps <span class="keyword">on</span> i.data_space_id = ps.data_space_id </span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> sys.destination_data_spaces dds</span><br><span class="line"><span class="keyword">on</span> ps.data_space_id = dds.partition_scheme_id </span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> sys.data_spaces ds2 <span class="keyword">on</span> dds.data_space_id = ds2.data_space_id </span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> sys.partitions p <span class="keyword">on</span> dds.destination_id = p.partition_number</span><br><span class="line"><span class="keyword">and</span> p.object_id = i.object_id <span class="keyword">and</span> p.index_id = i.index_id </span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> sys.partition_functions pf <span class="keyword">on</span> ps.function_id = pf.function_id </span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> sys.Partition_Range_values v <span class="keyword">on</span> pf.function_id = v.function_id</span><br><span class="line"><span class="keyword">and</span> v.boundary_id = p.partition_number - pf.boundary_value_on_right </span><br><span class="line"><span class="keyword">WHERE</span> i.object_id = object_id(<span class="string">'test_zyz'</span>)    <span class="comment">--此处是表名</span></span><br><span class="line"><span class="keyword">and</span> i.index_id <span class="keyword">in</span> (<span class="number">0</span>, <span class="number">1</span>) </span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> p.partition_number</span><br></pre></td></tr></table></figure></p><p>可以看到各分区的具体数量<br><img src="/img/sqlserver_分区表/sqlserver_fenqu8.jpg" alt="fenqu8" width="600" height="600"><br>查询某个分区的语法是：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> test_zyz</span><br><span class="line"><span class="keyword">WHERE</span> $partition.Fun_test_zyz_birthday(birthday)=<span class="number">2</span> <span class="comment">---$partition.分区函数(分区列)</span></span><br></pre></td></tr></table></figure></p><h3 id="分区表的分割与合并"><a href="#分区表的分割与合并" class="headerlink" title="分区表的分割与合并"></a>分区表的分割与合并</h3><h3 id="分区表的分割"><a href="#分区表的分割" class="headerlink" title="分区表的分割"></a>分区表的分割</h3><p>分区表的分割就相当于新建一个分区，将原有的分区内需要被分割的内容插入到新建的分区中，然后删除这部分内容。<br>新加入一个分割点：<code>2009-01-01</code>。如图所示：<br><img src="/img/sqlserver_分区表/sqlserver_fenqu9.jpg" alt="fenqu9" width="400" height="600"><br>对于上图的操作，分割时候，被分割的分区3内的内容复制到分区4，然后删除分区3中对于的部分。<strong>但是这种操作非常消耗IO，并且会在分割的过程中锁定分区3的内容，而且这个操作所产生的日志是被转移数据的4倍。</strong>所以最后在建表的时候就考虑到以后的分割点。<br>分区分割分为两个步骤：<ul><li>首先要告诉SQL Server新建立的分区放到哪个文件组。</li><li>建立新的分割点。</li></ul>现在增加一条测试数据：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_zyz(<span class="keyword">name</span>,age,birthday)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">'xiaoming5'</span>,<span class="number">20</span>,<span class="string">'2011-01-01 00:00:00.000'</span>)</span><br></pre></td></tr></table></figure></p><p>执行长查询，得到：<br><img src="/img/sqlserver_分区表/sqlserver_fenqu10.jpg" alt="fenqu10"><br>接下来可以执行分割操作：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--分割出来的分区数据存在在哪个文件组</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">PARTITION</span> SCHEME SchemaForParirion <span class="keyword">NEXT</span> USED <span class="string">'ByBirGroup2'</span></span><br><span class="line"><span class="comment">--添加分割点</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">PARTITION</span> <span class="keyword">FUNCTION</span> Fun_test_zyz_birthday()</span><br><span class="line"><span class="keyword">SPLIT</span> <span class="keyword">RANGE</span>(<span class="string">'2009-01-01'</span>)</span><br></pre></td></tr></table></figure></p><p>再次查询可以得到：<br><img src="/img/sqlserver_分区表/sqlserver_fenqu11.jpg" alt="fenqu11"></p><h4 id="分区表的合并"><a href="#分区表的合并" class="headerlink" title="分区表的合并"></a>分区表的合并</h4><p>分区表的合并可以看做是分割的逆操作，合并时必须提供分割点，且分割点存在，不然会报错：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--提供分割点，合并分区</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">PARTITION</span> <span class="keyword">FUNCTION</span> Fun_test_zyz_birthday()</span><br><span class="line"><span class="keyword">MERGE</span> <span class="keyword">RANGE</span>(<span class="string">'2009-01-01'</span>)</span><br></pre></td></tr></table></figure></p><h3 id="分区表数据迁移"><a href="#分区表数据迁移" class="headerlink" title="分区表数据迁移"></a>分区表数据迁移</h3><h4 id="分区表一个分区的数据迁移到普通表"><a href="#分区表一个分区的数据迁移到普通表" class="headerlink" title="分区表一个分区的数据迁移到普通表"></a>分区表一个分区的数据迁移到普通表</h4><p>从分区到普通表，需要满足以下条件：<ul><li>普通表必须建立在分区表切换出的分区所在的文件组上。</li><li>普通表的表结构和分区表一致。</li><li>普通表上的索引要和分区表一致，包括聚集索引和非聚集索引。</li><li>普通表必须是空表。</li></ul><br>首先，创建和<code>test_zyz</code>结构相同的普通表：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [dbo].[test_zyz2](</span><br><span class="line">[<span class="keyword">id</span>] [<span class="built_in">INT</span>] <span class="keyword">IDENTITY</span>(<span class="number">1</span>,<span class="number">1</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">[<span class="keyword">name</span>] [<span class="built_in">VARCHAR</span>](<span class="number">50</span>) <span class="literal">NULL</span>,</span><br><span class="line">[age] [<span class="built_in">INT</span>] <span class="literal">NULL</span>,</span><br><span class="line">[birthday] [DATETIME] <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"> <span class="keyword">CONSTRAINT</span> [PK_test_zyz2] PRIMARY <span class="keyword">KEY</span> NONCLUSTERED </span><br><span class="line">(</span><br><span class="line">[birthday] <span class="keyword">ASC</span></span><br><span class="line">)<span class="keyword">WITH</span> (PAD_INDEX = <span class="keyword">OFF</span>, STATISTICS_NORECOMPUTE = <span class="keyword">OFF</span>, IGNORE_DUP_KEY = <span class="keyword">OFF</span>, ALLOW_ROW_LOCKS = <span class="keyword">ON</span>, ALLOW_PAGE_LOCKS = <span class="keyword">ON</span>) <span class="keyword">ON</span> [ByBirGroup2]</span><br><span class="line">) <span class="keyword">ON</span> [ByBirGroup2] <span class="comment">---表格建在分区2上，这样我们就能迁移分区2的数据</span></span><br></pre></td></tr></table></figure></p><p>然后从分区表中复制数据到普通表：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--将test_zyz分区表中的第2分区数据复制到普通表中</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> testdb..test_zyz <span class="keyword">switch</span> <span class="keyword">partition</span> <span class="number">2</span> <span class="keyword">to</span> testdb..test_zyz2</span><br></pre></td></tr></table></figure></p><p>可以看到，分区2的数据已经没有了,迁移到了<code>test_zyz2</code>表中<br><img src="/img/sqlserver_分区表/sqlserver_fenqu12.jpg" alt="fenqu12"><br>但是要注意的是，从普通表<code>test_zyz2</code>中还原数据到<code>test_zyz</code>这个分区表分区2的时候，还要新增另外一个条件：普通表必须加上和分区数据范围一致的 check 约束条件。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> testdb..test_zyz2 <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> CK_SalesOrders_Birthday</span><br><span class="line"><span class="keyword">CHECK</span>(birthday&gt;<span class="string">'2004-01-01'</span> <span class="keyword">AND</span> birthday&lt;=<span class="string">'2007-01-01'</span>) <span class="comment">---之前分区函数是left，所以应该是&lt;='2007-01-01'</span></span><br></pre></td></tr></table></figure></p><p>成功建立<code>check</code>约束条件以后，就可以还原数据了：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--将普通表中的数据复制到test_zyz分区表中的第2分区</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> testdb..test_zyz2 <span class="keyword">switch</span> <span class="keyword">to</span> testdb..test_zyz <span class="keyword">partition</span> <span class="number">2</span></span><br></pre></td></tr></table></figure></p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>分区表分区切换并没有真正去移动数据,而是<code>SQL Server</code>在系统底层改变了表的元数据。因此分区表分区切换是高效、快速、灵活的。利用分区表的分区切换功能，我们可以快速加载数据到分区表、卸载分区数据到普通表，然后<code>TRUNCATE</code>普通表，以实现快速删除分区表数据，也可以快速迁移分区到历史表。<br>本文学习自<a href="http://www.cnblogs.com/CareySon/archive/2011/12/30/2307766.html" target="_blank" rel="noopener">理解SQL SERVER中的分区表</a>，感谢宋沄剑大大。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;分区表的定义&quot;&gt;&lt;a href=&quot;#分区表的定义&quot; class=&quot;headerlink&quot; title=&quot;分区表的定义&quot;&gt;&lt;/a&gt;分区表的定义&lt;/h3&gt;&lt;p&gt;一般情况下，我们建立一个数据库的表，表里面的数据都会放在同一个文件里面。但是如果是分区表的话，表数据会根据我
      
    
    </summary>
    
    
      <category term="sqlserver" scheme="http://yoursite.com/tags/sqlserver/"/>
    
  </entry>
  
  <entry>
    <title>jupyter notebook和charts实现数据可视化</title>
    <link href="http://yoursite.com/2017/12/14/jupyter-notebook%E5%92%8Ccharts%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    <id>http://yoursite.com/2017/12/14/jupyter-notebook和charts实现数据可视化/</id>
    <published>2017-12-14T03:52:56.000Z</published>
    <updated>2018-12-27T02:46:29.800Z</updated>
    
    <content type="html"><![CDATA[<h3 id="安装jupyter"><a href="#安装jupyter" class="headerlink" title="安装jupyter"></a>安装jupyter</h3><p>Jupyter Notebook是一个交互式笔记本，是一个功能非常强大的交互式工具。一般来说，我们安装的话，只要使用<code>pip install jupyter</code>就可以了。但是如果安装失败，我们也可以使用<code>anaconda</code>这个包管理工具来安装，这个还是比较方便的。<br>这里有一个jupyter notebook的教程，比较简单，但是也还不错。<a href="https://www.cnblogs.com/nxld/p/6566380.html" target="_blank" rel="noopener">教程地址</a></p><h3 id="chart模块"><a href="#chart模块" class="headerlink" title="chart模块"></a>chart模块</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>首先<code>pip</code>安装<code>charts</code>模块，<code>pip install charts</code>。这个时候试试<code>import</code>是否成功，如果成功，那么OK。如果失败的话，找到<code>site-packages</code>文件路径，打开<code>charts</code>文件夹，将<code>charts</code>文件下的7个文件替换，替换地址为<a href="https://github.com/zhangdaxiang/charts-replace" target="_blank" rel="noopener">文件地址</a>。</p><h4 id="柱状图"><a href="#柱状图" class="headerlink" title="柱状图"></a>柱状图</h4><p>接下来我们把之前爬取到的赶集网的数据用图形表示出来,这样数据比较起来更加直观。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line"><span class="keyword">import</span> charts</span><br><span class="line"><span class="comment">#连接之前爬取的数据，在Mongodb里面</span></span><br><span class="line">client = pymongo.MongoClient(<span class="string">'localhost'</span>,<span class="number">27017</span>)</span><br><span class="line">ganji = client[<span class="string">'ganji'</span>]</span><br><span class="line">ganji3 = ganji[<span class="string">'ganji3'</span>]</span><br><span class="line">cate_list = []</span><br><span class="line"><span class="comment">#取之前爬取到的cates属性的第二个标签来分类</span></span><br><span class="line">cate_list = [i[<span class="string">'cates'</span>][<span class="number">2</span>] <span class="keyword">for</span> i <span class="keyword">in</span> ganji3.find()]</span><br><span class="line"><span class="comment">#set来进行去重，取出不重复的标签</span></span><br><span class="line">cate_index = list(set(cate_list))</span><br><span class="line"><span class="comment">#取出每个标签对应的数量</span></span><br><span class="line">cate_list = [i[<span class="string">'cates'</span>][<span class="number">2</span>] <span class="keyword">for</span> i <span class="keyword">in</span> ganji3.find()]</span><br><span class="line">num_list = [cate_list.count(i) <span class="keyword">for</span> i <span class="keyword">in</span> cate_index]</span><br><span class="line"><span class="comment">#使用zip函数来一一对应</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cate_num</span><span class="params">()</span>:</span></span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> zip(cate_index,num_list):</span><br><span class="line">data = &#123;</span><br><span class="line"><span class="string">'name'</span>:k</span><br><span class="line">,<span class="string">'data'</span>:[v]</span><br><span class="line">,<span class="string">'type'</span>:<span class="string">'column'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">yield</span> data</span><br><span class="line"><span class="comment">#使用charts的plot方法生成柱状图</span></span><br><span class="line">charts.plot([i <span class="keyword">for</span> i <span class="keyword">in</span> cate_num()],show=<span class="string">'inline'</span>,options=&#123;<span class="string">'title'</span>:&#123;<span class="string">'text'</span>:<span class="string">'ganji_cate'</span>&#125;&#125;)</span><br></pre></td></tr></table></figure></p><p><img src="/img/jupyter-notebook和charts实现数据可视化/ganji_cates.jpg" alt="ganji_cates" width="800" height="800"></p><h4 id="折线图"><a href="#折线图" class="headerlink" title="折线图"></a>折线图</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> date,timedelta</span><br><span class="line"><span class="keyword">import</span> charts</span><br><span class="line"><span class="comment">#连接Mongodb</span></span><br><span class="line">client = pymongo.MongoClient(<span class="string">'localhost'</span>,<span class="number">27017</span>)</span><br><span class="line">ganji3 = client[<span class="string">'ganji'</span>]</span><br><span class="line">ganjisheet = ganji3[<span class="string">'ganji3'</span>]</span><br><span class="line"><span class="comment">#统一日期格式</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> ganjisheet.find():</span><br><span class="line">    <span class="keyword">if</span> len(i[<span class="string">'pub_date'</span>].split(<span class="string">'.'</span>))&gt;<span class="number">1</span>:</span><br><span class="line">        ganjisheet.update(&#123;<span class="string">'_id'</span>:i[<span class="string">'_id'</span>]&#125;,&#123;<span class="string">'$set'</span>:&#123;<span class="string">'pub_date'</span>:<span class="string">'-'</span>.join(i[<span class="string">'pub_date'</span>].split(<span class="string">'.'</span>))&#125;&#125;)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#返回一段时间，timedelte()和data()是处理日期的函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">date_num</span><span class="params">(date1,date2)</span>:</span></span><br><span class="line"><span class="comment">#data()函数输入三个自然数，输出一个字符串</span></span><br><span class="line">    start_date = date(int(date1.split(<span class="string">'-'</span>)[<span class="number">0</span>]),int(date1.split(<span class="string">'-'</span>)[<span class="number">1</span>]),int(date1.split(<span class="string">'-'</span>)[<span class="number">2</span>]))</span><br><span class="line">    end_date = date(int(date2.split(<span class="string">'-'</span>)[<span class="number">0</span>]),int(date2.split(<span class="string">'-'</span>)[<span class="number">1</span>]),int(date2.split(<span class="string">'-'</span>)[<span class="number">2</span>]))</span><br><span class="line">    <span class="keyword">while</span> start_date &lt;= end_date:</span><br><span class="line">        <span class="keyword">yield</span> start_date</span><br><span class="line">        <span class="comment">#timedelta(1)就表示1天</span></span><br><span class="line">        start_date += timedelta(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#返回data生成器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ares_num</span><span class="params">(areas,date1,date2)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> area <span class="keyword">in</span> areas:</span><br><span class="line">        area_num = []</span><br><span class="line">        <span class="keyword">for</span> date <span class="keyword">in</span> date_num(date1,date2):</span><br><span class="line">            num = ganjisheet.find(&#123;<span class="string">'pub_date'</span>:date.strftime(<span class="string">'%Y-%m-%d'</span>),<span class="string">'area'</span>:area&#125;).count()</span><br><span class="line">            area_num.append(num)</span><br><span class="line">        data = &#123;<span class="string">'name'</span>:area</span><br><span class="line">               ,<span class="string">'data'</span>:area_num</span><br><span class="line">               ,<span class="string">'type'</span>:<span class="string">'line'</span>&#125;</span><br><span class="line">        <span class="keyword">yield</span> data</span><br><span class="line"></span><br><span class="line"><span class="comment">#表格参数</span></span><br><span class="line">options = &#123;</span><br><span class="line">    <span class="string">'title'</span>: &#123;<span class="string">'text'</span>: <span class="string">'我是标题'</span>&#125;</span><br><span class="line">    ,<span class="string">'subtitle'</span>: &#123;<span class="string">'text'</span>: <span class="string">'我是副标题'</span>&#125;</span><br><span class="line">    ,<span class="string">'xAxis'</span>: &#123;<span class="string">'categories'</span>: [i.strftime(<span class="string">'%Y-%m-%d'</span>) <span class="keyword">for</span> i <span class="keyword">in</span> date_num(<span class="string">'2016-01-01'</span>,<span class="string">'2016-01-10'</span>)]</span><br><span class="line">              ,<span class="string">'title'</span>:&#123;<span class="string">'text'</span>:<span class="string">'x轴标题'</span>&#125;&#125;</span><br><span class="line">    ,<span class="string">'yAxis'</span>:&#123;<span class="string">'title'</span>:&#123;<span class="string">'text'</span>:<span class="string">'y轴标题'</span>&#125;&#125;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">series = [i <span class="keyword">for</span> i <span class="keyword">in</span> ares_num([<span class="string">'朝阳'</span>,<span class="string">'海淀'</span>,<span class="string">'通州'</span>],<span class="string">'2016-01-01'</span>,<span class="string">'2016-01-10'</span>)]</span><br><span class="line">charts.plot(series,show = <span class="string">'inline'</span>,options = options)</span><br></pre></td></tr></table></figure><p><img src="/img/jupyter-notebook和charts实现数据可视化/ganji_cates2.jpg" alt="ganji_cates2" width="800" height="800"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;安装jupyter&quot;&gt;&lt;a href=&quot;#安装jupyter&quot; class=&quot;headerlink&quot; title=&quot;安装jupyter&quot;&gt;&lt;/a&gt;安装jupyter&lt;/h3&gt;&lt;p&gt;Jupyter Notebook是一个交互式笔记本，是一个功能非常强大的交互式工具。
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="charts" scheme="http://yoursite.com/tags/charts/"/>
    
  </entry>
  
  <entry>
    <title>sqlserver存储过程小技巧</title>
    <link href="http://yoursite.com/2017/12/07/sqlserver%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    <id>http://yoursite.com/2017/12/07/sqlserver存储过程小技巧/</id>
    <published>2017-12-07T08:15:09.000Z</published>
    <updated>2018-12-27T02:46:29.803Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数据写入表"><a href="#数据写入表" class="headerlink" title="数据写入表"></a>数据写入表</h3><p>今天碰到一个问题，执行一个存储过程时<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXEC proc_orderday</span><br></pre></td></tr></table></figure></p><p>返回了一系列的数据，但是并不能对这些数据进行处理,我们想要对这些数据进行操作的话，就要写把他们写入一个表。<br>需要注意的是，一定要先建表，才能写入，直接<code>select * into</code>是不行的。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#先建一个临时表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="comment">#tmp</span></span><br><span class="line">(</span><br><span class="line">...</span><br><span class="line">)</span><br><span class="line"><span class="comment">#写入存储过程数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="comment">#tmp</span></span><br><span class="line">EXEC proc_orderday</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;数据写入表&quot;&gt;&lt;a href=&quot;#数据写入表&quot; class=&quot;headerlink&quot; title=&quot;数据写入表&quot;&gt;&lt;/a&gt;数据写入表&lt;/h3&gt;&lt;p&gt;今天碰到一个问题，执行一个存储过程时&lt;br&gt;&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table
      
    
    </summary>
    
      <category term="sqlserver" scheme="http://yoursite.com/categories/sqlserver/"/>
    
    
      <category term="sqlserver" scheme="http://yoursite.com/tags/sqlserver/"/>
    
  </entry>
  
  <entry>
    <title>python之路(8):IO编程</title>
    <link href="http://yoursite.com/2017/12/04/python%E4%B9%8B%E8%B7%AF(8)IO%E7%BC%96%E7%A8%8B/"/>
    <id>http://yoursite.com/2017/12/04/python之路(8)IO编程/</id>
    <published>2017-12-04T06:56:42.000Z</published>
    <updated>2018-12-27T02:46:29.802Z</updated>
    
    <content type="html"><![CDATA[<p>平常，我们用电脑浏览器访问页面，我们对网页服务器说，我们要你的<code>HTML</code>，这个是向网页服务器发数据，叫作<code>Output</code>。然后网页服务器把数据传过来，我们接收，这个叫作<code>Input</code>。再比如说我们从内存写入到磁盘文件，是<code>Output</code>，从磁盘文件读到内存是<code>Input</code>。<br>这个地方我之前经常弄混，后来记住了，这个”进出”是相对于内存来说的，就明了了。</p><h3 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h3><p>文件读写是最基本的<code>IO</code>操作。现代操作系统，一般不允许程序直接操作磁盘。所以，读写文件都是请求操作系统打开一个文件对象（通常称为文件描述符），然后通过系统提供的接口把数据写入这个文件对象，或者从这个文件对象读取数据。</p><h4 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h4><p>我们可以通过<code>open()</code>函数传入文件名和标识符来打开一个文件：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f=open(<span class="string">'/users/text.txt'</span>,<span class="string">'r'</span>)</span><br></pre></td></tr></table></figure></p><p>这里的<code>r</code>表示这个文件是读。如果要打开的文件不存在，<code>open()</code>函数就会报出<code>IOError</code>的错误。如果打开成功，我们可以使用<code>read()</code>方法来读取文件的内容：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f.read()</span><br></pre></td></tr></table></figure></p><p>操作完毕以后，需要用<code>close()</code>方法来关闭这个文件。如果不关闭的话，这个文件对象就会一直占用系统资源。而且如果<code>open()</code>报错的话，会影响程序接下去运行，我们一般用<code>try...finally...</code>的方法来解决这个问题：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">f = open(<span class="string">'/user/text.txt'</span>,<span class="string">'r'</span>)</span><br><span class="line">print(f.read())</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line"><span class="keyword">if</span> f:</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure></p><p>这样太麻烦了，所以有一种用<code>with</code>的便捷的写法，这样写<code>python</code>会自己关闭文件：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'/user/text.txt'</span>,<span class="string">'r'</span>):</span><br><span class="line">print(f.read())</span><br></pre></td></tr></table></figure></p><p>这样就可以实现和上面一样的功能。<br>要注意的是，<code>read()</code>方法会一次读取文件的所有内容。可以使用<code>read(size)</code>来一次读取<code>size</code>大小的内容，反复调用，从而获得全部。也可以使用<code>readlines()</code>来获取文件的一行内容。<br>这些都是在<code>utf-8</code>编码下文本的情况，如果要读取视频，图片等二进制的文件，就要使用<code>rb</code>标识符：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'/user/picture1.jpg'</span>,<span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">print(f.read())</span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line"><span class="string">b'\xff\xd8\xff\xe1\x00\x18Exif\x00\x00...'</span> <span class="comment"># 十六进制表示的字节</span></span><br></pre></td></tr></table></figure></p><p>如果文件对象不是<code>utf-8</code>，可以使用<code>encoding</code>参数来读取，比如说<code>gbk</code>格式的：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'/user/text.txt'</span>,<span class="string">'r'</span>,encoding=<span class="string">'gbk'</span>) <span class="keyword">as</span> f:</span><br><span class="line">print(f.read())</span><br></pre></td></tr></table></figure></p><p>有时候如果文件编码不规范的话，很容易产生错误，最简单方法是忽略，<code>open()</code>有一个<code>errors</code>来实现这个：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'/user/text.txt'</span>,<span class="string">'r'</span>,encoding=<span class="string">'gbk'</span>,errors=<span class="string">'ignore'</span>) <span class="keyword">as</span> f:</span><br><span class="line">print(f.read())</span><br></pre></td></tr></table></figure></p><h4 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h4><p>写文件和读文件的唯一区别就是把标识符改成<code>w</code>和<code>wb</code>。而且如果没有<code>close()</code>的话，会导致一部分写入的数据没有保存，所以一定要<code>close()</code>。同样的，<code>with</code>写法可以帮我们自动<code>close()</code>。</p><h3 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h3><p><code>python</code>的目录操作基本都在内置的<code>os</code>模块中，使用前记得导入。</p><h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><p><code>python</code>中的环境变量，全部保存在<code>os.environ</code>中：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#导入os模块</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="comment">#查看环境变量</span></span><br><span class="line">os.environ</span><br></pre></td></tr></table></figure></p><p>如果想查看某个环境变量的值，比如<code>PATH</code>，可以使用<code>os.environ.get(&#39;key&#39;)</code>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">os.environ.get(<span class="string">'PATH'</span>)</span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line"><span class="string">'C:\\Ruby23-x64\\bin;C:\\Program Files (x86)\\Intel\\iCLS Client\\;'</span></span><br><span class="line"><span class="comment">#如果环境变量不存在</span></span><br><span class="line">os.environ.get(<span class="string">'x'</span>,<span class="string">'default'</span>)</span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line"><span class="string">'default'</span></span><br></pre></td></tr></table></figure></p><h4 id="操作文件和目录"><a href="#操作文件和目录" class="headerlink" title="操作文件和目录"></a>操作文件和目录</h4><p><code>python</code>操作文件的函数都在<code>os</code>模块和<code>os.path</code>模块中：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看当前目录的绝对路径</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.abspath(<span class="string">'.'</span>)</span><br><span class="line"><span class="string">'C:\\Users\\Administrator\\Desktop'</span></span><br><span class="line"><span class="comment">#在某个目录下创建一个新目录，把新目录的完整路径表示出来</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.join(<span class="string">'\\test1\\test2'</span>,<span class="string">'test3'</span>)</span><br><span class="line"><span class="string">'\\test1\\test2\\test3'</span></span><br><span class="line"><span class="comment">#然后创建一个目录</span></span><br><span class="line">os.mkdir(<span class="string">'C:\\Users\\Administrator\\Desktop\\test1\\test2\\test3'</span>)</span><br><span class="line"><span class="comment">#删除目录</span></span><br><span class="line">os.rmdir(<span class="string">'C:\\Users\\Administrator\\Desktop\\test1\\test2\\test3'</span>)</span><br></pre></td></tr></table></figure></p><p>想要拼接两个路径，使用<code>os.path.join()</code>函数。<br>在Linux/Unix/Mac下返回：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">part<span class="number">-1</span>/part<span class="number">-2</span></span><br></pre></td></tr></table></figure></p><p>在Windows下会返回：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">part<span class="number">-1</span>\\part<span class="number">-2</span></span><br></pre></td></tr></table></figure></p><p>还可以使使用<code>os.path.split()</code>和<code>os.path.splitext()</code>这两个函数来分割路径：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#这个函数分割至文件名</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(os.path.split(<span class="string">'C:\\Users\\Administrator\\Desktop\\test1\\test2\\test3.txt'</span>))</span><br><span class="line">(<span class="string">'C:\\Users\\Administrator\\Desktop\\test1\\test2'</span>, <span class="string">'test3.txt'</span>)</span><br><span class="line"><span class="comment">#这个函数分割至文件后缀名</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(os.path.splitext(<span class="string">'C:\\Users\\Administrator\\Desktop\\test1\\test2\\test3.txt'</span>))</span><br><span class="line">(<span class="string">'C:\\Users\\Administrator\\Desktop\\test1\\test2\\test3'</span>, <span class="string">'.txt'</span>)</span><br></pre></td></tr></table></figure></p><p>如果当前目录下有一个文件名<code>text3.txt</code>，文件操作的比如重命名，删除可以用一下两个函数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#重命名</span></span><br><span class="line">os.rename(<span class="string">'text3.txt'</span>,<span class="string">'text4.txt'</span>)</span><br><span class="line"><span class="comment">#当然也可以这样写</span></span><br><span class="line">os.rename(<span class="string">'C:\\Users\\Administrator\\Desktop\\test1\\test2\\test3.txt'</span>,<span class="string">'C:\\Users\\Administrator\\Desktop\\test1\\test2\\test4.txt'</span>)</span><br><span class="line"><span class="comment">#删除</span></span><br><span class="line">os.remove(<span class="string">'text3.txt'</span>)</span><br></pre></td></tr></table></figure></p><p>可以使用以下两个函数来判定是否为目录和文件：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#判定是否为目录</span></span><br><span class="line">os.path.isdir(path)</span><br><span class="line"><span class="comment">#判定是否为文件</span></span><br><span class="line">os.path.isfile(path)</span><br></pre></td></tr></table></figure></p><p>可以使用一下的代码来实现筛选出当前目录下所有<code>.py</code>文件：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[x <span class="keyword">for</span> x <span class="keyword">in</span> os.path.listdir(<span class="string">'.'</span>) <span class="keyword">if</span> os.path.isfile(x) <span class="keyword">and</span> os.path.splitext(x)[<span class="number">1</span>]==<span class="string">'py'</span>]</span><br></pre></td></tr></table></figure></p><p>但是<code>os</code>模块里面没有移动文件的函数。。。感觉很不方便。好在<code>shutil</code>模块中有类似的函数来补充使用。</p><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><h4 id="序列化-1"><a href="#序列化-1" class="headerlink" title="序列化"></a>序列化</h4><p>一般情况下，我们在内存中执行程序，如果定义了一个变量：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d = dict(name=<span class="string">'zhangdaxiang'</span>,age=<span class="number">23</span>,city=<span class="string">'hangzhou'</span>)</span><br></pre></td></tr></table></figure></p><p>这样子，变量是存储在内存中的，如果我们在程序中改变了这个<code>dict</code>，而没有保存到磁盘里。结算程序时，变量占用的内存被回收，下次运行程序，这个变量还是没有改变之前的值。想把对象保存到磁盘，就要序列化。<br>我们把变量变成可以存储或者传输的过程就叫作序列化。而把序列化对象重新读取到内存中，就称作反序列化。<br><code>python</code>中提供了<code>pickle</code>模块来实现这个需求。<br>可以用<code>pickle.dumps()</code>序列化成一个<code>bytes</code>，也可以使用<code>pickle.dump()</code>直接把对象序列化然后写入<code>file-like Object</code>中：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#导入pickle模块</span></span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line">d = dict(name=<span class="string">'zhangdaxiang'</span>,age=<span class="number">23</span>,city=<span class="string">'hangzhou'</span>)</span><br><span class="line"><span class="comment">#打开一个file-like Object文件</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'dump.txt'</span>,<span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line"><span class="comment">#写入序列化对象</span></span><br><span class="line">pickle.dump(d,f)</span><br><span class="line"></span><br><span class="line"><span class="comment">#序列化bytes</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pickle.dumps(d)</span><br><span class="line"><span class="string">b'\x80\x03&#125;q\x00(X\x03\x00\x00\x00ageq\x01K\x17X\x04\x00\x00\x00nameq\x02X\x0c\x00\x00\x00zhangdaxiangq\x03X\x04\x00\x00\x00cityq\x04X\x08\x00\x00\x00hangzhouq\x05u.'</span></span><br></pre></td></tr></table></figure></p><p>可以使用<code>pickle.loads()</code>直接把一个<code>bytes</code>对象反序列化，也可以用<code>pickle.load()</code>函数从一个<code>file-like Object</code>中反序列化对象：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="comment">#打开一个file-like Object</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'dump.txt'</span>,<span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line"><span class="comment">#反序列化</span></span><br><span class="line">d = pickle.load(f) <span class="comment">#因为变量之前的内存已经回来，反序列化出来的变量虽然值和之前一样，但是并不是一个变量了</span></span><br><span class="line">print(d)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#直接反序列化bytes</span></span><br><span class="line">d = dict(name=<span class="string">'zhangdaxiang'</span>,age=<span class="number">23</span>,city=<span class="string">'hangzhou'</span>)</span><br><span class="line"><span class="comment">#反序列化bytes</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pickle.loads(pickle.dumps(d))</span><br><span class="line">&#123;<span class="string">'city'</span>: <span class="string">'hangzhou'</span>, <span class="string">'name'</span>: <span class="string">'zhangdaxiang'</span>, <span class="string">'age'</span>: <span class="number">23</span>&#125;</span><br></pre></td></tr></table></figure></p><h4 id="json"><a href="#json" class="headerlink" title="json"></a>json</h4><p>如果我们想在不同的程序直接传递数据，可以把对象转换成<code>json</code>格式，<code>json</code>格式就是一个字符串，所以任何程序都可以读取。<br><code>python</code>提供了一个<code>json</code>模块来完成转换，和序列化类似的，也有<code>dump()</code>和<code>dumps()</code>来转换成<code>json</code>，也有<code>load()</code>和<code>loads()</code>来把<code>json</code>转换成<code>python</code>对象。比如说转换一个<code>dict</code>对象：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> json</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = dict(name=<span class="string">'zhangdaxiang'</span>,age=<span class="number">23</span>,city=<span class="string">'hangzhou'</span>) </span><br><span class="line"><span class="comment">#返回json对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>json.dumps(d)</span><br><span class="line"><span class="string">'&#123;"city": "hangzhou", "age": 23, "name": "zhangdaxiang"&#125;'</span></span><br></pre></td></tr></table></figure></p><p>和序列化类似，<code>dump()</code>函数是直接把<code>json</code>写入一个<code>file-like Object</code>对象。<br>反序列化的<code>loads()</code>和<code>load()</code>函数也类似：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义json对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>json_str = <span class="string">'&#123;"city": "hangzhou", "age": 23, "name": "zhangdaxiang"&#125;'</span></span><br><span class="line"><span class="comment">#反序列化，返回dict</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>json.loads(json_str)</span><br><span class="line">&#123;<span class="string">'name'</span>: <span class="string">'zhangdaxiang'</span>, <span class="string">'city'</span>: <span class="string">'hangzhou'</span>, <span class="string">'age'</span>: <span class="number">23</span>&#125;</span><br></pre></td></tr></table></figure></p><p>从上面可以看出，<code>json</code>中的<code>{}</code>是对应<code>python</code>中的<code>dict</code>，这样就可以互相转换。但是更多的时候，我们是用一个类来表示一个对象，如果用<code>json</code>模块来转换的话，就会报<code>TypeError</code>的错误。不必惊慌，<code>dumps()</code>函数有一个可选参数<code>default</code>，这个参数可以把对象转换成可以转换为<code>json</code>的对象，然后就可以和之前转换<code>dict</code>一样转换了。一般情况下，我们可以定义一个函数把类转换为<code>dict</code>来解决：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#导入json</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="comment">#定义一个类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span><span class="params">()</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,age,city)</span>:</span></span><br><span class="line">self.name = name</span><br><span class="line">self.age = age</span><br><span class="line">self.city = city</span><br><span class="line"><span class="comment">#定义一个转化函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">People2dict</span><span class="params">(x)</span>:</span></span><br><span class="line"><span class="keyword">return</span> &#123;<span class="string">'name'</span>: x.name</span><br><span class="line">,<span class="string">'age'</span>:x.age</span><br><span class="line">,<span class="string">'city'</span>:x.city&#125;</span><br><span class="line"><span class="comment">#实例化类</span></span><br><span class="line">people = People(<span class="string">'zhangdaxiang'</span>,<span class="number">23</span>,<span class="string">'city'</span>)</span><br><span class="line"><span class="comment">#转换为json</span></span><br><span class="line">print(json.dumps(people,default=People2dict))</span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line">&#123;<span class="string">"age"</span>: <span class="number">23</span>, <span class="string">"city"</span>: <span class="string">"hangzhou"</span>, <span class="string">"name"</span>: <span class="string">"zhangdaxiang"</span>&#125;</span><br></pre></td></tr></table></figure></p><p>这样就和之前一样了。<br>我们也可以使用一个偷懒的方法，因为类的实例一般都有<code>__dict__</code>方法的话，<code>people.__dict__</code>后就可以认为是一个<code>dict</code>。我们只需要如此操作即可：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(json.dumps(people,default=<span class="keyword">lambda</span> x:x.__dict__))</span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line">&#123;<span class="string">"name"</span>: <span class="string">"zhangdaxiang"</span>, <span class="string">"age"</span>: <span class="number">23</span>, <span class="string">"city"</span>: <span class="string">"hangzhou"</span>&#125;</span><br></pre></td></tr></table></figure></p><p>同样的，我们想要反序列化<code>json</code>字段的话，我们先用<code>loads()</code>返回一个<code>dict</code>，然后自定义一个函数来把<code>dict</code>传入<code>object_hook</code>来转化成类。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义json对象</span></span><br><span class="line">json_str = <span class="string">'&#123;"city": "hangzhou", "age": 23, "name": "zhangdaxiang"&#125;'</span></span><br><span class="line"><span class="comment">#字典转化为类实例</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dict2People</span><span class="params">(x)</span>:</span></span><br><span class="line"><span class="keyword">return</span> People(x[<span class="string">'name'</span>],x[<span class="string">'age'</span>],x[<span class="string">'city'</span>])</span><br><span class="line"><span class="comment">#反序列化</span></span><br><span class="line">print(json.loads(json_str,object_hook = dict2People))</span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line">&lt;__main__.People object at <span class="number">0x0000000003496EB8</span>&gt;</span><br></pre></td></tr></table></figure></p><p>这样就打印出了实例对象的内存地址。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;平常，我们用电脑浏览器访问页面，我们对网页服务器说，我们要你的&lt;code&gt;HTML&lt;/code&gt;，这个是向网页服务器发数据，叫作&lt;code&gt;Output&lt;/code&gt;。然后网页服务器把数据传过来，我们接收，这个叫作&lt;code&gt;Input&lt;/code&gt;。再比如说我们从内存写入
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Windows7安装Scrapy与Pyspider</title>
    <link href="http://yoursite.com/2017/10/26/Windows7%E5%AE%89%E8%A3%85Scrapy%E4%B8%8EPyspider/"/>
    <id>http://yoursite.com/2017/10/26/Windows7安装Scrapy与Pyspider/</id>
    <published>2017-10-26T08:32:18.000Z</published>
    <updated>2018-12-27T02:46:29.798Z</updated>
    
    <content type="html"><![CDATA[<p>说的python上面的爬虫框架，最有名的当然是Scrapy了，但是感觉他对windows操作系统不太友好，安装的时候各种报错。这个也加深了我好好学习linux的决心。经过多次尝试，总结一下windows上安装Scrapy和Pyspider的步骤。</p><p>Scrapy要求Twisted.whl，Pyspider要求lxml.whl</p><h3 id="更新pip（可选）"><a href="#更新pip（可选）" class="headerlink" title="更新pip（可选）"></a>更新pip（可选）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m pip install -U pip</span><br></pre></td></tr></table></figure><h3 id="安装wheel"><a href="#安装wheel" class="headerlink" title="安装wheel"></a>安装wheel</h3><p>进入python目录下的scripts目录<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> D:\\Python35\Scripts</span><br></pre></td></tr></table></figure></p><p>安装wheel<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install wheel</span><br></pre></td></tr></table></figure></p><h3 id="下载whl"><a href="#下载whl" class="headerlink" title="下载whl"></a>下载whl</h3><p>找到并下载lxml与Twisted两个包。</p><h3 id="安装whl"><a href="#安装whl" class="headerlink" title="安装whl"></a>安装whl</h3><p>安装.whl<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install lxml-3.6.4-cp35-cp35m-win_amd64.whl</span><br><span class="line">pip install Twisted-16.6.0-cp35-cp35m-win_amd64.whl</span><br></pre></td></tr></table></figure></p><h3 id="安装Scrapy、PySpider"><a href="#安装Scrapy、PySpider" class="headerlink" title="安装Scrapy、PySpider"></a>安装Scrapy、PySpider</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install scrapy</span><br><span class="line">pip install pyspider</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;说的python上面的爬虫框架，最有名的当然是Scrapy了，但是感觉他对windows操作系统不太友好，安装的时候各种报错。这个也加深了我好好学习linux的决心。经过多次尝试，总结一下windows上安装Scrapy和Pyspider的步骤。&lt;/p&gt;
&lt;p&gt;Scrapy
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python爬虫同时添加用户代理和ip代理</title>
    <link href="http://yoursite.com/2017/10/21/python%E7%88%AC%E8%99%AB%E5%90%8C%E6%97%B6%E6%B7%BB%E5%8A%A0%E7%94%A8%E6%88%B7%E4%BB%A3%E7%90%86%E5%92%8Cip%E4%BB%A3%E7%90%86/"/>
    <id>http://yoursite.com/2017/10/21/python爬虫同时添加用户代理和ip代理/</id>
    <published>2017-10-20T16:00:00.000Z</published>
    <updated>2018-12-27T02:46:29.803Z</updated>
    
    <content type="html"><![CDATA[<h3 id="为何要设置User-Agent"><a href="#为何要设置User-Agent" class="headerlink" title="为何要设置User Agent"></a>为何要设置User Agent</h3><blockquote><p>通过一段时间的爬虫学习，也成功实现了一些小的爬取项目，有的时候会出现代码正确但是无法爬取的情况。通过科学上网，了解到了有一些网站对于爬虫访问会有一定的措施，如果一段时间内同一ip访问次数过多，就会当做爬虫程序予以封杀。所以，我们需要伪装自己的爬虫程序，了解到伪装大致需要添加用户代理以及ip代理。下面是设置UA代理和ip代理的过程。</p></blockquote><h3 id="常见的User-Agent"><a href="#常见的User-Agent" class="headerlink" title="常见的User Agent"></a>常见的User Agent</h3><h4 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Mozilla/<span class="number">5.0</span> (Linux; Android <span class="number">4.1</span><span class="number">.1</span>; Nexus <span class="number">7</span> Build/JRO03D) AppleWebKit/<span class="number">535.19</span> (KHTML, like Gecko) Chrome/<span class="number">18.0</span><span class="number">.1025</span><span class="number">.166</span> Safari/<span class="number">535.19</span></span><br><span class="line">Mozilla/<span class="number">5.0</span> (Linux; U; Android <span class="number">4.0</span><span class="number">.4</span>; en-gb; GT-I9300 Build/IMM76D) AppleWebKit/<span class="number">534.30</span> (KHTML, like Gecko) Version/<span class="number">4.0</span> Mobile Safari/<span class="number">534.30</span></span><br><span class="line">Mozilla/<span class="number">5.0</span> (Linux; U; Android <span class="number">2.2</span>; en-gb; GT-P1000 Build/FROYO) AppleWebKit/<span class="number">533.1</span> (KHTML, like Gecko) Version/<span class="number">4.0</span> Mobile Safari/<span class="number">533.1</span></span><br></pre></td></tr></table></figure><h4 id="Firefox"><a href="#Firefox" class="headerlink" title="Firefox"></a>Firefox</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mozilla/<span class="number">5.0</span> (Windows NT <span class="number">6.2</span>; WOW64; rv:<span class="number">21.0</span>) Gecko/<span class="number">20100101</span> Firefox/<span class="number">21.0</span></span><br><span class="line">Mozilla/<span class="number">5.0</span> (Android; Mobile; rv:<span class="number">14.0</span>) Gecko/<span class="number">14.0</span> Firefox/<span class="number">14.0</span></span><br></pre></td></tr></table></figure><h4 id="Google-Chrome"><a href="#Google-Chrome" class="headerlink" title="Google Chrome"></a>Google Chrome</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mozilla/<span class="number">5.0</span> (Windows NT <span class="number">6.2</span>; WOW64) AppleWebKit/<span class="number">537.36</span> (KHTML, like Gecko) Chrome/<span class="number">27.0</span><span class="number">.1453</span><span class="number">.94</span> Safari/<span class="number">537.36</span></span><br><span class="line">Mozilla/<span class="number">5.0</span> (Linux; Android <span class="number">4.0</span><span class="number">.4</span>; Galaxy Nexus Build/IMM76B) AppleWebKit/<span class="number">535.19</span> (KHTML, like Gecko) Chrome/<span class="number">18.0</span><span class="number">.1025</span><span class="number">.133</span> Mobile Safari/<span class="number">535.19</span></span><br></pre></td></tr></table></figure><h4 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mozilla/<span class="number">5.0</span> (iPad; CPU OS <span class="number">5</span>_0 like Mac OS X) AppleWebKit/<span class="number">534.46</span> (KHTML, like Gecko) Version/<span class="number">5.1</span> Mobile/<span class="number">9</span>A334 Safari/<span class="number">7534.48</span><span class="number">.3</span></span><br><span class="line">Mozilla/<span class="number">5.0</span> (iPod; U; CPU like Mac OS X; en) AppleWebKit/<span class="number">420.1</span> (KHTML, like Gecko) Version/<span class="number">3.0</span> Mobile/<span class="number">3</span>A101a Safari/<span class="number">419.3</span></span><br></pre></td></tr></table></figure><h3 id="添加方法"><a href="#添加方法" class="headerlink" title="添加方法"></a>添加方法</h3><h4 id="添加UA"><a href="#添加UA" class="headerlink" title="添加UA"></a>添加UA</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line">url =<span class="string">'https://www.cnblogs.com/AndyChen2015/p/7418280.html'</span></span><br><span class="line">headers = (<span class="string">"User-Agent"</span>,<span class="string">"Mozilla/5.0 (iPod; U; CPU like Mac OS X; en) AppleWebKit/420.1 (KHTML, like Gecko) Version/3.0 Mobile/3A101a Safari/419.3"</span>)</span><br><span class="line">opener = urllib.request.build_opener()</span><br><span class="line">opener.addheaders = [headers]</span><br><span class="line"><span class="comment">#将opener安装为全局，让urlopen()访问时也添加对应报头</span></span><br><span class="line">urllib.request.install_opener(opener)</span><br><span class="line">data1 = opener.open(url)</span><br><span class="line">data2 = urllib.request.urlopen(url)</span><br></pre></td></tr></table></figure><h4 id="添加ip代理"><a href="#添加ip代理" class="headerlink" title="添加ip代理"></a>添加ip代理</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line">ip = <span class="string">"192.168.1.1"</span></span><br><span class="line">proxy = urllib.request.ProxyHandler(&#123;<span class="string">"http"</span>:ip&#125;)</span><br><span class="line">opener = urllib.request.build_opener(proxy,urllib.request.HTTPHandler)</span><br><span class="line"><span class="comment">#将opener安装为全局</span></span><br><span class="line">urllib.request.install_opener(opener)</span><br></pre></td></tr></table></figure><h3 id="完整代码-两者同时添加"><a href="#完整代码-两者同时添加" class="headerlink" title="完整代码(两者同时添加)"></a>完整代码(两者同时添加)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#同时使用ip代理以及用户代理</span></span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="comment">#用户代理池和ip代理池</span></span><br><span class="line">uapools = [</span><br><span class="line"><span class="string">"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.221 Safari/537.36 SE 2.X MetaSr 1.0"</span>,</span><br><span class="line"><span class="string">"Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Trident/4.0; Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1) ; Maxthon/3.0)"</span>,</span><br><span class="line"><span class="string">"Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0; Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1) ;  QIHU 360EE)"</span>]</span><br><span class="line">ippools = [<span class="string">"61.135.217.7"</span>,<span class="string">"118.114.77.47"</span>,<span class="string">"111.224.104.161"</span>]</span><br><span class="line">url = <span class="string">'http://www.baidu.com'</span></span><br><span class="line"><span class="comment">#添加用户代理以及ip代理</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ua</span><span class="params">(uapools,ippools)</span>:</span></span><br><span class="line">    req = urllib.request.Request(url)</span><br><span class="line">    req.add_header(<span class="string">"User-Agent"</span>,random.choice(uapools))</span><br><span class="line">    proxy = urllib.request.ProxyHandler(&#123;<span class="string">"https"</span>:random.choice(ippools)&#125;)</span><br><span class="line">    opener = urllib.request.build_opener(proxy,urllib.request.HTTPHandler)</span><br><span class="line">    <span class="comment">#将opener安装为全局</span></span><br><span class="line">    urllib.request.install_opener(opener)</span><br><span class="line">    <span class="keyword">return</span> req</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">        req = ua(uapools,ippools)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            data = urllib.request.urlopen(req)</span><br><span class="line">            print(len(data.read()))</span><br><span class="line">            print(data.getcode())</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> err:</span><br><span class="line">            print(err)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;为何要设置User-Agent&quot;&gt;&lt;a href=&quot;#为何要设置User-Agent&quot; class=&quot;headerlink&quot; title=&quot;为何要设置User Agent&quot;&gt;&lt;/a&gt;为何要设置User Agent&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;通过一段时
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>sqlserver存储过程中output和return之我见</title>
    <link href="http://yoursite.com/2017/03/28/sqlserver%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E4%B8%ADoutput%E5%92%8Creturn%E4%B9%8B%E6%88%91%E8%A7%81/"/>
    <id>http://yoursite.com/2017/03/28/sqlserver存储过程中output和return之我见/</id>
    <published>2017-03-28T03:13:04.000Z</published>
    <updated>2018-12-27T02:46:29.803Z</updated>
    
    <content type="html"><![CDATA[<p>今天老大把我叫去，和我说以后把数据库开发的一部分工作交给我。之前做的都是一些数据提取统计之类的活，虽然也写过几个存储过程，也大多数是提取类的。其中也用到了<code>output</code>这样的参数，但是之前没有好好地看过原理，只是根据之前已有的存储过程生搬硬套，总感觉对于<code>output</code>和<code>return</code>的理解不够。所以，今天就来总结一下这两个的用法。</p><h3 id="四种参数"><a href="#四种参数" class="headerlink" title="四种参数"></a>四种参数</h3><p>1.<code>input</code> 这个参数只是将信息从应用程序传输到存储过程。<br>2.<code>inputoutput</code>这个参数可以将信息从应用程序传输到存储过程，并可以将信息传输回应用程序。<br>3.<code>output</code>这个参数可以只可以将信息从存储过程传输回应用程序。<br>4.<code>returnvalue</code> 这个参数表示存储过程的返回值。存储过程参数列表中不显示该参数。它只和存储过程的 <code>return</code> 语句中的值相关联。</p><h3 id="参数实例"><a href="#参数实例" class="headerlink" title="参数实例"></a>参数实例</h3><h4 id="不带输入参数"><a href="#不带输入参数" class="headerlink" title="不带输入参数"></a>不带输入参数</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">IF OBJECT_ID('user_info') IS NOT NULL </span><br><span class="line"><span class="keyword">DROP</span> PROC user_info </span><br><span class="line"><span class="comment">--GO起到了分割sql脚本的作用，上下语句可以视为两个脚本</span></span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="keyword">CREATE</span> PROC user_info</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SET</span> NOCOUNT <span class="keyword">ON</span></span><br><span class="line"><span class="keyword">DECLARE</span> @<span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">BEGIN</span> </span><br><span class="line"><span class="keyword">SELECT</span> @<span class="keyword">name</span> = <span class="keyword">name</span> <span class="keyword">FROM</span> userinfo</span><br><span class="line"><span class="keyword">END</span> </span><br><span class="line">PRINT @<span class="keyword">name</span></span><br><span class="line"><span class="keyword">SET</span> NOCOUNT <span class="keyword">OFF</span></span><br><span class="line"><span class="comment">--执行存储过程</span></span><br><span class="line">EXEC user_info</span><br></pre></td></tr></table></figure><h4 id="带输入参数"><a href="#带输入参数" class="headerlink" title="带输入参数"></a>带输入参数</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">IF OBJECT_ID('user_info') IS NOT NULL </span><br><span class="line"><span class="keyword">DROP</span> PROC user_info </span><br><span class="line"><span class="comment">--GO起到了分割sql脚本的作用，上下语句可以视为两个脚本</span></span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="keyword">CREATE</span> PROC user_info</span><br><span class="line">(</span><br><span class="line">@<span class="keyword">id</span> <span class="built_in">INT</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SET</span> NOCOUNT <span class="keyword">ON</span></span><br><span class="line"><span class="keyword">DECLARE</span> @<span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">BEGIN</span> </span><br><span class="line"><span class="keyword">SELECT</span> @<span class="keyword">name</span> = <span class="keyword">name</span> <span class="keyword">FROM</span> userinfo <span class="keyword">WHERE</span> <span class="keyword">id</span> = @<span class="keyword">id</span></span><br><span class="line"><span class="keyword">END</span> </span><br><span class="line">PRINT @<span class="keyword">name</span></span><br><span class="line"><span class="keyword">SET</span> NOCOUNT <span class="keyword">OFF</span></span><br><span class="line"><span class="comment">--执行存储过程</span></span><br><span class="line">EXEC user_info @<span class="keyword">id</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="带return参数"><a href="#带return参数" class="headerlink" title="带return参数"></a>带return参数</h4><p>这里涉及到一个存储过程返回值的概念，和用<code>select</code>输出一个结果集不同的是，<code>return</code>返回的是一个数字。如果存储过程中有<code>return</code>，则返回<code>return</code>出来的值。如果没有<code>return</code>的话，则返回0。<br>这样子是返回作用的行数，即全局变量<code>@@ROWCOUNT</code>：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">IF OBJECT_ID('user_info') IS NOT NULL </span><br><span class="line"><span class="keyword">DROP</span> PROC user_info </span><br><span class="line"><span class="comment">--GO起到了分割sql脚本的作用，上下语句可以视为两个脚本</span></span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="keyword">CREATE</span> PROC user_info</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SET</span> NOCOUNT <span class="keyword">ON</span></span><br><span class="line"><span class="keyword">DECLARE</span> @<span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">BEGIN</span> </span><br><span class="line"><span class="keyword">SELECT</span> @<span class="keyword">name</span> = <span class="keyword">name</span> <span class="keyword">FROM</span> userinfo</span><br><span class="line"><span class="keyword">END</span> </span><br><span class="line"><span class="keyword">RETURN</span> @@ROWCOUNT</span><br><span class="line"><span class="keyword">SET</span> NOCOUNT <span class="keyword">OFF</span></span><br><span class="line"><span class="comment">--执行存储过程</span></span><br><span class="line"><span class="keyword">DECLARE</span> @<span class="keyword">result</span> <span class="built_in">INT</span></span><br><span class="line">EXEC @<span class="keyword">result</span> = user_info </span><br><span class="line"><span class="keyword">SELECT</span> @<span class="keyword">result</span></span><br></pre></td></tr></table></figure></p><p>这样的话就是没有<code>return</code>关键字，其实就是<code>return 0</code>：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">IF OBJECT_ID('user_info') IS NOT NULL </span><br><span class="line"><span class="keyword">DROP</span> PROC user_info </span><br><span class="line"><span class="comment">--GO起到了分割sql脚本的作用，上下语句可以视为两个脚本</span></span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="keyword">CREATE</span> PROC user_info</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SET</span> NOCOUNT <span class="keyword">ON</span></span><br><span class="line"><span class="keyword">DECLARE</span> @<span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">BEGIN</span> </span><br><span class="line"><span class="keyword">SELECT</span> @<span class="keyword">name</span> = <span class="keyword">name</span> <span class="keyword">FROM</span> userinfo</span><br><span class="line"><span class="keyword">END</span> </span><br><span class="line"><span class="comment">--RETURN @@ROWCOUNT</span></span><br><span class="line"><span class="keyword">SET</span> NOCOUNT <span class="keyword">OFF</span></span><br><span class="line"><span class="comment">--执行存储过程</span></span><br><span class="line"><span class="keyword">DECLARE</span> @<span class="keyword">result</span> <span class="built_in">INT</span></span><br><span class="line">EXEC @<span class="keyword">result</span> = user_info </span><br><span class="line"><span class="keyword">SELECT</span> @<span class="keyword">result</span></span><br></pre></td></tr></table></figure></p><p>注意的是，这里的<code>@@ROWCOUNT</code>虽然现实影响的行数是3，但是<code>@name</code>只是最近的一个。</p><h4 id="带有输出参数"><a href="#带有输出参数" class="headerlink" title="带有输出参数"></a>带有输出参数</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">IF OBJECT_ID('user_info') IS NOT NULL </span><br><span class="line"><span class="keyword">DROP</span> PROC user_info </span><br><span class="line"><span class="comment">--GO起到了分割sql脚本的作用，上下语句可以视为两个脚本</span></span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="keyword">CREATE</span> PROC user_info</span><br><span class="line">(</span><br><span class="line">@<span class="keyword">id</span> <span class="built_in">INT</span></span><br><span class="line">,@<span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">10</span>)=<span class="string">''</span> <span class="keyword">OUTPUT</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SET</span> NOCOUNT <span class="keyword">ON</span></span><br><span class="line"><span class="keyword">BEGIN</span> </span><br><span class="line"><span class="keyword">SELECT</span> @<span class="keyword">name</span> = <span class="keyword">name</span> <span class="keyword">FROM</span> userinfo <span class="keyword">WHERE</span> <span class="keyword">id</span> = @<span class="keyword">id</span></span><br><span class="line"><span class="keyword">END</span> </span><br><span class="line"><span class="keyword">SET</span> NOCOUNT <span class="keyword">OFF</span></span><br><span class="line"><span class="comment">--执行存储过程</span></span><br><span class="line"><span class="keyword">DECLARE</span> @<span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">10</span>)</span><br><span class="line"><span class="comment">--要注意的是，这里要重新declare一次OUTPUT参数@name,而且如果使用了@id=3这样的调用写法，OUTPUT参数也要用@name = value这样的写法。</span></span><br><span class="line"><span class="comment">--第一种写法</span></span><br><span class="line">EXEC user_info @<span class="keyword">id</span> = <span class="number">3</span>,@<span class="keyword">name</span> = @<span class="keyword">name</span> <span class="keyword">OUTPUT</span></span><br><span class="line"><span class="comment">--第二种写法</span></span><br><span class="line">EXEC user_info <span class="number">3</span>,@<span class="keyword">name</span> <span class="keyword">OUTPUT</span></span><br><span class="line"><span class="keyword">SELECT</span> @<span class="keyword">name</span></span><br></pre></td></tr></table></figure><h4 id="同时带return参数和output参数"><a href="#同时带return参数和output参数" class="headerlink" title="同时带return参数和output参数"></a>同时带return参数和output参数</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">IF OBJECT_ID('user_info') IS NOT NULL </span><br><span class="line"><span class="keyword">DROP</span> PROC user_info </span><br><span class="line"><span class="comment">--GO起到了分割sql脚本的作用，上下语句可以视为两个脚本</span></span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="keyword">CREATE</span> PROC user_info</span><br><span class="line">(</span><br><span class="line">@<span class="keyword">id</span> <span class="built_in">INT</span></span><br><span class="line">,@<span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">10</span>) <span class="keyword">OUTPUT</span> </span><br><span class="line">)</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SET</span> NOCOUNT <span class="keyword">ON</span></span><br><span class="line"><span class="keyword">DECLARE</span> @age <span class="built_in">INT</span> </span><br><span class="line"><span class="keyword">BEGIN</span> </span><br><span class="line"><span class="keyword">SELECT</span> @<span class="keyword">name</span> = <span class="keyword">name</span>,@age = age <span class="keyword">FROM</span> userinfo <span class="keyword">WHERE</span> <span class="keyword">id</span> = @<span class="keyword">id</span></span><br><span class="line"><span class="keyword">RETURN</span> @age</span><br><span class="line"><span class="keyword">END</span> </span><br><span class="line"><span class="keyword">SET</span> NOCOUNT <span class="keyword">OFF</span></span><br><span class="line"><span class="comment">--执行存储过程</span></span><br><span class="line"><span class="keyword">DECLARE</span> @<span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">DECLARE</span> @age <span class="built_in">INT</span> </span><br><span class="line">EXEC @age = user_info @<span class="keyword">id</span> = <span class="number">1</span>,@<span class="keyword">name</span> = @<span class="keyword">name</span> <span class="keyword">OUTPUT</span> </span><br><span class="line"><span class="comment">--当然这也写也是可以的，就像之前提到的</span></span><br><span class="line">EXEC @age = user_info <span class="number">1</span>,@<span class="keyword">name</span> <span class="keyword">OUTPUT</span> </span><br><span class="line"><span class="keyword">SELECT</span> @<span class="keyword">name</span>,@age</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天老大把我叫去，和我说以后把数据库开发的一部分工作交给我。之前做的都是一些数据提取统计之类的活，虽然也写过几个存储过程，也大多数是提取类的。其中也用到了&lt;code&gt;output&lt;/code&gt;这样的参数，但是之前没有好好地看过原理，只是根据之前已有的存储过程生搬硬套，总感觉
      
    
    </summary>
    
      <category term="sqlserver" scheme="http://yoursite.com/categories/sqlserver/"/>
    
    
      <category term="sqlserver" scheme="http://yoursite.com/tags/sqlserver/"/>
    
  </entry>
  
  <entry>
    <title>CentOS 6.X版本下安装vsftpd</title>
    <link href="http://yoursite.com/2017/02/08/CentOS-6-X%E7%89%88%E6%9C%AC%E4%B8%8B%E5%AE%89%E8%A3%85vsftpd/"/>
    <id>http://yoursite.com/2017/02/08/CentOS-6-X版本下安装vsftpd/</id>
    <published>2017-02-08T09:18:25.000Z</published>
    <updated>2018-12-27T02:46:29.797Z</updated>
    
    <content type="html"><![CDATA[<p>今天老大让我搭建一个开源的发布项目叫瓦力，我打算在自己的虚拟机里面先进行测试，其中的一步需要我搭建一个FTP服务器，vsftpd在Linux下是比较有名的FTP服务器，我就来试试这个。</p><p>实验环境： Centos 6.5</p><h3 id="安装vsftpd"><a href="#安装vsftpd" class="headerlink" title="安装vsftpd"></a>安装vsftpd</h3><p>查看是否已经安装vsftpd<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa | grep vsftpd</span><br></pre></td></tr></table></figure></p><p>如果没有，就安装，并设置开机启动<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum -y install vsftpd</span><br><span class="line">chkconfig vsftpd on</span><br></pre></td></tr></table></figure></p><h3 id="基于虚拟用户的配置"><a href="#基于虚拟用户的配置" class="headerlink" title="基于虚拟用户的配置"></a>基于虚拟用户的配置</h3><p>所谓虚拟用户就是没有使用真实的帐户，只是通过映射到真实帐户和设置权限的目的。虚拟用户不能登录CentOS系统。</p><h4 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h4><p>打开<code>/etc/vsftpd/vsftpd.conf</code>，做如下配置<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">anonymous_enable=NO <span class="comment"># 设定不允许匿名访问</span></span><br><span class="line">local_enable=YES <span class="comment"># 设定本地用户可以访问。注：如使用虚拟宿主用户，在该项目设定为NO的情况下所有虚拟用户将无法访问</span></span><br><span class="line">ascii_upload_enable=YES</span><br><span class="line">ascii_download_nable=YES <span class="comment"># 设定支持ASCII模式的上传和下载功能</span></span><br><span class="line">chroot_list_enable=YES <span class="comment"># 使用户不能离开主目录</span></span><br><span class="line">chroot_list_file=/etc/vsftpd/chroot_list <span class="comment"># 是否限制在主目录下的用户名单，至于是限制名单还是排除名单，这取决于chroot_local_user的值。</span></span><br><span class="line">pam_service_name=vsftpd <span class="comment"># PAM认证文件名。PAM将根据/etc/pam.d/vsftpd进行认证</span></span><br></pre></td></tr></table></figure></p><p>以下这些是关于vsftpd虚拟用户支持的重要配置项，默认<code>vsftpd.conf</code>中不包含这些设定项目，需要自己手动添加<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">guest_enable=YES <span class="comment"># 设定启用虚拟用户功能</span></span><br><span class="line">guest_username=ftp <span class="comment"># 指定虚拟用户的宿主用户，CentOS中已经有内置的ftp用户了</span></span><br><span class="line">user_config_dir=/etc/vsftpd/vuser_conf <span class="comment"># 设定虚拟用户个人vsftp的CentOS FTP服务文件存放路径。存放虚拟用户个性的CentOS FTP服务文件(配置文件名=虚拟用户名)</span></span><br></pre></td></tr></table></figure></p><h4 id="进行认证"><a href="#进行认证" class="headerlink" title="进行认证"></a>进行认证</h4><p>首先，安装Berkeley DB工具，很多人找不到db_load的问题就是没有安装这个包。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install db4 db4-utils</span><br></pre></td></tr></table></figure></p><p>然后，创建用户密码文本<code>/etc/vsftpd/vuser_passwd.txt</code> ，注意奇行是用户名，偶行是密码<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span></span><br><span class="line">123456</span><br></pre></td></tr></table></figure></p><p>接着，生成虚拟用户认证的db文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db_load -T -t <span class="built_in">hash</span> -f /etc/vsftpd/vuser_passwd.txt /etc/vsftpd/vuser_passwd.db</span><br></pre></td></tr></table></figure></p><p>随后，编辑认证文件<code>/etc/pam.d/vsftpd</code>，全部注释掉原来语句，再增加以下两句：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auth required pam_userdb.so db=/etc/vsftpd/vuser_passwd</span><br><span class="line">account required pam_userdb.so db=/etc/vsftpd/vuser_passwd</span><br></pre></td></tr></table></figure></p><p>最后，创建虚拟用户配置文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /etc/vsftpd/vuser_conf/</span><br><span class="line">vi /etc/vsftpd/vuser_conf/<span class="built_in">test</span> <span class="comment"># 文件名等于vuser_passwd.txt里面的账户名，否则下面设置无效</span></span><br></pre></td></tr></table></figure></p><p>内容如下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">local_root=/ftp/www <span class="comment"># 虚拟用户根目录,根据实际情况修改</span></span><br><span class="line">write_enable=YES <span class="comment"># 可写</span></span><br><span class="line">anon_umask=022 <span class="comment"># 掩码</span></span><br><span class="line">anon_world_readable_only=NO</span><br><span class="line">anon_upload_enable=YES</span><br><span class="line">anon_mkdir_write_enable=YES</span><br><span class="line">anon_other_write_enable=YES</span><br></pre></td></tr></table></figure></p><h4 id="设置Selinux"><a href="#设置Selinux" class="headerlink" title="设置Selinux"></a>设置Selinux</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setsebool -P ftp_home_dir=1 <span class="comment">#设置ftp可以使用home目录</span></span><br><span class="line">setsebool -P allow_ftpd_full_access=1 <span class="comment"># 设置ftp用户可以有所有权限</span></span><br></pre></td></tr></table></figure><h4 id="设置FTP根目录权限"><a href="#设置FTP根目录权限" class="headerlink" title="设置FTP根目录权限"></a>设置FTP根目录权限</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir /ftp/www <span class="comment"># 创建目录</span></span><br><span class="line">chmod -R 755 /ftp</span><br><span class="line">chmod -R 777 /ftp/www</span><br></pre></td></tr></table></figure><p>最新的vsftpd要求对主目录不能有写的权限所以ftp为755，主目录下面的子目录再设置777权限</p><h4 id="设置防火墙"><a href="#设置防火墙" class="headerlink" title="设置防火墙"></a>设置防火墙</h4><p>打开<code>/etc/sysconfig/iptables</code></p><p>在<code>-A INPUT –m state --state NEW –m tcp –p –dport 22 –j ACCEPT</code>，下添加：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-A INPUT -m state --state NEW -m tcp -p -dport 21 -j ACCEPT</span><br></pre></td></tr></table></figure></p><p>然后保存，并关闭该文件，在终端内运行下面的命令，刷新防火墙配置：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service iptables restart</span><br></pre></td></tr></table></figure></p><p>OK，运行<code>service vsftpd start</code>，你就可以访问你的FTP服务器了。</p><h3 id="配置PASV模式"><a href="#配置PASV模式" class="headerlink" title="配置PASV模式"></a>配置PASV模式</h3><p>vsftpd默认没有开启PASV模式，现在FTP只能通过PORT模式连接，要开启PASV默认需要通过下面的配置</p><p>打开<code>/etc/vsftpd/vsftpd.conf</code>，在末尾添加<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pasv_enable=YES <span class="comment"># 开启PASV模式</span></span><br><span class="line">pasv_min_port=40000 <span class="comment"># 最小端口号</span></span><br><span class="line">pasv_max_port=40080 <span class="comment"># 最大端口号</span></span><br><span class="line">pasv_promiscuous=YES</span><br></pre></td></tr></table></figure></p><p>在防火墙配置内开启40000到40080端口<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-A INPUT -m state --state NEW -m tcp -p -dport 40000:40080 -j ACCEPT</span><br></pre></td></tr></table></figure></p><p>重启iptabls和vsftpd<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">service iptables restart</span><br><span class="line">service vsftpd restart</span><br></pre></td></tr></table></figure></p><p>现在可以使用PASV模式连接你的FTP服务器了~</p><p>CentOS 7中默认使用Firewalld做防火墙，所以修改iptables后，在重启系统后，根本不管用。</p><p>Firewalld中添加端口方法如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=3306/tcp --permanent</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天老大让我搭建一个开源的发布项目叫瓦力，我打算在自己的虚拟机里面先进行测试，其中的一步需要我搭建一个FTP服务器，vsftpd在Linux下是比较有名的FTP服务器，我就来试试这个。&lt;/p&gt;
&lt;p&gt;实验环境： Centos 6.5&lt;/p&gt;
&lt;h3 id=&quot;安装vsftpd
      
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>git学习(4):自定义git</title>
    <link href="http://yoursite.com/2017/01/31/git%E5%AD%A6%E4%B9%A0(4)%E8%87%AA%E5%AE%9A%E4%B9%89git/"/>
    <id>http://yoursite.com/2017/01/31/git学习(4)自定义git/</id>
    <published>2017-01-31T07:17:21.000Z</published>
    <updated>2018-12-27T02:46:29.799Z</updated>
    
    <content type="html"><![CDATA[<h3 id="自定义git"><a href="#自定义git" class="headerlink" title="自定义git"></a>自定义git</h3><p>我们还可以自定义很多git的配置项，比如，让git显示颜色，这样可以让命令行更加醒目：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global color.ui <span class="literal">true</span></span><br></pre></td></tr></table></figure></p><h4 id="忽略特殊文件"><a href="#忽略特殊文件" class="headerlink" title="忽略特殊文件"></a>忽略特殊文件</h4><p>有的时候，我们有一些文件放在git工作目录中，但是我们又不想把这些文件上传到远程仓库，比如说生成的文件之类的。<br>我们可以在工作目录的根目录下创建一个<code>.gitignore</code>文件，在里面填写需要忽略的文件就可以了。最后，我们需要把<code>.gitignore</code>也推送到远程仓库。<br>忽略文件的原则是：<br>1.忽略操作系统自动生成的文件，比如缩略图等；<br>2.忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件；<br>3.忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。</p><h4 id="配置别名"><a href="#配置别名" class="headerlink" title="配置别名"></a>配置别名</h4><p>比如<code>git status</code>这个命令，我们想用<code>git st</code>来表示，我们可以使用如下命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global alias.st status</span><br></pre></td></tr></table></figure></p><p>同理，其他命令也可以这样处理。注意的是，<code>--config</code>是全局变量，对于这台计算机的当前用户，修改后的命令都通用。如果不加这个参数的话，修改后的命令只对当前仓库生效。每个仓库的配置文件都存放在<code>.git/config</code>里，而别名就在<code>[alias]</code>之后。当前用户的git配置文件则存放在用户主目录的<code>.gitconfig</code>里。如果想要修改别名，直接修改这两个配置文件也可以。</p><h4 id="搭建git服务器"><a href="#搭建git服务器" class="headerlink" title="搭建git服务器"></a>搭建git服务器</h4><p>把远程服务器托管到github上是一个不错的选择，但是如果我们不交钱的话，我们的项目所有人都可以访问，就很没有隐私。如果我们即想隐藏自己的项目，也不想给万恶的美帝交钱的话，自己搭建一个<code>git</code>服务器无疑是一个更好的选择。<br>我们前面说过，远程仓库其实和本地仓库是没有区别的，只是方便大家进行版本交换，所以搭建起来也很简单。我们需要一台<code>linux</code>系统的机器，搭建<code>git</code>服务器的话需要一台<code>linux</code>系统的机器，廖大推荐使用<code>buntu</code>或<code>Debian</code>，这样，通过几条<code>apt</code>命令就可以很快搭建了。<br>我们需要一个有<code>sudo</code>权限的账户，然后简单几步安装。<br>第一步，安装<code>git</code>：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure></p><p>d第二步，创建一个<code>git</code>账户，来运行<code>git</code>服务：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo adduser git</span><br></pre></td></tr></table></figure></p><p>第三步，创建证书登录：<br>把所有要推送到这个远程仓库的用户的公钥收集过来，就类似于在<code>github</code>中的ssh认证一样，放在<code>/home/git/.ssh/authorized_keys</code>文件里，一行一个。<br>第四步，初始化Git仓库：<br>需要一个文件夹作为<code>git</code>的仓库，假设是假定是<code>/srv/test.git</code>，在<code>/srv</code>目录下输入命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo git init --bare test.git</span><br></pre></td></tr></table></figure></p><p>这样子<code>git</code>会建立一个裸仓库，裸仓库是没有工作区的，所有<code>git</code>服务器不允许用户上来直接更改文件。而且服务器上的仓库通常以<code>.git</code>结尾。接下来我们把<code>owner</code>也改成<code>git</code>:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chown -R git:git test.git</span><br></pre></td></tr></table></figure></p><p>第五步，禁用shell登录：<br>为了安全，原则上，我们禁止<code>git</code>用户能通过<code>shell</code>登录。我们找到<code>/etc/passwd</code>文件，把其中的一行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git:x:1001:1001:,,,:/home/git:/bin/bash</span><br></pre></td></tr></table></figure></p><p>改成<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell</span><br></pre></td></tr></table></figure></p><p>这样处理之后，<code>git</code>用户只能通过<code>ssh</code>推送<code>git</code>，不能够通过<code>shell</code>登录到服务器。<br>这样子，<code>git</code>服务器就搭建好了，我们可以像使用<code>github</code>一样使用他了。</p><h4 id="管理公钥和权限"><a href="#管理公钥和权限" class="headerlink" title="管理公钥和权限"></a>管理公钥和权限</h4><p>廖大说，用<code>Gitosis</code>可以管理公钥。用<code>Gitolite</code>可以让<code>git</code>拥有像svn一样的权限。这两个我都还没有接触，暂且不表，等有机会的时候在尝试一下。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;自定义git&quot;&gt;&lt;a href=&quot;#自定义git&quot; class=&quot;headerlink&quot; title=&quot;自定义git&quot;&gt;&lt;/a&gt;自定义git&lt;/h3&gt;&lt;p&gt;我们还可以自定义很多git的配置项，比如，让git显示颜色，这样可以让命令行更加醒目：&lt;br&gt;&lt;figure
      
    
    </summary>
    
      <category term="git" scheme="http://yoursite.com/categories/git/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>git学习(3):分支和标签管理</title>
    <link href="http://yoursite.com/2017/01/30/git%E5%AD%A6%E4%B9%A0(3)%E5%88%86%E6%94%AF%E5%92%8C%E6%A0%87%E7%AD%BE%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2017/01/30/git学习(3)分支和标签管理/</id>
    <published>2017-01-30T08:58:11.000Z</published>
    <updated>2018-12-27T02:46:29.799Z</updated>
    
    <content type="html"><![CDATA[<h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><p>用了git的分支之后，只想狠狠地给他打个call，和svn的分支比起来，git简直快了指数呗。说起来，svn的分支功能，我基本没有使用过，因为实在是不太方便。<br>分支就像是两个平行宇宙，我在这个分支进行修改，并不会影响到另外一个分支。根据需要的话，修改完毕之后，可以将两个分支合并。分支在实际使用中具体表现在，如果我在开发一个新功能，只开发到一半。这个时候同事也想用这个代码库开发别的功能，但是开发到一半的代码库无疑会影响到新的开发。这个时候，如果你新建了一个分支，在自己的分支上做开发，别人就可以在原来的分支上开发，这样互不影响。都到都开发完毕了，再把两个分支合并，岂不美哉。</p><h4 id="创建与合并分支"><a href="#创建与合并分支" class="headerlink" title="创建与合并分支"></a>创建与合并分支</h4><p>通俗来讲，分支就像一个平行宇宙，每个平行宇宙都有一条时间线，我们每次<code>commit</code>就是串起了一条时间线。目前为止，我们只有一条时间线，即<code>master</code>分支。严格来讲，<code>HEAD</code>并不是指向提交，而是指向分支<code>master</code>，然后<code>master</code>才是指向提交。所以,<code>HEAD</code>指向的是当前分支。<br>我们可以这样理解，新建了一个分支，其实就是在<code>master</code>这条时间线的某个时间节点分出了两条平行的时间线，一条还是按<code>master</code>原有的轨迹行走，另一条就按另一个方向前进。我们将这个时间线，也就是分支命名为<code>dev</code>。<br>等到<code>dev</code>上的修改全部完成了，我们可以把<code>dev</code>这个分支和<code>master</code>分支合并。最简单的情况是这样的，如果<code>master</code>这个分支没有进行任何修改，那么我们可以直接将<code>master</code>指向<code>dev</code>这个分支。然后，我们就可以把<code>dev</code>这个分支删除了，其实也就是把<code>dev</code>的指针给删除掉。<br>接下来是实际操作：<br>我们要先创建一个分支，然后用<code>git checkout &lt;name&gt;</code>切换到这个分支，如果同时加上<code>-b</code>这个参数，就是创建的同时并切换分支：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b dev</span><br></pre></td></tr></table></figure></p><p>相当于相面两句代码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch dev</span><br><span class="line">git checkout dev</span><br></pre></td></tr></table></figure></p><p>同时，我们可以用<code>git branch</code>查看当前分支。<br>等到<code>dev</code>分支的修改都完成后，我们需要把<code>dev</code>上的东西合并到<code>master</code>。首先用<code>git checkout master</code>切换到<code>master</code>分支，然后输入：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge dev</span><br></pre></td></tr></table></figure></p><p><code>git merge</code>命令用于合并指定分支到当前分支。因为<code>master</code>没有修改，即是<code>Fast-forward</code>（快进模式）。直接把<code>master</code>指向<code>dev</code>的当前提交，所以速度非常地快。<br>合并完成以后，就可以删除<code>dev</code>分支了：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d dev</span><br></pre></td></tr></table></figure></p><p>如果要丢弃一个没有被合并过的分支，可以通过<code>git branch -D &lt;name&gt;</code>强行删除。</p><h4 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h4><p>但是现实使用中，<code>master</code>没有进行修改的情况是非常少见的。一般都是<code>dev</code>分支修改的同时，<code>master</code>分支也被修改了。这种情况下，我们就无法执行“快速合并”操作。如果我们在<code>master</code>分支运行<code>git merge dev</code>命令，git就会提示我们发生冲突，合并失败。<br>为了解决这种问题，我们必须先手动解决冲突后，再进行合并。我们使用<code>git status</code>可以查看冲突的文件，<br>在这条命令下，我们是可以看到冲突文件的内容的。Git用”&lt;&lt;&lt;&lt;&lt;&lt;&lt;”，”=======”，”&gt;&gt;&gt;&gt;&gt;&gt;&gt;”标记出不同分支的内容。我们手动修改工作区的冲突文件后，再合并，就成功了。<br>这时候，我们使用带参数的<code>git log</code>命令可以查看分支情况：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --graph --pretty=oneline --abbrev-commit</span><br></pre></td></tr></table></figure></p><p>最后，<code>git branch -d dev</code>删除<code>dev</code>分支。</p><h4 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h4><p>通常情况下，git会尽可能地使用<code>Fast forward</code>模式，但是这样操作的话，在删除分支之后，分支的信息就会丢失。如果我们想在分支删除以后还保留分支信息的话，可以加上<code>--no-ff</code>参数来强制禁用<code>Fast forward</code>模式。一般来说，能使用快进模式来合并分支的话，都是<code>master</code>没有更改的情况，所以接下来合并命令的前提是<code>master</code>分支没有更改，我们要把更改了的<code>dev</code>分支合并到<code>master</code>上：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge --no-ff -m <span class="string">"merge with no-ff"</span> dev</span><br></pre></td></tr></table></figure></p><p>参数<code>-m</code>后面跟的是这次合并的注释。<br>在实际开发中，我们要遵循以下几个原则：<br>1.<code>master</code>分支是一个非常稳定的分支，我们平时不应该在上面直接做修改。<br>2.平时我们应该都在<code>dev</code>分支上面做修改，比如我们要发布一个1.0新版本，应该在<code>dev</code>分支上完成1.0后，再合并到<code>master</code>分支。<br>3.每个小伙伴应该都有自己的<code>dev</code>分支，不要混用。</p><h4 id="bug分支"><a href="#bug分支" class="headerlink" title="bug分支"></a>bug分支</h4><p>很多情况下，我们的生产环境也就是<code>master</code>分支出现了bug，理论上，我们应该要新建一个<code>bug1</code>分支来修改bug，等到bug修复完成后，再把<code>bug1</code>合并到<code>master</code>分支。但是这个时候，我们手头的<code>dev</code>分支还在工作，而且只进行到一半。如果把工作到一半的<code>dev</code>分支合并到<code>master</code>，这当然是不可取的。写到一半的代码势必会影响到<code>master</code>的正常工作，这可如何是好。<br>不必惊慌，这个一个非常常见的情况，git也给了相应的处理措施。我们可以使用<code>git stash</code>命令来把工作现场给储存起来，等以后恢复工作现场继续工作。在使用了<code>git stash</code>后，再用<code>git status</code>来查看工作区，会发现工作区是干净的，这说明，<code>dev</code>分支被保存起来了。<br>接下来我们要修改<code>master</code>分支上的bug，我们需要先切换到<code>master</code>分支上，然后新建一个<code>bug1</code>分支：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git checkout -b bug1</span><br></pre></td></tr></table></figure></p><p>修复成功后，再切换到<code>master</code>分支，将<code>bug1</code>分支合并到<code>master</code>分支，然后删除：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git merge --no-ff -m <span class="string">"mix bug1"</span> bug1</span><br><span class="line">git branch -d bug1</span><br></pre></td></tr></table></figure></p><p>这样，bug就修复完毕了，我们要接着干活，所以我们想要恢复刚刚的<code>dev</code>工作现场,我们先切换回<code>dev</code>，然后用<code>git stash list</code>命令查看所有工作现场：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout dev</span><br><span class="line">git stash list</span><br></pre></td></tr></table></figure></p><p>恢复<code>stash</code>的命令有两种，一种是<code>git stash apply</code>，这种恢复后<code>stash</code>不会删除。要删除的话，可以使用<code>git stash pop</code>恢复。<br>如果我们之前进行了多次<code>stash</code>保存操作，恢复的时候可以用<code>git stash list</code>查看，然后恢复指定<code>stash</code>:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash apply stash@&#123;0&#125;</span><br></pre></td></tr></table></figure></p><h4 id="多人协助"><a href="#多人协助" class="headerlink" title="多人协助"></a>多人协助</h4><p>在进行多人共同开发一个项目的时候，不可避免要使用到远程仓库了。当我们从远程仓库克隆的时候，其实git已经把我们本地工作目录的<code>master</code>和远程<code>master</code>关联起来了，而且远程仓库的默认名称是<code>origin</code>，我们可以使用<code>git remote</code>来查看远程仓库的信息，加上<code>-v</code>参数可以让信息更加详细。<br>要推送分支到远程的命令是：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin 分支名</span><br></pre></td></tr></table></figure></p><p>当我们从远程仓库<code>git clone git@github.com:用户名/仓库名.git</code>克隆时，默认情况下，我们只能看到<code>master</code>分支，别的分支是么有的。如果我们要在本地的<code>dev</code>上开发，在本地创建和远程分支对应的分支:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b dev origin/dev</span><br></pre></td></tr></table></figure></p><p>这个时候，我们就可以在本地修改<code>dev</code>分支，然后快乐地推送到远程了。<br>但是我们有一个很烦人的小伙伴，我们叫他小辉，小辉现在也在本地修改<code>dev</code>分支，然后也推送了版本到远程仓库。<br>如果我们恰好修改了同一个文件，我在小辉之后推送的话，就会报错，那是因为我们文件内容冲突了。解决这个方法其实也很简单，我们可以使用<code>git pull</code>命令把最新的提交从<code>origin/dev</code>上抓下来，解决冲突再合并就OK了。可是我们再次<code>git pull</code>的时候还是报错了，提示<code>no tracking information</code>,这是因为本地的<code>dev</code>没有关联到远程，使用命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch --<span class="built_in">set</span>-upstream dev origin/dev</span><br></pre></td></tr></table></figure></p><h3 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h3><h4 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h4><p>每个标签<code>tags</code>都是和一个<code>commit</code>绑定在一起的，他的优势就是，容易记住。因为<code>commit</code>都是一大串数字，而<code>tags</code>是可以自定义的，所以就很…ok。<br>创建标签非常简单，我们需要切换到要打标签的分支,然后是用<code>git tag &lt;name&gt;</code>就可以打一个标签。默认标签是打在刚提交的<code>commit</code>上的。但是小辉非要给以前的<code>commit</code>打标签，好吧，这也是可以的。我们只要使用命令找到历史提交的<code>commit id</code>就可以了：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --pretty=oneline --abbrev-commit</span><br><span class="line">git tag &lt;name&gt; commitid</span><br></pre></td></tr></table></figure></p><p> 我们可以使用<code>git tag</code>查看标签,使用<code>git show &lt;tagname&gt;</code>查看标签信息。还可以创建带有说明的标签，用<code>-a</code>指定标签名，<code>-m</code>指定说明文字：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -a &lt;name&gt; -m <span class="string">"tagv1.0"</span> commitid</span><br></pre></td></tr></table></figure></p><p>还可以通过-s用私钥签名一个标签：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -s v2.0 -m <span class="string">"tagv2.0"</span> commitid</span><br></pre></td></tr></table></figure></p><h4 id="操作标签"><a href="#操作标签" class="headerlink" title="操作标签"></a>操作标签</h4><p>如果标签打错了，我们也可以删除：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -d &lt;tagname&gt;</span><br></pre></td></tr></table></figure></p><p>这些操作都是在本地的，所有不用担心影响到远程仓库，如果我们想把标签推送到远程仓库，可以推送一个本地标签：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin &lt;tagname&gt;</span><br></pre></td></tr></table></figure></p><p>也可以一次性推送所有未推送标签:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin --tags</span><br></pre></td></tr></table></figure></p><p>如果推送到远程以后，发现标签错了，想要删除，也可以：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git tag -d &lt;tagname&gt;</span><br><span class="line">git push origin:refs/tags/&lt;tagname&gt;</span><br></pre></td></tr></table></figure></p><p>成功删除。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;分支管理&quot;&gt;&lt;a href=&quot;#分支管理&quot; class=&quot;headerlink&quot; title=&quot;分支管理&quot;&gt;&lt;/a&gt;分支管理&lt;/h3&gt;&lt;p&gt;用了git的分支之后，只想狠狠地给他打个call，和svn的分支比起来，git简直快了指数呗。说起来，svn的分支功能，我基
      
    
    </summary>
    
      <category term="git" scheme="http://yoursite.com/categories/git/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>git学习(2):git版本库管理</title>
    <link href="http://yoursite.com/2017/01/29/git%E5%AD%A6%E4%B9%A0(2)git%E7%89%88%E6%9C%AC%E5%BA%93%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2017/01/29/git学习(2)git版本库管理/</id>
    <published>2017-01-29T03:06:49.000Z</published>
    <updated>2018-12-27T02:46:29.798Z</updated>
    
    <content type="html"><![CDATA[<p>之前我们已经成功提交了一个<code>readme.txt</code>文件,接下来，可以对这个文件进行修改，然后运行<code>git status</code>命令可以看到结果，这个命令可以让我们随时掌握仓库的状态，如果我们要看看具体改了哪些内容，可以使用<code>git diff</code>这个命令来查看。然后如果要将修改的文件进行提交的话，操作就和之前的一样了。</p><h3 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h3><h4 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h4><p>git的版本回退就类似于快照，每次我们<code>commit</code>之后，就在版本库给我们建立一个快照。如果我们把文件误删了，或者搞混了，就可以从最近的一<code>commit</code>恢复。<br>我们使用<code>git log</code>这个命令可以查看我们的历史记录，如果觉得输出太多，可以加上<code>--pretty=oneline</code>参数来提取<code>commit id</code>。这里需要注意的是，git的版本号和svn不一样，并不是1,2,3….这样递增的数字，而是一个通过SHA1计算得到的非常大的数字，并且用十六进制表示，这样可以从很大程度上避免版本号的冲突。<br>现在，我们要开始进行版本回退，git必须知道当前版本，用<code>HEAD</code>表示当前版本，上一个版本就是<code>HEAD^</code>，再上一个版本就是<code>HEAD^^</code>，如果往上100个版本就写做<code>HEAD~100</code>。<br>所以我们要回退到上一个版本的命令就是：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git resrt --hard HEAD^</span><br></pre></td></tr></table></figure></p><p>如果我们知道<code>commit id</code>的话，我也可以直接使用<code>commit id</code>，比如id是<code>123456....</code>，就是：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard 123456</span><br></pre></td></tr></table></figure></p><p>版本号没必要写全，写前面几位就可以了。<br>如果我们忘记了摸个版本的<code>commit id</code>，我们可以使用<code>git reflog</code>来查看之前的历史命令，这样也可以查看到之前的<code>commit id</code>。<br>git和svn相比，多了一个暂存区的概念。</p><h4 id="工作区"><a href="#工作区" class="headerlink" title="工作区"></a>工作区</h4><p>工作区的通俗来理解，应该就是我们的工作目录，也就是文件的目录。</p><h4 id="版本库"><a href="#版本库" class="headerlink" title="版本库"></a>版本库</h4><p>在工作区里有一个名为<code>.git</code>的隐藏目录，这个就是git的版本库。其中比较重要的就是被称为stage的暂存区，以及创建工作区是自动生成的<code>master</code>分支，以及指向<code>master</code>的名为<code>HEAD</code>的指针。<br>之前我们提交的两步操作:<br>第一步，<code>git add</code>就是将文件修改添加到暂存区。<br>第二步，<code>git commit</code>就是 将文件修改<strong>一次性</strong>从暂存区提交到分支。</p><h4 id="管理修改"><a href="#管理修改" class="headerlink" title="管理修改"></a>管理修改</h4><p>接下来我们需要了解到的是，git跟踪的是修改，而不是文件。<br>举个栗子，我们修改了一个名为<code>readme.txt</code>的文件，先用<code>git add readme.txt</code>添加到暂存区，然后再次修改这个文件，最后用<code>git commit</code>提交到分支。这个时候我们用<code>git status</code>查看状态，可以发现，第二次修改并没有被提交。<br>这是因为，第一次修改之后，我们使用了<code>git add</code>将修改添加到了暂存区，第二次修改却没有这样操作，所以<code>git commit</code>并不会将第二次修改提交到分支。如果我们想把第二次修改也提交到分支的话，可以在第二次修改之后，再次使用<code>git add readme.txt</code>，这样就可以一起提交了。<br>如果我们想查看工作区和版本库之间的差别的话，可以使用：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff HEAD -- readme.txt</span><br></pre></td></tr></table></figure></p><h4 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h4><p>如果发现工作区的文件在我们修改之后有错误，想把他恢复到上一个版本的状态。可以使用<code>git checkout -- readme.txt</code>来丢弃工作区的修改。<br>这里分成两种情况:<br>第一种，<code>readme.txt</code>修改之后没有提交到暂存区，这时候撤销修改就恢复到版本库里的状态。<br>第二种，<code>readme.txt</code>修改之后提交到了暂存区，撤销修改就恢复到提交到暂存区时的状态。<br>如果我们的修改在提交到暂存区之后才发现错误，这个时候要修改的话。我们需要先使用<code>git reset HEAD readme.txt</code>把暂存区的修改撤销掉，重新放回工作区。然后按之前修改工作区的文件的步骤进行。</p><h4 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h4><p>当我们在工作区删除了一个文件之后，希望在版本库中也删除这个文件。我们先用<code>git status</code>查看状态，git会非常人性化地提示我们，版本库和工作区不一致，并且告诉我们哪个文件不一致。而且，他会给我们两个选择：<br>一个是要从版本库里面也删除这个文件，我们可以使用<code>git rm readme.txt</code>来删除，然后用<code>git commit</code>提交。这样，版本库里的文件也被删除了。<br>另一个是删错了，我们想要恢复工作区的文件，我们可以使用<code>git checkout -- readme.txt</code>来将误删的文件恢复到最新版本。</p><h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3><p>说到远程仓库，首选当然是代码圈大型交友平台github啦，嘿嘿。</p><h4 id="添加SSH"><a href="#添加SSH" class="headerlink" title="添加SSH"></a>添加SSH</h4><p>我们想要把本地版本库和github上面的仓库关联起来，是通过SSH协议的。只需要两步就可以实现这个：<br>第一步，在主目录下查看是否拥有<code>.ssh</code>文件夹，如果有，再看看是否有<code>id_rsa</code>和<code>id_rsa.pub</code>，其中<code>id_rsa</code>是私钥，<code>id_rsa.pub</code>是公钥。有的话就可以进行第二步了，没有的话，就打开shell窗口，执行以下代码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -keygen -t rsa -C <span class="string">"youemail@address.com"</span></span><br></pre></td></tr></table></figure></p><p>在<code>.ssh</code>里生成上面的公钥和私钥。<br>第二步，在github里打开Account settings，SSH Keys页面，然后，点Add SSH Key，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容。</p><h4 id="添加远程库"><a href="#添加远程库" class="headerlink" title="添加远程库"></a>添加远程库</h4><p>先在github上建立一个<code>repository</code>,然后在本地工作区打开shell，运行命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:用户名/仓库名.git</span><br></pre></td></tr></table></figure></p><p>添加以后，远程仓库就叫<code>origin</code>,这个是git的默认叫法，也可以改成别的。<br>接下来，可以使用<code>git push</code>来讲本地版本库推送到远程仓库。第一次推送的时候，加上<code>-u</code>参数，git会把本地<code>master</code>分支推送到远程<code>master</code>分支，还会将两者关联起来。如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure></p><p>这样，github上也有了和本地一模一样的内容了。<br>以后在本地修改，只要通过命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure></p><p>就可以把本地最新的<code>master</code>分支推送到github了。</p><h4 id="从远程仓库克隆"><a href="#从远程仓库克隆" class="headerlink" title="从远程仓库克隆"></a>从远程仓库克隆</h4><p>在一个空的文件夹，执行命令:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:用户名/仓库名.git</span><br></pre></td></tr></table></figure></p><p>将远程仓库克隆到本地。<br>Git支持多种协议，包括<code>https</code>，但通过<code>ssh</code>支持的原生git协议速度最快</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前我们已经成功提交了一个&lt;code&gt;readme.txt&lt;/code&gt;文件,接下来，可以对这个文件进行修改，然后运行&lt;code&gt;git status&lt;/code&gt;命令可以看到结果，这个命令可以让我们随时掌握仓库的状态，如果我们要看看具体改了哪些内容，可以使用&lt;code&gt;g
      
    
    </summary>
    
      <category term="git" scheme="http://yoursite.com/categories/git/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>git学习(1):git介绍并创建版本库</title>
    <link href="http://yoursite.com/2017/01/28/git%E5%AD%A6%E4%B9%A0(1)git%E4%BB%8B%E7%BB%8D%E5%B9%B6%E5%88%9B%E5%BB%BA%E7%89%88%E6%9C%AC%E5%BA%93/"/>
    <id>http://yoursite.com/2017/01/28/git学习(1)git介绍并创建版本库/</id>
    <published>2017-01-28T08:19:56.000Z</published>
    <updated>2018-12-27T02:46:29.798Z</updated>
    
    <content type="html"><![CDATA[<p>关于版本控制系统，我们公司目前用的是集中式的svn。集中式的版本控制系统就类似于一个图书馆，有一个寄存版本库的中央服务器。如果我们要修改代码的话，需要先从中央服务器获取最新版本，修改完再推送会中央服务器。就像从图书馆借一本书出来带回家，在家里改完了再还给图书馆。<br>而git就是分布式版本控制系统的代表。分布式的就没有中央服务器的概念，每个人的电脑上都是一个完整的版本库。如果我在电脑上更改了一个文件，另一个人也同时更改了这个文件，我们俩只要相互推送，就可以看到对方更改的地方。<br>这样两者相比起来，分布式的版本控制系统就有更高的安全性。如果是集中式的，中央服务器挂了，那整个版本库就没了。<br>值得一提的是，分布式版本控制系统其实也很少在两人之间的电脑上推送版本库的修改，一般也有一台电脑来充当“中央服务器”，这台电脑仅仅是为了方便大家交换版本修改，没有这台机器的话，大家也能照常干活。<br>但是svn最大的缺点还是他需要联网，如果在局域网内，如果带宽更大，其实也还好。但是如果在互联网上，网速慢就很坑爹了，而git就没有这方面的烦恼。于此同时，git的分支管理也异常强大。<br>在这里，我要手动感谢廖雪峰廖大，他的git教程写得通俗易懂。（ps.他的python教程我也在看，当字典用不错，推荐一下。）<br>git 是linux之父开发的，所以一开始，git也只能在linux和Unix系统上运行。随着时间的迁移，当然就会有好汉觉得，这么好用的东西，我win上面怎么可以不能用呢，于是，现在我们在windows上也可以运行git啦。</p><h3 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h3><h4 id="linux上安装"><a href="#linux上安装" class="headerlink" title="linux上安装"></a>linux上安装</h4><p>首先输入<code>git</code>查看系统是否安装，如果没有的话，很多linux系统都会提示我们如何安装的。<br>一般输入<code>sudo apt-get install git</code>就可以安装git</p><h4 id="windows上安装"><a href="#windows上安装" class="headerlink" title="windows上安装"></a>windows上安装</h4><p>百度git去官网下载一个exe，无脑下一步就可以啦。</p><h3 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h3><p>版本库就像一个仓库，在我们电脑里，可以理解成一个目录。里面所有文件的修改删除，git都能跟踪，我们可以在任何时刻追踪历史，进行还原。<br>通过<code>git init</code>命令可以把一个目录变成可以管理的仓库：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure></p><p>这样，我们就建立起了一个版本仓库，并且在当前目录下，多了一个.git的隐藏文件夹，这个文件夹是用来跟踪管理git版本库的，千万不要手贱去修改这个里面的文件。</p><h3 id="把文件添加到版本库"><a href="#把文件添加到版本库" class="headerlink" title="把文件添加到版本库"></a>把文件添加到版本库</h3><p>新建一个read.txt后，将文件添加到版本库，只需要两步：<br>第一步，用命令<code>git add</code>，将文件添加到仓库：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add readme.txt</span><br></pre></td></tr></table></figure></p><p>第二步，用命令<code>git commit</code>，将文件提交到仓库,<code>-m</code>后面是对这次提交的说明:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">"bulid readme.txt"</span></span><br></pre></td></tr></table></figure></p><p>注意的是，<code>commit</code>一次可以提交很多文件，所以我们可以多次<code>add</code>不同的文件，然后一次性<code>commit</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;关于版本控制系统，我们公司目前用的是集中式的svn。集中式的版本控制系统就类似于一个图书馆，有一个寄存版本库的中央服务器。如果我们要修改代码的话，需要先从中央服务器获取最新版本，修改完再推送会中央服务器。就像从图书馆借一本书出来带回家，在家里改完了再还给图书馆。&lt;br&gt;而g
      
    
    </summary>
    
      <category term="git" scheme="http://yoursite.com/categories/git/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>sqlserver中DATEADD和DATEDIFF的用法示例介绍</title>
    <link href="http://yoursite.com/2016/12/21/MSSQL%E4%B8%ADDATEADD%E5%92%8CDATEDIFF%E7%9A%84%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B%E4%BB%8B%E7%BB%8D/"/>
    <id>http://yoursite.com/2016/12/21/MSSQL中DATEADD和DATEDIFF的用法示例介绍/</id>
    <published>2016-12-21T06:18:23.000Z</published>
    <updated>2018-12-27T02:46:29.798Z</updated>
    
    <content type="html"><![CDATA[<p>DATEDIFF函数是用于计算两个日期之间的小时、天、周、月、年等时间的间隔。DATEADD函数通过给定时间间隔对一个日期进行加减来获得一个新的日期。<br>一个月的第一天<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> <span class="keyword">DATEADD</span>(mm, <span class="keyword">DATEDIFF</span>(mm,<span class="number">0</span>,<span class="keyword">getdate</span>()), <span class="number">0</span>)</span><br></pre></td></tr></table></figure></p><p>本周的星期一<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> <span class="keyword">DATEADD</span>(wk, <span class="keyword">DATEDIFF</span>(wk,<span class="number">0</span>,<span class="keyword">getdate</span>()), <span class="number">0</span>)</span><br></pre></td></tr></table></figure></p><p>一年的第一天<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> <span class="keyword">DATEADD</span>(yy, <span class="keyword">DATEDIFF</span>(yy,<span class="number">0</span>,<span class="keyword">getdate</span>()), <span class="number">0</span>)</span><br></pre></td></tr></table></figure></p><p>季度的第一天<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> <span class="keyword">DATEADD</span>(qq, <span class="keyword">DATEDIFF</span>(qq,<span class="number">0</span>,<span class="keyword">getdate</span>()), <span class="number">0</span>)</span><br></pre></td></tr></table></figure></p><p>当天的半夜<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> <span class="keyword">DATEADD</span>(dd, <span class="keyword">DATEDIFF</span>(dd,<span class="number">0</span>,<span class="keyword">getdate</span>()), <span class="number">0</span>)</span><br></pre></td></tr></table></figure></p><p>上个月的最后一天<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> <span class="keyword">dateadd</span>(ms,<span class="number">-3</span>,<span class="keyword">DATEADD</span>(mm, <span class="keyword">DATEDIFF</span>(mm,<span class="number">0</span>,<span class="keyword">getdate</span>()), <span class="number">0</span>))</span><br></pre></td></tr></table></figure></p><p>去年的最后一天<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> <span class="keyword">dateadd</span>(ms,<span class="number">-3</span>,<span class="keyword">DATEADD</span>(yy, <span class="keyword">DATEDIFF</span>(yy,<span class="number">0</span>,<span class="keyword">getdate</span>()), <span class="number">0</span>))</span><br></pre></td></tr></table></figure></p><p>本月的最后一天<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> <span class="keyword">dateadd</span>(ms,<span class="number">-3</span>,<span class="keyword">DATEADD</span>(mm, <span class="keyword">DATEDIFF</span>(m,<span class="number">0</span>,<span class="keyword">getdate</span>())+<span class="number">1</span>, <span class="number">0</span>))</span><br></pre></td></tr></table></figure></p><p>本年的最后一天<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> <span class="keyword">dateadd</span>(ms,<span class="number">-3</span>,<span class="keyword">DATEADD</span>(yy, <span class="keyword">DATEDIFF</span>(yy,<span class="number">0</span>,<span class="keyword">getdate</span>())+<span class="number">1</span>, <span class="number">0</span>))</span><br></pre></td></tr></table></figure></p><p>本月的第一个星期一<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">DATEADD</span>(wk,<span class="keyword">DATEDIFF</span>(wk,<span class="number">0</span>,<span class="keyword">dateadd</span>(dd,<span class="number">6</span><span class="keyword">datepart</span>(<span class="keyword">day</span>,<span class="keyword">getdate</span>()),<span class="keyword">getdate</span>())), <span class="number">0</span>)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;DATEDIFF函数是用于计算两个日期之间的小时、天、周、月、年等时间的间隔。DATEADD函数通过给定时间间隔对一个日期进行加减来获得一个新的日期。&lt;br&gt;一个月的第一天&lt;br&gt;&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cl
      
    
    </summary>
    
      <category term="sqlserver" scheme="http://yoursite.com/categories/sqlserver/"/>
    
    
      <category term="sqlserver" scheme="http://yoursite.com/tags/sqlserver/"/>
    
  </entry>
  
  <entry>
    <title>sqlserver float 转 varchar 防止科学计数法</title>
    <link href="http://yoursite.com/2016/12/20/sqlserver-float-%E8%BD%AC-varchar-%E9%98%B2%E6%AD%A2%E7%A7%91%E5%AD%A6%E8%AE%A1%E6%95%B0%E6%B3%95/"/>
    <id>http://yoursite.com/2016/12/20/sqlserver-float-转-varchar-防止科学计数法/</id>
    <published>2016-12-20T04:44:34.000Z</published>
    <updated>2018-12-27T02:46:29.803Z</updated>
    
    <content type="html"><![CDATA[<p>今天给同事处理数据需求的时候，发现了一个问题，直接将Float转化成Varchar，生成的字符串是科学计数法。研究了一下发现，用Cast转换两次即可。<br>Float—&gt;&gt;Decimal—&gt;&gt;Varchar<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">cast</span>(<span class="keyword">cast</span>(字段 <span class="keyword">as</span> <span class="built_in">decimal</span>(<span class="number">18</span>,<span class="number">0</span>)) <span class="keyword">as</span> <span class="built_in">varchar</span>)</span><br></pre></td></tr></table></figure></p><p>哇咔咔</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天给同事处理数据需求的时候，发现了一个问题，直接将Float转化成Varchar，生成的字符串是科学计数法。研究了一下发现，用Cast转换两次即可。&lt;br&gt;Float—&amp;gt;&amp;gt;Decimal—&amp;gt;&amp;gt;Varchar&lt;br&gt;&lt;figure class=&quot;hi
      
    
    </summary>
    
      <category term="sqlserver" scheme="http://yoursite.com/categories/sqlserver/"/>
    
    
      <category term="sqlserver" scheme="http://yoursite.com/tags/sqlserver/"/>
    
  </entry>
  
  <entry>
    <title>pymongo的基本操作</title>
    <link href="http://yoursite.com/2016/12/14/pymongo%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2016/12/14/pymongo的基本操作/</id>
    <published>2016-12-14T05:56:18.000Z</published>
    <updated>2018-12-27T02:46:29.800Z</updated>
    
    <content type="html"><![CDATA[<p>前几天写了个简单爬虫爬取了58的数据，今天想要把他和<code>Mongodb</code>数据库连接起来。</p><h3 id="Windows平台安装Mongodb"><a href="#Windows平台安装Mongodb" class="headerlink" title="Windows平台安装Mongodb"></a>Windows平台安装Mongodb</h3><h4 id="Mongodb下载"><a href="#Mongodb下载" class="headerlink" title="Mongodb下载"></a>Mongodb下载</h4><p>首先去<code>Mongodb</code>官网下载一个MongoDB 预编译二进制包，<a href="https://www.mongodb.com/download-center#community" target="_blank" rel="noopener">下载地址</a>。</p><h4 id="创建数据目录"><a href="#创建数据目录" class="headerlink" title="创建数据目录"></a>创建数据目录</h4><p><code>Mongodb</code>将数据存储在<code>db</code>目录下，但是这个数据目录不会自己创建，我们需要在安装完成后创建它。(注意，数据目录要放在根目录下。比如<code>C:\</code>和<code>D:\</code>)<br>我们创建一个<code>db\data\</code>目录。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /d D:\</span><br><span class="line">mkdir data\db\</span><br></pre></td></tr></table></figure></p><h4 id="配置Mongodb服务"><a href="#配置Mongodb服务" class="headerlink" title="配置Mongodb服务"></a>配置Mongodb服务</h4><p>先在<code>data</code>目录下再创建一个<code>long</code>文件夹：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir data\log\</span><br></pre></td></tr></table></figure></p><p>然后在<code>Mongodb</code>目录文件下再创建一个配置文件<code>C:\mongodb\mongod.cfg</code>,其中指定 <code>systemLog.path</code>和<code>storage.dbPath</code>。具体配置如下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">systemLog:</span><br><span class="line">    destination: file #注意是四个空格不是Tab</span><br><span class="line">    path: D:\data\log\mongod.log</span><br><span class="line">storage:</span><br><span class="line">    dbPath: D:\data\db</span><br></pre></td></tr></table></figure></p><h4 id="安装Mongodb服务"><a href="#安装Mongodb服务" class="headerlink" title="安装Mongodb服务"></a>安装Mongodb服务</h4><p>通过执行<code>mongod.exe</code>，使用<code>--install</code>选项来安装服务，使用<code>--config</code>选项来指定之前创建的配置文件。这样我们可以开机自动启动<code>Mongodb</code>服务了。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"D:\mongodb\bin\mongod.exe" --config "D:\mongodb\mongod.cfg" --install</span><br></pre></td></tr></table></figure></p><p>然后启动<code>Mongodb</code>服务：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net start MongoDB</span><br></pre></td></tr></table></figure></p><p>完成，这时候，运行<code>Mongodb</code>目录下的<code>mongo.exe</code>，就可以进入交互模式了。</p><h3 id="pymongo基本操作"><a href="#pymongo基本操作" class="headerlink" title="pymongo基本操作"></a>pymongo基本操作</h3><p>首先导入<code>pymongo</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymongo</span><br></pre></td></tr></table></figure></p><h4 id="创建连接"><a href="#创建连接" class="headerlink" title="创建连接"></a>创建连接</h4><p>指定<code>host</code>及<code>port</code>参数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client = pymongo.MongoClient(<span class="string">'localhost'</span>,<span class="number">27017</span>)</span><br></pre></td></tr></table></figure></p><p>或者这样<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client = pymongo.MongoClient(<span class="string">'mongodb://localhost:27017/'</span>)</span><br></pre></td></tr></table></figure></p><h4 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tongcheng = client.tongcheng</span><br></pre></td></tr></table></figure><p>或者<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tongcheng = client[<span class="string">'tongcheng'</span>]</span><br></pre></td></tr></table></figure></p><h4 id="连接聚集"><a href="#连接聚集" class="headerlink" title="连接聚集"></a>连接聚集</h4><p>相当于关系型数据库中的表<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tongchengsheet = tongcheng.tongchengsheet</span><br></pre></td></tr></table></figure></p><p>或者<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tongchengsheet = tongcheng[<span class="string">'tongchengsheet'</span>]</span><br></pre></td></tr></table></figure></p><p>查看数据库下面所有的聚集<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tongcheng.collection_names()</span><br></pre></td></tr></table></figure></p><h4 id="插入记录"><a href="#插入记录" class="headerlink" title="插入记录"></a>插入记录</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">data = &#123;</span><br><span class="line">  <span class="string">'name'</span>:name</span><br><span class="line">  ,<span class="string">'age'</span>:age</span><br><span class="line">  ,<span class="string">'city'</span>:city</span><br><span class="line">&#125;</span><br><span class="line">tongchengsheet.insert(data)</span><br></pre></td></tr></table></figure><p>注意，这里插入的一定是一个字典。</p><h4 id="按条件删除记录"><a href="#按条件删除记录" class="headerlink" title="按条件删除记录"></a>按条件删除记录</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tongchengsheet.remove(&#123;<span class="string">'name'</span>:name&#125;)</span><br></pre></td></tr></table></figure><p>即为删除<code>name</code>值为“name”的记录。</p><h4 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tongchengsheet.update(&#123;<span class="string">'name'</span>:name&#125;,&#123;<span class="string">'$set'</span>:&#123;<span class="string">'age'</span>:age,<span class="string">'city'</span>:city&#125;&#125;)</span><br></pre></td></tr></table></figure><p>即为把<code>name</code>条件为“name”的行，<code>age</code>和<code>city</code>字段改成设定的值。这样只会修改发现的第一条数据，如果想修改所有的文档，需要把<code>multi</code>参数改成<code>true</code>。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tongchengsheet.update(&#123;<span class="string">'name'</span>:name&#125;,&#123;<span class="string">'set'</span>:&#123;<span class="string">'age'</span>:age,<span class="string">'city'</span>:city&#125;&#125;,&#123;<span class="string">'multi'</span>:true&#125;)</span><br></pre></td></tr></table></figure></p><h4 id="查找数据"><a href="#查找数据" class="headerlink" title="查找数据"></a>查找数据</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#find_one()查询一条数据，不带参数则返回第一条，带参数则按条件查找</span></span><br><span class="line">tongchengsheet.find_one()</span><br><span class="line">tongchengsheet.find_one(&#123;<span class="string">'name'</span>:name&#125;)</span><br><span class="line"><span class="comment">#find_one()查询所有数据，不带参数则返回所有数据，带参数则按条件查找</span></span><br><span class="line">tongchengsheet.find()</span><br><span class="line">tongchengsheet.find(&#123;<span class="string">'name'</span>:name&#125;)</span><br></pre></td></tr></table></figure><p>可以用<code>count()</code>方法查看聚集数据数量,<code>limit()</code>方法限制条数<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tongchengsheet.find().count()</span><br><span class="line"><span class="comment">#查看前n条</span></span><br><span class="line">tongchengsheet.find().limit(n)</span><br></pre></td></tr></table></figure></p><p>类似于关系型数据库的<code>ORDER BY</code>,我们同样可以使用<code>sort()</code>函数来排序<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#默认升序</span></span><br><span class="line">tongchengsheet.find().sort(<span class="string">'name'</span>)</span><br><span class="line"><span class="comment">#ASCENDING为升序</span></span><br><span class="line">tongchengsheet.find().sort(<span class="string">'name'</span>,pymongo.ASCENDING)</span><br><span class="line"><span class="comment">#DESCENDING为降序</span></span><br><span class="line">tongchengsheet.find().sort(<span class="string">'name'</span>,pymongo.DESCENDING)</span><br><span class="line"><span class="comment">#多字段排序</span></span><br><span class="line">tongchengsheet.find().sort([(<span class="string">'name'</span>,pymongo,ASCENDING),(<span class="string">'age'</span>,pymongo.DESCENDING)])</span><br></pre></td></tr></table></figure></p><h4 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h4><p>其他操作以后用到再补充。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前几天写了个简单爬虫爬取了58的数据，今天想要把他和&lt;code&gt;Mongodb&lt;/code&gt;数据库连接起来。&lt;/p&gt;
&lt;h3 id=&quot;Windows平台安装Mongodb&quot;&gt;&lt;a href=&quot;#Windows平台安装Mongodb&quot; class=&quot;headerlink&quot; t
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="pymongo" scheme="http://yoursite.com/tags/pymongo/"/>
    
      <category term="爬虫" scheme="http://yoursite.com/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>openvpn 连接提示CreateFile failed on TAP device</title>
    <link href="http://yoursite.com/2016/12/14/openvpn-%E8%BF%9E%E6%8E%A5%E6%8F%90%E7%A4%BACreateFile-failed-on-TAP-device/"/>
    <id>http://yoursite.com/2016/12/14/openvpn-连接提示CreateFile-failed-on-TAP-device/</id>
    <published>2016-12-14T04:38:54.000Z</published>
    <updated>2018-12-27T02:46:29.800Z</updated>
    
    <content type="html"><![CDATA[<p>今天一大早有同事反映VPN连接不上，老大就让我去检查一下，我一个小虾米刚用VPN还不到1个月，着实有些为难啊，只能硬着头皮上了。</p><p>打开log一看，发现报错<code>CreateFile failed on TAP device</code>，遂百度，成功得到解决方法。</p><p>记录一下</p><p>1.关闭OpenVPN客户端<br>2.进入OpenVPN安装目录\bin<br>3.运行deltapall.bat，并按提示执行完成<br>4.运行addtap.bat，并按提示执行完成<br>5.重新运行OpenVPN客户端，完成连接即可</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天一大早有同事反映VPN连接不上，老大就让我去检查一下，我一个小虾米刚用VPN还不到1个月，着实有些为难啊，只能硬着头皮上了。&lt;/p&gt;
&lt;p&gt;打开log一看，发现报错&lt;code&gt;CreateFile failed on TAP device&lt;/code&gt;，遂百度，成功得到
      
    
    </summary>
    
      <category term="PC" scheme="http://yoursite.com/categories/PC/"/>
    
    
      <category term="PC" scheme="http://yoursite.com/tags/PC/"/>
    
  </entry>
  
</feed>
