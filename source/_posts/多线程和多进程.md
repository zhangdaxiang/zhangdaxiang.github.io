---
title: 多线程和多进程
date: 2018-06-10 23:08:13
tags: [python,threading,multiprocessing]
categories: python
---

## threading模块
### 线程对象的创建
#### Thread类直接创建
```python
import threading
import time

def countNum(n): #定义线程需要运行的函数
	print("running on number:%s"%n)
	time.sleep(3)
	
if __name__ == '__main__':
	t1 = threading.Thread(target=countNum,args=(23,))
	t2 = threading.Thread(target=countNum,args=(24,))
	
	t1.start() #启动进程
	t2.start() 
	print("ending!")
```
#### Thread类继承式创建
```python
import threading
import time

class MyThread(threading.Thread):
	
	def __init__(self,num):
		threading.Thread.__init__(self)
		self.num = num
	def run(self):
		print("running on number:%s"%self.num)
		time.sleep(3)
		
t1=MyThread(56) #即实例化MyThread
t2=MyThread(78)

t1.start() #即调用实例对象的run()方法
t2.start() 

print("ending!")
```
### Thread类的实例方法
#### join()和setDaemon()方法
```python
# join()：在子线程完成运行之前，这个子线程的父线程将一直被阻塞。
# setDaemon(True)：
        '''
         将线程声明为守护线程，必须在start() 方法调用之前设置，如果不设置为守护线程程序会被无限挂起。

         当我们在程序运行中，执行一个主线程，如果主线程又创建一个子线程，主线程和子线程 就分兵两路，分别运行，那么当主线程完成

         想退出时，会检验子线程是否完成。如果子线程未完成，则主线程会等待子线程完成后再退出。但是有时候我们需要的是只要主线程

         完成了，不管子线程是否完成，都要和主线程一起退出，这时就可以 用setDaemon方法啦
'''
         
import threading
from time import ctime,sleep

def music(name):
	print('{name} Begin listen music {time}'.format(name=name,time=ctime()))
	sleep(3)
	print('{name} End listen music {time}'.format(name=name,time=ctime()))

def blog(name):
	print('{name} Begin write blog {time}'.format(name=name,time=ctime()))
	sleep(5)
	print('{name} End write blog {time}'.format(name=name,time=ctime()))

t1 = threading.Thread(target=music,args=('Tony',))
t2 = threading.Thread(target=blog,args=('Xiaoming',))

thread = []

thread.append(t1)
thread.append(t2)

if __name__ == '__main__':
	t2.setDaemon(True) #设在start()之前，主线程结束,则该守护线程也结束。
	for t in thread:
		t.start()
		#t.join() #这里加join()的话,则会在t1线程结束前阻塞主线程，的for循环，t2和主线程不执行

	#t1.join()#这里加join()，t1线程和t2线程同时执行，主线程阻塞
	#t2.join()
	sleep(2)
	print('End!!')
```
当daemon被设置为True时，如果主线程退出，那么子线程也将跟着退出，反之，子线程将继续运行，直到正常退出。
ps.在python3.5自带的IDE里面貌似有BUG，主线程结算之后还是会接着运行声明的守护线程。
#### 多线程实例其他方法
```python
#Thread实例对象的方法
	#isAlive():返回线程是否活动
	#getName():返回线程名
	#setName():设置线程名称
#threading模块其他方法
	#threading.currentThread(): 返回当前的线程变量
	#threading.enumerate():返回正在运行的线程list。正在运行包括启动后和结束前，不包括启动前和终止后的线程。
	#threading.activeCount():返回正在运行的线程数，和len(threading.enumerate())返回相同值。
```
### GIL